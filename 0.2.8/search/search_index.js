var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#unreal-engine-ayon-integration","title":"Unreal Engine AYON Integration","text":"<p>This is repository for addon to AYON integration Unreal Engine Editor.</p> <p>For more information go to documentation.</p>"},{"location":"index.html#building","title":"Building","text":"<ul> <li>run <code>python ./create_package.py</code></li> <li>upload resulting zip for <code>package</code> directory to your AYON server instance.</li> <li>add installed version to your bundle</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_unreal<ul> <li>addon</li> <li>api<ul> <li>helpers</li> <li>hierarchy</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>rendering</li> <li>tools_ui</li> </ul> </li> <li>hooks<ul> <li>pre_pyside_install</li> <li>pre_workfile_preparation</li> </ul> </li> <li>lib</li> <li>plugins<ul> <li>create<ul> <li>create_camera</li> <li>create_layout</li> <li>create_render</li> <li>create_staticmeshfbx</li> <li>create_uasset</li> </ul> </li> <li>inventory<ul> <li>connect_animation_to_sequence</li> <li>delete_unused_assets</li> <li>update_actors</li> </ul> </li> <li>load<ul> <li>load_alembic_animation</li> <li>load_animation</li> <li>load_camera</li> <li>load_geometrycache_abc</li> <li>load_image_png</li> <li>load_layout</li> <li>load_layout_existing</li> <li>load_skeletalmesh_abc</li> <li>load_skeletalmesh_fbx</li> <li>load_staticmesh_abc</li> <li>load_staticmesh_fbx</li> <li>load_uasset</li> <li>load_yeticache</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_frame_range</li> <li>collect_instance_members</li> <li>collect_remove_marked</li> <li>collect_render_files</li> <li>create_farm_render_instances</li> <li>extract_camera</li> <li>extract_fbx</li> <li>extract_layout</li> <li>extract_look</li> <li>extract_uasset</li> <li>switch_render_target</li> <li>validate_actors_existing_in_scene</li> <li>validate_camera_tracks</li> <li>validate_frame_range</li> <li>validate_model_content</li> <li>validate_no_dependencies</li> <li>validate_sequence_frames</li> </ul> </li> </ul> </li> <li>ue_workers</li> <li>ui<ul> <li>splash_screen</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>imageio</li> <li>import_settings</li> <li>pre_launch_settings</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_unreal/index.html","title":"ayon_unreal","text":""},{"location":"autoapi/client/ayon_unreal/index.html#client.ayon_unreal.UnrealAddon","title":"<code>UnrealAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_unreal/addon.py</code> <pre><code>class UnrealAddon(AYONAddon, IHostAddon):\n    name = \"unreal\"\n    version = __version__\n    host_name = \"unreal\"\n\n    def get_global_environments(self):\n        return {\n            \"AYON_UNREAL_ROOT\": UNREAL_ADDON_ROOT,\n        }\n\n    def add_implementation_envs(self, env, app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Set AYON_UNREAL_PLUGIN required for Unreal implementation\n        # Imports are in this method for Python 2 compatibility of an addon\n        from pathlib import Path\n\n        from .lib import get_compatible_integration\n\n        from ayon_core.tools.utils import show_message_dialog\n\n        pattern = re.compile(r'^\\d+-\\d+$')\n\n        if not pattern.match(app.name):\n            msg = (\n                \"Unreal application key in the settings must be in format\"\n                \"'5-0' or '5-1'\"\n            )\n            show_message_dialog(\n                parent=None,\n                title=\"Unreal application name format\",\n                message=msg,\n                level=\"critical\")\n            raise ValueError(msg)\n\n        ue_version = app.name.replace(\"-\", \".\")\n        unreal_plugin_path = os.path.join(\n            UNREAL_ADDON_ROOT, \"integration\", f\"UE_{ue_version}\", \"Ayon\"\n        )\n        if not Path(unreal_plugin_path).exists():\n            if compatible_versions := get_compatible_integration(\n                ue_version, Path(UNREAL_ADDON_ROOT) / \"integration\"\n            ):\n                unreal_plugin_path = compatible_versions[-1] / \"Ayon\"\n                unreal_plugin_path = unreal_plugin_path.as_posix()\n\n        if not env.get(\"AYON_UNREAL_PLUGIN\"):\n            env[\"AYON_UNREAL_PLUGIN\"] = unreal_plugin_path\n\n        # Set default environments if are not set via settings\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"UE_PYTHONPATH\": os.environ.get(\"PYTHONPATH\", \"\"),\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(UNREAL_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".uproject\"]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/index.html#client.ayon_unreal.UnrealAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_unreal/addon.py</code> <pre><code>def add_implementation_envs(self, env, app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Set AYON_UNREAL_PLUGIN required for Unreal implementation\n    # Imports are in this method for Python 2 compatibility of an addon\n    from pathlib import Path\n\n    from .lib import get_compatible_integration\n\n    from ayon_core.tools.utils import show_message_dialog\n\n    pattern = re.compile(r'^\\d+-\\d+$')\n\n    if not pattern.match(app.name):\n        msg = (\n            \"Unreal application key in the settings must be in format\"\n            \"'5-0' or '5-1'\"\n        )\n        show_message_dialog(\n            parent=None,\n            title=\"Unreal application name format\",\n            message=msg,\n            level=\"critical\")\n        raise ValueError(msg)\n\n    ue_version = app.name.replace(\"-\", \".\")\n    unreal_plugin_path = os.path.join(\n        UNREAL_ADDON_ROOT, \"integration\", f\"UE_{ue_version}\", \"Ayon\"\n    )\n    if not Path(unreal_plugin_path).exists():\n        if compatible_versions := get_compatible_integration(\n            ue_version, Path(UNREAL_ADDON_ROOT) / \"integration\"\n        ):\n            unreal_plugin_path = compatible_versions[-1] / \"Ayon\"\n            unreal_plugin_path = unreal_plugin_path.as_posix()\n\n    if not env.get(\"AYON_UNREAL_PLUGIN\"):\n        env[\"AYON_UNREAL_PLUGIN\"] = unreal_plugin_path\n\n    # Set default environments if are not set via settings\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"UE_PYTHONPATH\": os.environ.get(\"PYTHONPATH\", \"\"),\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_unreal/addon.html#client.ayon_unreal.addon.UnrealAddon","title":"<code>UnrealAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_unreal/addon.py</code> <pre><code>class UnrealAddon(AYONAddon, IHostAddon):\n    name = \"unreal\"\n    version = __version__\n    host_name = \"unreal\"\n\n    def get_global_environments(self):\n        return {\n            \"AYON_UNREAL_ROOT\": UNREAL_ADDON_ROOT,\n        }\n\n    def add_implementation_envs(self, env, app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Set AYON_UNREAL_PLUGIN required for Unreal implementation\n        # Imports are in this method for Python 2 compatibility of an addon\n        from pathlib import Path\n\n        from .lib import get_compatible_integration\n\n        from ayon_core.tools.utils import show_message_dialog\n\n        pattern = re.compile(r'^\\d+-\\d+$')\n\n        if not pattern.match(app.name):\n            msg = (\n                \"Unreal application key in the settings must be in format\"\n                \"'5-0' or '5-1'\"\n            )\n            show_message_dialog(\n                parent=None,\n                title=\"Unreal application name format\",\n                message=msg,\n                level=\"critical\")\n            raise ValueError(msg)\n\n        ue_version = app.name.replace(\"-\", \".\")\n        unreal_plugin_path = os.path.join(\n            UNREAL_ADDON_ROOT, \"integration\", f\"UE_{ue_version}\", \"Ayon\"\n        )\n        if not Path(unreal_plugin_path).exists():\n            if compatible_versions := get_compatible_integration(\n                ue_version, Path(UNREAL_ADDON_ROOT) / \"integration\"\n            ):\n                unreal_plugin_path = compatible_versions[-1] / \"Ayon\"\n                unreal_plugin_path = unreal_plugin_path.as_posix()\n\n        if not env.get(\"AYON_UNREAL_PLUGIN\"):\n            env[\"AYON_UNREAL_PLUGIN\"] = unreal_plugin_path\n\n        # Set default environments if are not set via settings\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"UE_PYTHONPATH\": os.environ.get(\"PYTHONPATH\", \"\"),\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(UNREAL_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".uproject\"]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/addon.html#client.ayon_unreal.addon.UnrealAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_unreal/addon.py</code> <pre><code>def add_implementation_envs(self, env, app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Set AYON_UNREAL_PLUGIN required for Unreal implementation\n    # Imports are in this method for Python 2 compatibility of an addon\n    from pathlib import Path\n\n    from .lib import get_compatible_integration\n\n    from ayon_core.tools.utils import show_message_dialog\n\n    pattern = re.compile(r'^\\d+-\\d+$')\n\n    if not pattern.match(app.name):\n        msg = (\n            \"Unreal application key in the settings must be in format\"\n            \"'5-0' or '5-1'\"\n        )\n        show_message_dialog(\n            parent=None,\n            title=\"Unreal application name format\",\n            message=msg,\n            level=\"critical\")\n        raise ValueError(msg)\n\n    ue_version = app.name.replace(\"-\", \".\")\n    unreal_plugin_path = os.path.join(\n        UNREAL_ADDON_ROOT, \"integration\", f\"UE_{ue_version}\", \"Ayon\"\n    )\n    if not Path(unreal_plugin_path).exists():\n        if compatible_versions := get_compatible_integration(\n            ue_version, Path(UNREAL_ADDON_ROOT) / \"integration\"\n        ):\n            unreal_plugin_path = compatible_versions[-1] / \"Ayon\"\n            unreal_plugin_path = unreal_plugin_path.as_posix()\n\n    if not env.get(\"AYON_UNREAL_PLUGIN\"):\n        env[\"AYON_UNREAL_PLUGIN\"] = unreal_plugin_path\n\n    # Set default environments if are not set via settings\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"UE_PYTHONPATH\": os.environ.get(\"PYTHONPATH\", \"\"),\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/lib.html","title":"lib","text":"<p>Unreal launching and project tools.</p>"},{"location":"autoapi/client/ayon_unreal/lib.html#client.ayon_unreal.lib.create_unreal_project","title":"<code>create_unreal_project(project_name, unreal_project_name, ue_version, pr_dir, engine_path, dev_mode=False, env=None)</code>","text":"<p>This will create <code>.uproject</code> file at specified location.</p> <p>As there is no way I know to create a project via command line, this is easiest option. Unreal project file is basically a JSON file. If we find the <code>AYON_UNREAL_PLUGIN</code> environment variable we assume this is the location of the Integration Plugin and we copy its content to the project folder and enable this plugin.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of the project in AYON.</p> required <code>unreal_project_name</code> <code>str</code> <p>Name of the project in Unreal.</p> required <code>ue_version</code> <code>str</code> <p>Unreal engine version (like 4.23).</p> required <code>pr_dir</code> <code>Path</code> <p>Path to directory where project will be created.</p> required <code>engine_path</code> <code>Path</code> <p>Path to Unreal Engine installation.</p> required <code>dev_mode</code> <code>bool</code> <p>Flag to trigger C++ style Unreal project needing Visual Studio and other tools to compile plugins from sources. This will trigger automatically if <code>Binaries</code> directory is not found in plugin folders as this indicates this is only source distribution of the plugin. Dev mode is also set in Settings.</p> <code>False</code> <code>env</code> <code>dict</code> <p>Environment to use. If not set, <code>os.environ</code>.</p> <code>None</code> Throws <p>NotImplementedError: For unsupported platforms.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Deprecated <p>since 3.16.0</p> Source code in <code>client/ayon_unreal/lib.py</code> <pre><code>def create_unreal_project(project_name: str,\n                          unreal_project_name: str,\n                          ue_version: str,\n                          pr_dir: Path,\n                          engine_path: Path,\n                          dev_mode: bool = False,\n                          env: dict = None) -&gt; None:\n    \"\"\"This will create `.uproject` file at specified location.\n\n    As there is no way I know to create a project via command line, this is\n    easiest option. Unreal project file is basically a JSON file. If we find\n    the `AYON_UNREAL_PLUGIN` environment variable we assume this is the\n    location of the Integration Plugin and we copy its content to the project\n    folder and enable this plugin.\n\n    Args:\n        project_name (str): Name of the project in AYON.\n        unreal_project_name (str): Name of the project in Unreal.\n        ue_version (str): Unreal engine version (like 4.23).\n        pr_dir (Path): Path to directory where project will be created.\n        engine_path (Path): Path to Unreal Engine installation.\n        dev_mode (bool, optional): Flag to trigger C++ style Unreal project\n            needing Visual Studio and other tools to compile plugins from\n            sources. This will trigger automatically if `Binaries`\n            directory is not found in plugin folders as this indicates\n            this is only source distribution of the plugin. Dev mode\n            is also set in Settings.\n        env (dict, optional): Environment to use. If not set, `os.environ`.\n\n    Throws:\n        NotImplementedError: For unsupported platforms.\n\n    Returns:\n        None\n\n    Deprecated:\n        since 3.16.0\n\n    \"\"\"\n\n    preset = get_project_settings(project_name)[\"unreal\"][\"project_setup\"]\n    # get unreal engine identifier\n    # -------------------------------------------------------------------------\n    # FIXME (antirotor): As of 4.26 this is problem with UE4 built from\n    # sources. In that case Engine ID is calculated per machine/user and not\n    # from Engine files as this code then reads. This then prevents UE4\n    # to directly open project as it will complain about project being\n    # created in different UE4 version. When user convert such project\n    # to his UE4 version, Engine ID is replaced in uproject file. If some\n    # other user tries to open it, it will present him with similar error.\n\n    # engine_path should be the location of UE_X.X folder\n\n    ue_editor_exe: Path = get_editor_exe_path(engine_path, ue_version)\n    cmdlet_project: Path = get_path_to_cmdlet_project(ue_version)\n\n    project_file = pr_dir / f\"{unreal_project_name}.uproject\"\n\n    print(\"--- Generating a new project ...\")\n    commandlet_cmd = [\n        ue_editor_exe.as_posix(),\n        cmdlet_project.as_posix(),\n        \"-run=AyonGenerateProject\",\n        project_file.resolve().as_posix()\n    ]\n\n    if dev_mode or preset[\"dev_mode\"]:\n        commandlet_cmd.append('-GenerateCode')\n\n    gen_process = subprocess.Popen(commandlet_cmd,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n\n    for line in gen_process.stdout:\n        print(line.decode(), end='')\n    gen_process.stdout.close()\n    return_code = gen_process.wait()\n\n    if return_code and return_code != 0:\n        raise RuntimeError(\n            (f\"Failed to generate '{unreal_project_name}' project! \"\n             f\"Exited with return code {return_code}\"))\n\n    print(\"--- Project has been generated successfully.\")\n\n    with open(project_file.as_posix(), mode=\"r+\") as pf:\n        pf_json = json.load(pf)\n        pf_json[\"EngineAssociation\"] = get_build_id(engine_path, ue_version)\n        pf.seek(0)\n        json.dump(pf_json, pf, indent=4)\n        pf.truncate()\n        print(\"--- Engine ID has been written into the project file\")\n\n    if dev_mode or preset[\"dev_mode\"]:\n        u_build_tool = get_path_to_ubt(engine_path, ue_version)\n\n        arch = \"Win64\"\n        if platform.system().lower() == \"windows\":\n            arch = \"Win64\"\n        elif platform.system().lower() == \"linux\":\n            arch = \"Linux\"\n        elif platform.system().lower() == \"darwin\":\n            # we need to test this out\n            arch = \"Mac\"\n\n        command1 = [\n            u_build_tool.as_posix(),\n            \"-projectfiles\",\n            f\"-project={project_file}\",\n            \"-progress\"\n        ]\n\n        subprocess.run(command1)\n\n        command2 = [\n            u_build_tool.as_posix(),\n            f\"-ModuleWithSuffix={unreal_project_name},3555\",\n            arch,\n            \"Development\",\n            \"-TargetType=Editor\",\n            f\"-Project={project_file}\",\n            project_file,\n            \"-IgnoreJunk\"\n        ]\n\n        subprocess.run(command2)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/lib.html#client.ayon_unreal.lib.get_compatible_integration","title":"<code>get_compatible_integration(ue_version, integration_root)</code>","text":"<p>Get path to compatible version of integration plugin.</p> <p>This will try to get the closest compatible versions to the one specified in sorted list.</p> <p>Parameters:</p> Name Type Description Default <code>ue_version</code> <code>str</code> <p>version of the current Unreal Engine.</p> required <code>integration_root</code> <code>Path</code> <p>path to built-in integration plugins.</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>list of Path: Sorted list of paths closest to the specified version.</p> Source code in <code>client/ayon_unreal/lib.py</code> <pre><code>def get_compatible_integration(\n        ue_version: str, integration_root: Path) -&gt; List[Path]:\n    \"\"\"Get path to compatible version of integration plugin.\n\n    This will try to get the closest compatible versions to the one\n    specified in sorted list.\n\n    Args:\n        ue_version (str): version of the current Unreal Engine.\n        integration_root (Path): path to built-in integration plugins.\n\n    Returns:\n        list of Path: Sorted list of paths closest to the specified\n            version.\n\n    \"\"\"\n    major, minor = ue_version.split(\".\")\n    integration_paths = [p for p in integration_root.iterdir()\n                         if p.is_dir()]\n\n    compatible_versions = []\n    for i in integration_paths:\n        # parse version from path\n        try:\n            i_major, i_minor = re.search(\n                r\"(?P&lt;major&gt;\\d+).(?P&lt;minor&gt;\\d+)$\", i.name).groups()\n        except AttributeError:\n            # in case there is no match, just skip to next\n            continue\n\n        # consider versions with different major so different that they\n        # are incompatible\n        if int(major) != int(i_major):\n            continue\n\n        compatible_versions.append(i)\n\n    sorted(set(compatible_versions))\n    return compatible_versions\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/lib.html#client.ayon_unreal.lib.get_editor_exe_path","title":"<code>get_editor_exe_path(engine_path, engine_version)</code>","text":"<p>Get UE Editor executable path.</p> Source code in <code>client/ayon_unreal/lib.py</code> <pre><code>def get_editor_exe_path(engine_path: Path, engine_version: str) -&gt; Path:\n    \"\"\"Get UE Editor executable path.\"\"\"\n    ue_path = engine_path / \"Engine/Binaries\"\n\n    ue_name = \"UnrealEditor\"\n\n    # handle older versions of Unreal Engine\n    if engine_version.split(\".\")[0] == \"4\":\n        ue_name = \"UE4Editor\"\n\n    if platform.system().lower() == \"windows\":\n            ue_path /= f\"Win64/{ue_name}.exe\"\n\n    elif platform.system().lower() == \"linux\":\n        ue_path /= f\"Linux/{ue_name}\"\n\n    elif platform.system().lower() == \"darwin\":\n        ue_path /= f\"Mac/{ue_name}\"\n\n    return ue_path\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/lib.html#client.ayon_unreal.lib.get_engine_versions","title":"<code>get_engine_versions(env=None)</code>","text":"<p>Detect Unreal Engine versions.</p> <p>This will try to detect location and versions of installed Unreal Engine. Location can be overridden by <code>UNREAL_ENGINE_LOCATION</code> environment variable.</p> <p>.. deprecated:: 3.15.4</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>dict</code> <p>Environment to use.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrderedDict</code> <p>dictionary with version as a key and dir as value. so the highest version is first.</p> Example <p>get_engine_versions() {     \"4.23\": \"C:/Epic Games/UE_4.23\",     \"4.24\": \"C:/Epic Games/UE_4.24\" }</p> Source code in <code>client/ayon_unreal/lib.py</code> <pre><code>def get_engine_versions(env=None):\n    \"\"\"Detect Unreal Engine versions.\n\n    This will try to detect location and versions of installed Unreal Engine.\n    Location can be overridden by `UNREAL_ENGINE_LOCATION` environment\n    variable.\n\n    .. deprecated:: 3.15.4\n\n    Args:\n        env (dict, optional): Environment to use.\n\n    Returns:\n        OrderedDict: dictionary with version as a key and dir as value.\n            so the highest version is first.\n\n    Example:\n        &gt;&gt;&gt; get_engine_versions()\n        {\n            \"4.23\": \"C:/Epic Games/UE_4.23\",\n            \"4.24\": \"C:/Epic Games/UE_4.24\"\n        }\n\n    \"\"\"\n    env = env or os.environ\n    engine_locations = {}\n    try:\n        root, dirs, _ = next(os.walk(env[\"UNREAL_ENGINE_LOCATION\"]))\n\n        for directory in dirs:\n            if directory.startswith(\"UE\"):\n                try:\n                    ver = re.split(r\"[-_]\", directory)[1]\n                except IndexError:\n                    continue\n                engine_locations[ver] = os.path.join(root, directory)\n    except KeyError:\n        # environment variable not set\n        pass\n    except OSError:\n        # specified directory doesn't exist\n        pass\n    except StopIteration:\n        # specified directory doesn't exist\n        pass\n\n    # if we've got something, terminate auto-detection process\n    if engine_locations:\n        return OrderedDict(sorted(engine_locations.items()))\n\n    # else kick in platform specific detection\n    if platform.system().lower() == \"windows\":\n        return OrderedDict(sorted(_win_get_engine_versions().items()))\n    if platform.system().lower() == \"linux\":\n        # on linux, there is no installation and getting Unreal Engine involves\n        # git clone. So we'll probably depend on `UNREAL_ENGINE_LOCATION`.\n        pass\n    if platform.system().lower() == \"darwin\":\n        return OrderedDict(sorted(_darwin_get_engine_version().items()))\n\n    return OrderedDict()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ue_workers.html","title":"ue_workers","text":""},{"location":"autoapi/client/ayon_unreal/ue_workers.html#client.ayon_unreal.ue_workers.UEProjectGenerationWorker","title":"<code>UEProjectGenerationWorker</code>","text":"<p>               Bases: <code>UEWorker</code></p> Source code in <code>client/ayon_unreal/ue_workers.py</code> <pre><code>class UEProjectGenerationWorker(UEWorker):\n    stage_begin = QtCore.Signal(str)\n\n    ue_version: str = None\n    project_name: str = None\n    project_dir: Path = None\n    dev_mode = False\n\n    def setup(self, ue_version: str,\n              project_name: str,\n              unreal_project_name,\n              engine_path: Path,\n              project_dir: Path,\n              dev_mode: bool = False,\n              env: dict = None):\n        \"\"\"Set the worker with necessary parameters.\n\n        Args:\n            ue_version (str): Unreal Engine version.\n            project_name (str): Name of the project in AYON.\n            unreal_project_name (str): Name of the project in Unreal.\n            engine_path (Path): Path to the Unreal Engine.\n            project_dir (Path): Path to the project directory.\n            dev_mode (bool, optional): Whether to run the project in dev mode.\n                Defaults to False.\n            env (dict, optional): Environment variables. Defaults to None.\n\n        \"\"\"\n\n        self.ue_version = ue_version\n        self.project_dir = project_dir\n        self.env = env or os.environ\n\n        preset = get_project_settings(project_name)[\"unreal\"][\"project_setup\"]\n\n        if dev_mode or preset[\"dev_mode\"]:\n            self.dev_mode = True\n\n        self.project_name = unreal_project_name\n        self.engine_path = engine_path\n\n    def execute(self):\n        # engine_path should be the location of UE_X.X folder\n\n        ue_editor_exe = ue_lib.get_editor_exe_path(self.engine_path,\n                                                   self.ue_version)\n        cmdlet_project = ue_lib.get_path_to_cmdlet_project(self.ue_version)\n        project_file = self.project_dir / f\"{self.project_name}.uproject\"\n\n        print(\"--- Generating a new project ...\")\n        # 1st stage\n        stage_count = 2\n        if self.dev_mode:\n            stage_count = 4\n\n        self.stage_begin.emit(\n            (\"Generating a new UE project ... 1 out of \"\n             f\"{stage_count}\"))\n\n        # Need to copy the commandlet project to a temporary folder where\n        # users don't need admin rights to write to.\n        cmdlet_tmp = tempfile.TemporaryDirectory()\n        cmdlet_filename = cmdlet_project.name\n        cmdlet_dir = cmdlet_project.parent.as_posix()\n        cmdlet_tmp_name = Path(cmdlet_tmp.name)\n        cmdlet_tmp_file = cmdlet_tmp_name.joinpath(cmdlet_filename)\n        copy_tree(\n            cmdlet_dir,\n            cmdlet_tmp_name.as_posix())\n\n        commandlet_cmd = [\n            f\"{ue_editor_exe.as_posix()}\",\n            f\"{cmdlet_tmp_file.as_posix()}\",\n            \"-run=AyonGenerateProject\",\n            f\"{project_file.resolve().as_posix()}\",\n        ]\n\n        if self.dev_mode:\n            commandlet_cmd.append(\"-GenerateCode\")\n\n        gen_process = subprocess.Popen(commandlet_cmd,\n                                       stdout=subprocess.PIPE,\n                                       stderr=subprocess.PIPE)\n\n        for line in gen_process.stdout:\n            decoded_line = line.decode(errors=\"replace\")\n            print(decoded_line, end=\"\")\n            self.log.emit(decoded_line)\n        gen_process.stdout.close()\n        return_code = gen_process.wait()\n\n        cmdlet_tmp.cleanup()\n\n        if return_code and return_code != 0:\n            msg = (\n                f\"Failed to generate {self.project_name} \"\n                f\"project! Exited with return code {return_code}\"\n            )\n            self.failed.emit(msg, return_code)\n            raise RuntimeError(msg)\n\n        print(\"--- Project has been generated successfully.\")\n        self.stage_begin.emit(\n            (f\"Writing the Engine ID of the build UE ... 1\"\n             f\" out of {stage_count}\"))\n\n        if not project_file.is_file():\n            msg = (\"Failed to write the Engine ID into .uproject file! Can \"\n                   \"not read!\")\n            self.failed.emit(msg)\n            raise RuntimeError(msg)\n\n        with open(project_file.as_posix(), mode=\"r+\") as pf:\n            pf_json = json.load(pf)\n            pf_json[\"EngineAssociation\"] = ue_lib.get_build_id(\n                self.engine_path,\n                self.ue_version\n            )\n            print(pf_json[\"EngineAssociation\"])\n            pf.seek(0)\n            json.dump(pf_json, pf, indent=4)\n            pf.truncate()\n            print(\"--- Engine ID has been written into the project file\")\n\n        self.progress.emit(90)\n        if self.dev_mode:\n            # 2nd stage\n            self.stage_begin.emit(\n                (f\"Generating project files ... 2 out of \"\n                 f\"{stage_count}\"))\n\n            self.progress.emit(0)\n            ubt_path = ue_lib.get_path_to_ubt(self.engine_path,\n                                              self.ue_version)\n\n            arch = \"Win64\"\n            if platform.system().lower() == \"windows\":\n                arch = \"Win64\"\n            elif platform.system().lower() == \"linux\":\n                arch = \"Linux\"\n            elif platform.system().lower() == \"darwin\":\n                # we need to test this out\n                arch = \"Mac\"\n\n            gen_prj_files_cmd = [ubt_path.as_posix(),\n                                 \"-projectfiles\",\n                                 f\"-project={project_file}\",\n                                 \"-progress\"]\n            gen_proc = subprocess.Popen(gen_prj_files_cmd,\n                                        stdout=subprocess.PIPE,\n                                        stderr=subprocess.PIPE)\n            for line in gen_proc.stdout:\n                decoded_line: str = line.decode(errors=\"replace\")\n                print(decoded_line, end=\"\")\n                self.log.emit(decoded_line)\n                parse_prj_progress(decoded_line, self.progress)\n\n            gen_proc.stdout.close()\n            return_code = gen_proc.wait()\n\n            if return_code and return_code != 0:\n                msg = (\"Failed to generate project files! \"\n                       f\"Exited with return code {return_code}\")\n                self.failed.emit(msg, return_code)\n                raise RuntimeError(msg)\n\n            self.stage_begin.emit(\n                f\"Building the project ... 3 out of {stage_count}\")\n            self.progress.emit(0)\n            # 3rd stage\n            build_prj_cmd = [ubt_path.as_posix(),\n                             f\"-ModuleWithSuffix={self.project_name},3555\",\n                             arch,\n                             \"Development\",\n                             \"-TargetType=Editor\",\n                             f\"-Project={project_file}\",\n                             f\"{project_file}\",\n                             \"-IgnoreJunk\"]\n\n            build_prj_proc = subprocess.Popen(build_prj_cmd,\n                                              stdout=subprocess.PIPE,\n                                              stderr=subprocess.PIPE)\n            for line in build_prj_proc.stdout:\n                decoded_line: str = line.decode(errors=\"replace\")\n                print(decoded_line, end=\"\")\n                self.log.emit(decoded_line)\n                parse_comp_progress(decoded_line, self.progress)\n\n            build_prj_proc.stdout.close()\n            return_code = build_prj_proc.wait()\n\n            if return_code and return_code != 0:\n                msg = (\"Failed to build project! \"\n                       f\"Exited with return code {return_code}\")\n                self.failed.emit(msg, return_code)\n                raise RuntimeError(msg)\n\n        self.progress.emit(100)\n        self.finished.emit(\"Project successfully built!\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ue_workers.html#client.ayon_unreal.ue_workers.UEProjectGenerationWorker.setup","title":"<code>setup(ue_version, project_name, unreal_project_name, engine_path, project_dir, dev_mode=False, env=None)</code>","text":"<p>Set the worker with necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>ue_version</code> <code>str</code> <p>Unreal Engine version.</p> required <code>project_name</code> <code>str</code> <p>Name of the project in AYON.</p> required <code>unreal_project_name</code> <code>str</code> <p>Name of the project in Unreal.</p> required <code>engine_path</code> <code>Path</code> <p>Path to the Unreal Engine.</p> required <code>project_dir</code> <code>Path</code> <p>Path to the project directory.</p> required <code>dev_mode</code> <code>bool</code> <p>Whether to run the project in dev mode. Defaults to False.</p> <code>False</code> <code>env</code> <code>dict</code> <p>Environment variables. Defaults to None.</p> <code>None</code> Source code in <code>client/ayon_unreal/ue_workers.py</code> <pre><code>def setup(self, ue_version: str,\n          project_name: str,\n          unreal_project_name,\n          engine_path: Path,\n          project_dir: Path,\n          dev_mode: bool = False,\n          env: dict = None):\n    \"\"\"Set the worker with necessary parameters.\n\n    Args:\n        ue_version (str): Unreal Engine version.\n        project_name (str): Name of the project in AYON.\n        unreal_project_name (str): Name of the project in Unreal.\n        engine_path (Path): Path to the Unreal Engine.\n        project_dir (Path): Path to the project directory.\n        dev_mode (bool, optional): Whether to run the project in dev mode.\n            Defaults to False.\n        env (dict, optional): Environment variables. Defaults to None.\n\n    \"\"\"\n\n    self.ue_version = ue_version\n    self.project_dir = project_dir\n    self.env = env or os.environ\n\n    preset = get_project_settings(project_name)[\"unreal\"][\"project_setup\"]\n\n    if dev_mode or preset[\"dev_mode\"]:\n        self.dev_mode = True\n\n    self.project_name = unreal_project_name\n    self.engine_path = engine_path\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/version.html","title":"version","text":"<p>Package declaring AYON addon 'unreal' version.</p>"},{"location":"autoapi/client/ayon_unreal/api/index.html","title":"api","text":"<p>Unreal Editor Ayon host API.</p>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>LoaderPlugin</code>, <code>ABC</code></p> <p>This serves as skeleton for future Ayon specific functionality</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class Loader(LoaderPlugin, ABC):\n    \"\"\"This serves as skeleton for future Ayon specific functionality\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealActorCreator","title":"<code>UnrealActorCreator</code>","text":"<p>               Bases: <code>UnrealBaseCreator</code></p> <p>Base class for Unreal creator plugins based on actors.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealActorCreator(UnrealBaseCreator):\n    \"\"\"Base class for Unreal creator plugins based on actors.\"\"\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Create instance of the asset.\n\n        Args:\n            product_name (str): Name of the product.\n            instance_data (dict): Data for the instance.\n            pre_create_data (dict): Data for the instance.\n\n        Returns:\n            CreatedInstance: Created instance.\n        \"\"\"\n        try:\n            if UNREAL_VERSION.major == 5:\n                world = unreal.UnrealEditorSubsystem().get_editor_world()\n            else:\n                world = unreal.EditorLevelLibrary.get_editor_world()\n\n            # Check if the level is saved\n            if world.get_path_name().startswith(\"/Temp/\"):\n                raise CreatorError(\n                    \"Level must be saved before creating instances.\")\n\n            # Check if instance data has members, filled by the plugin.\n            # If not, use selection.\n            if not instance_data.get(\"members\"):\n                actor_subsystem = unreal.EditorActorSubsystem()\n                sel_actors = actor_subsystem.get_selected_level_actors()\n                selection = [a.get_path_name() for a in sel_actors]\n\n                instance_data[\"members\"] = selection\n            instance_data[\"level\"] = world.get_path_name()\n\n            super(UnrealActorCreator, self).create(\n                product_name,\n                instance_data,\n                pre_create_data)\n\n        except Exception as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n\n    def get_pre_create_attr_defs(self):\n        return [\n            UILabelDef(\"Select actors to create instance from them.\"),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealActorCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create instance of the asset.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the product.</p> required <code>instance_data</code> <code>dict</code> <p>Data for the instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data for the instance.</p> required <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <p>Created instance.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Create instance of the asset.\n\n    Args:\n        product_name (str): Name of the product.\n        instance_data (dict): Data for the instance.\n        pre_create_data (dict): Data for the instance.\n\n    Returns:\n        CreatedInstance: Created instance.\n    \"\"\"\n    try:\n        if UNREAL_VERSION.major == 5:\n            world = unreal.UnrealEditorSubsystem().get_editor_world()\n        else:\n            world = unreal.EditorLevelLibrary.get_editor_world()\n\n        # Check if the level is saved\n        if world.get_path_name().startswith(\"/Temp/\"):\n            raise CreatorError(\n                \"Level must be saved before creating instances.\")\n\n        # Check if instance data has members, filled by the plugin.\n        # If not, use selection.\n        if not instance_data.get(\"members\"):\n            actor_subsystem = unreal.EditorActorSubsystem()\n            sel_actors = actor_subsystem.get_selected_level_actors()\n            selection = [a.get_path_name() for a in sel_actors]\n\n            instance_data[\"members\"] = selection\n        instance_data[\"level\"] = world.get_path_name()\n\n        super(UnrealActorCreator, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    except Exception as exc:\n        raise CreatorError(f\"Creator error: {exc}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealAssetCreator","title":"<code>UnrealAssetCreator</code>","text":"<p>               Bases: <code>UnrealBaseCreator</code></p> <p>Base class for Unreal creator plugins based on assets.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealAssetCreator(UnrealBaseCreator):\n    \"\"\"Base class for Unreal creator plugins based on assets.\"\"\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Create instance of the asset.\n\n        Args:\n            product_name (str): Name of the product.\n            instance_data (dict): Data for the instance.\n            pre_create_data (dict): Data for the instance.\n\n        Returns:\n            CreatedInstance: Created instance.\n        \"\"\"\n        try:\n            # Check if instance data has members, filled by the plugin.\n            # If not, use selection.\n            if not pre_create_data.get(\"members\"):\n                pre_create_data[\"members\"] = []\n\n                if pre_create_data.get(\"use_selection\"):\n                    utilib = unreal.EditorUtilityLibrary\n                    sel_objects = utilib.get_selected_assets()\n                    pre_create_data[\"members\"] = [\n                        a.get_path_name() for a in sel_objects]\n\n            super(UnrealAssetCreator, self).create(\n                product_name,\n                instance_data,\n                pre_create_data)\n\n        except Exception as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\", label=\"Use selection\", default=True)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealAssetCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create instance of the asset.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the product.</p> required <code>instance_data</code> <code>dict</code> <p>Data for the instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data for the instance.</p> required <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <p>Created instance.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Create instance of the asset.\n\n    Args:\n        product_name (str): Name of the product.\n        instance_data (dict): Data for the instance.\n        pre_create_data (dict): Data for the instance.\n\n    Returns:\n        CreatedInstance: Created instance.\n    \"\"\"\n    try:\n        # Check if instance data has members, filled by the plugin.\n        # If not, use selection.\n        if not pre_create_data.get(\"members\"):\n            pre_create_data[\"members\"] = []\n\n            if pre_create_data.get(\"use_selection\"):\n                utilib = unreal.EditorUtilityLibrary\n                sel_objects = utilib.get_selected_assets()\n                pre_create_data[\"members\"] = [\n                    a.get_path_name() for a in sel_objects]\n\n        super(UnrealAssetCreator, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    except Exception as exc:\n        raise CreatorError(f\"Creator error: {exc}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealHost","title":"<code>UnrealHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> <p>Unreal host implementation.</p> <p>For some time this class will re-use functions from module based implementation for backwards compatibility of older unreal projects.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>class UnrealHost(HostBase, ILoadHost, IPublishHost):\n    \"\"\"Unreal host implementation.\n\n    For some time this class will re-use functions from module based\n    implementation for backwards compatibility of older unreal projects.\n    \"\"\"\n\n    name = \"unreal\"\n\n    def install(self):\n        install()\n\n    def get_containers(self):\n        return ls()\n\n    @staticmethod\n    def show_tools_popup():\n        \"\"\"Show tools popup with actions leading to show other tools.\"\"\"\n        show_tools_popup()\n\n    @staticmethod\n    def show_tools_dialog():\n        \"\"\"Show tools dialog with actions leading to show other tools.\"\"\"\n        show_tools_dialog()\n\n    def update_context_data(self, data, changes):\n        content_path = unreal.Paths.project_content_dir()\n        op_ctx = content_path + CONTEXT_CONTAINER\n        attempts = 3\n        for i in range(attempts):\n            try:\n                with open(op_ctx, \"w+\") as f:\n                    json.dump(data, f)\n                break\n            except IOError as e:\n                if i == attempts - 1:\n                    raise Exception(\n                        \"Failed to write context data. Aborting.\") from e\n                unreal.log_warning(\"Failed to write context data. Retrying...\")\n                i += 1\n                time.sleep(3)\n                continue\n\n    def get_context_data(self):\n        content_path = unreal.Paths.project_content_dir()\n        op_ctx = content_path + CONTEXT_CONTAINER\n        if not os.path.isfile(op_ctx):\n            return {}\n        with open(op_ctx, \"r\") as fp:\n            data = json.load(fp)\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealHost.show_tools_dialog","title":"<code>show_tools_dialog()</code>  <code>staticmethod</code>","text":"<p>Show tools dialog with actions leading to show other tools.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@staticmethod\ndef show_tools_dialog():\n    \"\"\"Show tools dialog with actions leading to show other tools.\"\"\"\n    show_tools_dialog()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.UnrealHost.show_tools_popup","title":"<code>show_tools_popup()</code>  <code>staticmethod</code>","text":"<p>Show tools popup with actions leading to show other tools.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@staticmethod\ndef show_tools_popup():\n    \"\"\"Show tools popup with actions leading to show other tools.\"\"\"\n    show_tools_popup()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='_CON')</code>","text":"<p>Bundles nodes (assets) into a container and add metadata to it.</p> <p>Unreal doesn't support groups of assets that you can add metadata to. But it does support folders that helps to organize asset. Unfortunately those folders are just that - you cannot add any additional information to them. Ayon Integration Plugin is providing way out - Implementing <code>AssetContainer</code> Blueprint class. This class when added to folder can handle metadata on it using standard :func:<code>unreal.EditorAssetLibrary.set_metadata_tag()</code> and :func:<code>unreal.EditorAssetLibrary.get_metadata_tag_values()</code>. It also stores and monitor all changes in assets in path where it resides. List of those assets is available as <code>assets</code> property.</p> <p>This is list of strings starting with asset type and ending with its path: <code>Material /Game/Ayon/Test/TestMaterial.TestMaterial</code></p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def containerise(name, namespace, nodes, context, loader=None, suffix=\"_CON\"):\n    \"\"\"Bundles *nodes* (assets) into a *container* and add metadata to it.\n\n    Unreal doesn't support *groups* of assets that you can add metadata to.\n    But it does support folders that helps to organize asset. Unfortunately\n    those folders are just that - you cannot add any additional information\n    to them. Ayon Integration Plugin is providing way out - Implementing\n    `AssetContainer` Blueprint class. This class when added to folder can\n    handle metadata on it using standard\n    :func:`unreal.EditorAssetLibrary.set_metadata_tag()` and\n    :func:`unreal.EditorAssetLibrary.get_metadata_tag_values()`. It also\n    stores and monitor all changes in assets in path where it resides. List of\n    those assets is available as `assets` property.\n\n    This is list of strings starting with asset type and ending with its path:\n    `Material /Game/Ayon/Test/TestMaterial.TestMaterial`\n\n    \"\"\"\n    # 1 - create directory for container\n    root = \"/Game\"\n    container_name = f\"{name}{suffix}\"\n    new_name = move_assets_to_path(root, container_name, nodes)\n\n    # 2 - create Asset Container there\n    path = f\"{root}/{new_name}\"\n    create_container(container=container_name, path=path)\n\n    namespace = path\n\n    data = {\n        \"schema\": \"ayon:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": new_name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n    # 3 - imprint data\n    imprint(f\"{path}/{container_name}\", data)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.install","title":"<code>install()</code>","text":"<p>Install Unreal configuration for AYON.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Unreal configuration for AYON.\"\"\"\n    print(\"-=\" * 40)\n    logo = '''.\n.\n                    \u00b7\n                    \u2502\n                   \u00b7\u2219/\n                 \u00b7-\u2219\u2022\u2219-\u00b7\n              / \\\\  /\u2219\u00b7  / \\\\\n             \u2219   \\\\  \u2502  /   \u2219\n              \\\\   \\\\ \u00b7 /   /\n              \\\\\\\\   \u2219 \u2219  //\n                \\\\\\\\/   \\\\//\n                   ___\n                  \u2502   \u2502\n                  \u2502   \u2502\n                  \u2502   \u2502\n                  \u2502___\u2502\n                    -\u00b7\n\n         \u00b7-\u2500\u2550\u2500-\u2219 A Y O N \u2219-\u2500\u2550\u2500-\u00b7\n                by  YNPUT\n.\n'''\n    print(logo)\n    print(\"installing Ayon for Unreal ...\")\n    print(\"-=\" * 40)\n    logger.info(\"installing Ayon for Unreal\")\n    pyblish.api.register_host(\"unreal\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n    register_inventory_action_path(str(INVENTORY_PATH))\n    _register_callbacks()\n    _register_events()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.instantiate","title":"<code>instantiate(root, name, data, assets=None, suffix='_INS')</code>","text":"<p>Bundles nodes into container.</p> <p>Marking it with metadata as publishable instance. If assets are provided, they are moved to new path where <code>AyonPublishInstance</code> class asset is created and imprinted with metadata.</p> <p>This can then be collected for publishing by Pyblish for example.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>root path where to create instance container</p> required <code>name</code> <code>str</code> <p>name of the container</p> required <code>data</code> <code>dict</code> <p>data to imprint on container</p> required <code>assets</code> <code>list of str</code> <p>list of asset paths to include in publish                   instance</p> <code>None</code> <code>suffix</code> <code>str</code> <p>suffix string to append to instance name</p> <code>'_INS'</code> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def instantiate(root, name, data, assets=None, suffix=\"_INS\"):\n    \"\"\"Bundles *nodes* into *container*.\n\n    Marking it with metadata as publishable instance. If assets are provided,\n    they are moved to new path where `AyonPublishInstance` class asset is\n    created and imprinted with metadata.\n\n    This can then be collected for publishing by Pyblish for example.\n\n    Args:\n        root (str): root path where to create instance container\n        name (str): name of the container\n        data (dict): data to imprint on container\n        assets (list of str): list of asset paths to include in publish\n                              instance\n        suffix (str): suffix string to append to instance name\n\n    \"\"\"\n    container_name = f\"{name}{suffix}\"\n\n    # if we specify assets, create new folder and move them there. If not,\n    # just create empty folder\n    if assets:\n        new_name = move_assets_to_path(root, container_name, assets)\n    else:\n        new_name = create_folder(root, name)\n\n    path = f\"{root}/{new_name}\"\n    create_publish_instance(instance=container_name, path=path)\n\n    imprint(f\"{path}/{container_name}\", data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.ls","title":"<code>ls()</code>","text":"<p>List all containers.</p> <p>List all found in Content Manager of Unreal and return metadata from them. Adding <code>objectName</code> to set.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List all containers.\n\n    List all found in *Content Manager* of Unreal and return\n    metadata from them. Adding `objectName` to set.\n\n    \"\"\"\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n    # UE 5.1 changed how class name is specified\n    class_name = [\"/Script/Ayon\", \"AyonAssetContainer\"] if UNREAL_VERSION.major == 5 and UNREAL_VERSION.minor &gt; 0 else \"AyonAssetContainer\"  # noqa\n    ayon_containers = ar.get_assets_by_class(class_name, True)\n\n    # get_asset_by_class returns AssetData. To get all metadata we need to\n    # load asset. get_tag_values() work only on metadata registered in\n    # Asset Registry Project settings (and there is no way to set it with\n    # python short of editing ini configuration file).\n    for asset_data in ayon_containers:\n        asset = asset_data.get_asset()\n        data = unreal.EditorAssetLibrary.get_metadata_tag_values(asset)\n        data[\"objectName\"] = asset_data.asset_name\n        yield cast_map_to_str_dict(data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Stub to be either implemented or replaced.</p> <p>This is needed for old publisher implementation, but it is not supported (yet) in UE.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@contextmanager\ndef maintained_selection():\n    \"\"\"Stub to be either implemented or replaced.\n\n    This is needed for old publisher implementation, but\n    it is not supported (yet) in UE.\n    \"\"\"\n    try:\n        yield\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n    import pyblish.util\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.show_tools_dialog","title":"<code>show_tools_dialog()</code>","text":"<p>Show dialog with tools.</p> <p>Dialog will stay visible.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def show_tools_dialog():\n    \"\"\"Show dialog with tools.\n\n    Dialog will stay visible.\n    \"\"\"\n    from ayon_unreal.api import tools_ui\n\n    tools_ui.show_tools_dialog()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.show_tools_popup","title":"<code>show_tools_popup()</code>","text":"<p>Show popup with tools.</p> <p>Popup will disappear on click or losing focus.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def show_tools_popup():\n    \"\"\"Show popup with tools.\n\n    Popup will disappear on click or losing focus.\n    \"\"\"\n    from ayon_unreal.api import tools_ui\n\n    tools_ui.show_tools_popup()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/index.html#client.ayon_unreal.api.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Unreal configuration for Ayon.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Unreal configuration for Ayon.\"\"\"\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n    deregister_inventory_action_path(str(INVENTORY_PATH))\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/helpers.html","title":"helpers","text":""},{"location":"autoapi/client/ayon_unreal/api/helpers.html#client.ayon_unreal.api.helpers.AyonHelpers","title":"<code>AyonHelpers</code>","text":"<p>               Bases: <code>AyonLib</code></p> <p>Class wrapping some useful functions for Ayon.</p> <p>This class is extending native BP class in Ayon Integration Plugin.</p> Source code in <code>client/ayon_unreal/api/helpers.py</code> <pre><code>@unreal.uclass()\nclass AyonHelpers(unreal.AyonLib):\n    \"\"\"Class wrapping some useful functions for Ayon.\n\n    This class is extending native BP class in Ayon Integration Plugin.\n\n    \"\"\"\n\n    @unreal.ufunction(params=[str, unreal.LinearColor, bool])\n    def set_folder_color(self, path: str, color: unreal.LinearColor) -&gt; None:\n        \"\"\"Set color on folder in Content Browser.\n\n        This method sets color on folder in Content Browser. Unfortunately\n        there is no way to refresh Content Browser so new color isn't applied\n        immediately. They are saved to config file and appears correctly\n        only after Editor is restarted.\n\n        Args:\n            path (str): Path to folder\n            color (:class:`unreal.LinearColor`): Color of the folder\n\n        Example:\n\n            AyonHelpers().set_folder_color(\n                \"/Game/Path\", unreal.LinearColor(a=1.0, r=1.0, g=0.5, b=0)\n            )\n\n        Note:\n            This will take effect only after Editor is restarted. I couldn't\n            find a way to refresh it. Also, this saves the color definition\n            into the project config, binding this path with color. So if you\n            delete this path and later re-create, it will set this color\n            again.\n\n        \"\"\"\n        self.c_set_folder_color(path, color, False)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/helpers.html#client.ayon_unreal.api.helpers.AyonHelpers.set_folder_color","title":"<code>set_folder_color(path, color)</code>","text":"<p>Set color on folder in Content Browser.</p> <p>This method sets color on folder in Content Browser. Unfortunately there is no way to refresh Content Browser so new color isn't applied immediately. They are saved to config file and appears correctly only after Editor is restarted.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to folder</p> required <code>color</code> <p>class:<code>unreal.LinearColor</code>): Color of the folder</p> required <p>Example:</p> <pre><code>AyonHelpers().set_folder_color(\n    \"/Game/Path\", unreal.LinearColor(a=1.0, r=1.0, g=0.5, b=0)\n)\n</code></pre> Note <p>This will take effect only after Editor is restarted. I couldn't find a way to refresh it. Also, this saves the color definition into the project config, binding this path with color. So if you delete this path and later re-create, it will set this color again.</p> Source code in <code>client/ayon_unreal/api/helpers.py</code> <pre><code>@unreal.ufunction(params=[str, unreal.LinearColor, bool])\ndef set_folder_color(self, path: str, color: unreal.LinearColor) -&gt; None:\n    \"\"\"Set color on folder in Content Browser.\n\n    This method sets color on folder in Content Browser. Unfortunately\n    there is no way to refresh Content Browser so new color isn't applied\n    immediately. They are saved to config file and appears correctly\n    only after Editor is restarted.\n\n    Args:\n        path (str): Path to folder\n        color (:class:`unreal.LinearColor`): Color of the folder\n\n    Example:\n\n        AyonHelpers().set_folder_color(\n            \"/Game/Path\", unreal.LinearColor(a=1.0, r=1.0, g=0.5, b=0)\n        )\n\n    Note:\n        This will take effect only after Editor is restarted. I couldn't\n        find a way to refresh it. Also, this saves the color definition\n        into the project config, binding this path with color. So if you\n        delete this path and later re-create, it will set this color\n        again.\n\n    \"\"\"\n    self.c_set_folder_color(path, color, False)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/hierarchy.html","title":"hierarchy","text":""},{"location":"autoapi/client/ayon_unreal/api/hierarchy.html#client.ayon_unreal.api.hierarchy.FolderSelector","title":"<code>FolderSelector</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget for selecting a folder from the project hierarchy.</p> Source code in <code>client/ayon_unreal/api/hierarchy.py</code> <pre><code>class FolderSelector(QtWidgets.QWidget):\n    \"\"\"Widget for selecting a folder from the project hierarchy.\"\"\"\n\n    confirm_btn = None\n\n    def __init__(self, controller=None, parent=None, project=None):\n        if not project:\n            raise ValueError(\"Project name not provided.\")\n\n        super(FolderSelector, self).__init__(parent)\n\n        icon = QtGui.QIcon(resources.get_ayon_icon_filepath())\n        self.setWindowIcon(icon)\n        self.setWindowTitle(\"Folder Selector\")\n        self.setFocusPolicy(QtCore.Qt.StrongFocus)\n        self.setAttribute(QtCore.Qt.WA_DeleteOnClose, False)\n\n        self.setStyleSheet(style.load_stylesheet())\n\n        # Allow minimize\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.CustomizeWindowHint\n            | QtCore.Qt.WindowTitleHint\n            | QtCore.Qt.WindowMinimizeButtonHint\n            | QtCore.Qt.WindowCloseButtonHint\n        )\n\n        content_body = QtWidgets.QWidget(self)\n\n        # Folders\n        folders_wrapper = QtWidgets.QWidget(content_body)\n\n        folders_filter_text = PlaceholderLineEdit(folders_wrapper)\n        folders_filter_text.setPlaceholderText(\"Filter folders...\")\n\n        folders_widget = SimpleFoldersWidget(\n            controller=None, parent=folders_wrapper)\n        folders_widget.set_project_name(project_name=project)\n\n        folders_wrapper_layout = QtWidgets.QVBoxLayout(folders_wrapper)\n        folders_wrapper_layout.setContentsMargins(0, 0, 0, 0)\n        folders_wrapper_layout.addWidget(folders_filter_text, 0)\n        folders_wrapper_layout.addWidget(folders_widget, 1)\n\n        # Footer\n        footer_widget = QtWidgets.QWidget(content_body)\n\n        self.confirm_btn = ConfirmButton(footer_widget)\n\n        footer_layout = QtWidgets.QHBoxLayout(footer_widget)\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.addWidget(self.confirm_btn, 0)\n\n        # Main layout\n        content_layout = QtWidgets.QVBoxLayout(content_body)\n        content_layout.setContentsMargins(0, 0, 0, 0)\n        content_layout.addWidget(folders_wrapper, 1)\n        content_layout.addWidget(footer_widget, 0)\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.addWidget(content_body, 1)\n\n        folders_filter_text.textChanged.connect(\n            self._on_filter_text_changed)\n\n        self._controller = controller\n\n        self._confirm_btn = self.confirm_btn\n        self._folders_widget = folders_widget\n\n        self.resize(300, 400)\n\n        self.show()\n        self.raise_()\n        self.activateWindow()\n\n    def _on_filter_text_changed(self, text):\n        self._folders_widget.set_name_filter(text)\n\n    def get_selected_folder(self):\n        return self._folders_widget.get_selected_folder_path()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/hierarchy.html#client.ayon_unreal.api.hierarchy.build_sequence_hierarchy","title":"<code>build_sequence_hierarchy()</code>","text":"<p>Builds the sequence hierarchy by creating sequences from the root element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence root element is not found in the hierarchy.</p> Source code in <code>client/ayon_unreal/api/hierarchy.py</code> <pre><code>def build_sequence_hierarchy():\n    \"\"\"\n    Builds the sequence hierarchy by creating sequences from the root element.\n\n    Raises:\n        ValueError: If the sequence root element is not found in the hierarchy.\n    \"\"\"\n    print(\"Building sequence hierarchy...\")\n\n    project = get_current_project_name()\n\n    sequence_path = \"/Game/Ayon/\"\n\n    folder_selector = FolderSelector(project=project)\n\n    folder_selector.confirm_btn.clicked.connect(\n        lambda: _on_confirm_clicked(folder_selector, sequence_path, project)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/hierarchy.html#client.ayon_unreal.api.hierarchy.find_level_sequence","title":"<code>find_level_sequence(asset_content)</code>","text":"<p>Search level sequence already exists in the hierarchy</p> <p>Parameters:</p> Name Type Description Default <code>asset_content</code> <code>list</code> <p>List of asset contents</p> required Source code in <code>client/ayon_unreal/api/hierarchy.py</code> <pre><code>def find_level_sequence(asset_content):\n    \"\"\"\n    Search level sequence already exists in the hierarchy\n\n    Args:\n        asset_content (list): List of asset contents\n    \"\"\"\n    has_level_sequence = []\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n    for asset in asset_content:\n        content = ar.get_asset_by_object_path(asset).get_asset()\n        if content.get_class().get_name() == \"LevelSequence\":\n            has_level_sequence.append(content)\n    return has_level_sequence\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/hierarchy.html#client.ayon_unreal.api.hierarchy.save_asset_and_load_level","title":"<code>save_asset_and_load_level(asset_content, level_package, folder_selector)</code>","text":"<p>Save asset contents and load master level thus close folder selector</p> <p>Parameters:</p> Name Type Description Default <code>asset_content</code> <code>list</code> <p>List of asset contents</p> required <code>level_package</code> <code>str</code> <p>level package path</p> required <code>folder_selector(Object)</code> <p>folder selector widget</p> required Source code in <code>client/ayon_unreal/api/hierarchy.py</code> <pre><code>def save_asset_and_load_level(asset_content, level_package, folder_selector):\n    \"\"\"Save asset contents and load master level thus close\n    folder selector\n\n    Args:\n        asset_content (list): List of asset contents\n        level_package (str): level package path\n        folder_selector(Object): folder selector widget\n    \"\"\"\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    # load the master level\n    unreal.EditorLevelLibrary.load_level(level_package)\n\n    folder_selector.close()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_unreal/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.UnrealHost","title":"<code>UnrealHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> <p>Unreal host implementation.</p> <p>For some time this class will re-use functions from module based implementation for backwards compatibility of older unreal projects.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>class UnrealHost(HostBase, ILoadHost, IPublishHost):\n    \"\"\"Unreal host implementation.\n\n    For some time this class will re-use functions from module based\n    implementation for backwards compatibility of older unreal projects.\n    \"\"\"\n\n    name = \"unreal\"\n\n    def install(self):\n        install()\n\n    def get_containers(self):\n        return ls()\n\n    @staticmethod\n    def show_tools_popup():\n        \"\"\"Show tools popup with actions leading to show other tools.\"\"\"\n        show_tools_popup()\n\n    @staticmethod\n    def show_tools_dialog():\n        \"\"\"Show tools dialog with actions leading to show other tools.\"\"\"\n        show_tools_dialog()\n\n    def update_context_data(self, data, changes):\n        content_path = unreal.Paths.project_content_dir()\n        op_ctx = content_path + CONTEXT_CONTAINER\n        attempts = 3\n        for i in range(attempts):\n            try:\n                with open(op_ctx, \"w+\") as f:\n                    json.dump(data, f)\n                break\n            except IOError as e:\n                if i == attempts - 1:\n                    raise Exception(\n                        \"Failed to write context data. Aborting.\") from e\n                unreal.log_warning(\"Failed to write context data. Retrying...\")\n                i += 1\n                time.sleep(3)\n                continue\n\n    def get_context_data(self):\n        content_path = unreal.Paths.project_content_dir()\n        op_ctx = content_path + CONTEXT_CONTAINER\n        if not os.path.isfile(op_ctx):\n            return {}\n        with open(op_ctx, \"r\") as fp:\n            data = json.load(fp)\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.UnrealHost.show_tools_dialog","title":"<code>show_tools_dialog()</code>  <code>staticmethod</code>","text":"<p>Show tools dialog with actions leading to show other tools.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@staticmethod\ndef show_tools_dialog():\n    \"\"\"Show tools dialog with actions leading to show other tools.\"\"\"\n    show_tools_dialog()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.UnrealHost.show_tools_popup","title":"<code>show_tools_popup()</code>  <code>staticmethod</code>","text":"<p>Show tools popup with actions leading to show other tools.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@staticmethod\ndef show_tools_popup():\n    \"\"\"Show tools popup with actions leading to show other tools.\"\"\"\n    show_tools_popup()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.add_track","title":"<code>add_track(sequence, track)</code>","text":"<p>Backward compatibility for deprecated function of add_master_track() in UE 5.5</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>LevelSequence</code> <p>Level Sequence</p> required <p>Returns:</p> Name Type Description <code>MovieSceneTrack</code> <p>Any tracks inherited from unreal.MovieSceneTrack</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def add_track(sequence, track):\n    \"\"\"Backward compatibility for deprecated function of add_master_track() in UE 5.5\n\n    Args:\n        sequence (unreal.LevelSequence): Level Sequence\n\n    Returns:\n        MovieSceneTrack: Any tracks inherited from unreal.MovieSceneTrack\n    \"\"\"\n    if (\n        UNREAL_VERSION.major == 5\n        and UNREAL_VERSION.minor &gt; 4\n    ):\n        return sequence.add_track(track)\n    else:\n        return sequence.add_master_track(track)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.cast_map_to_str_dict","title":"<code>cast_map_to_str_dict(umap)</code>","text":"<p>Cast Unreal Map to dict.</p> <p>Helper function to cast Unreal Map object to plain old python dict. This will also cast values and keys to str. Useful for metadata dicts.</p> <p>Parameters:</p> Name Type Description Default <code>umap</code> <p>Unreal Map object</p> required <p>Returns:</p> Type Description <code>dict</code> <p>dict</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def cast_map_to_str_dict(umap) -&gt; dict:\n    \"\"\"Cast Unreal Map to dict.\n\n    Helper function to cast Unreal Map object to plain old python\n    dict. This will also cast values and keys to str. Useful for\n    metadata dicts.\n\n    Args:\n        umap: Unreal Map object\n\n    Returns:\n        dict\n\n    \"\"\"\n    return {str(key): str(value) for (key, value) in umap.items()}\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='_CON')</code>","text":"<p>Bundles nodes (assets) into a container and add metadata to it.</p> <p>Unreal doesn't support groups of assets that you can add metadata to. But it does support folders that helps to organize asset. Unfortunately those folders are just that - you cannot add any additional information to them. Ayon Integration Plugin is providing way out - Implementing <code>AssetContainer</code> Blueprint class. This class when added to folder can handle metadata on it using standard :func:<code>unreal.EditorAssetLibrary.set_metadata_tag()</code> and :func:<code>unreal.EditorAssetLibrary.get_metadata_tag_values()</code>. It also stores and monitor all changes in assets in path where it resides. List of those assets is available as <code>assets</code> property.</p> <p>This is list of strings starting with asset type and ending with its path: <code>Material /Game/Ayon/Test/TestMaterial.TestMaterial</code></p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def containerise(name, namespace, nodes, context, loader=None, suffix=\"_CON\"):\n    \"\"\"Bundles *nodes* (assets) into a *container* and add metadata to it.\n\n    Unreal doesn't support *groups* of assets that you can add metadata to.\n    But it does support folders that helps to organize asset. Unfortunately\n    those folders are just that - you cannot add any additional information\n    to them. Ayon Integration Plugin is providing way out - Implementing\n    `AssetContainer` Blueprint class. This class when added to folder can\n    handle metadata on it using standard\n    :func:`unreal.EditorAssetLibrary.set_metadata_tag()` and\n    :func:`unreal.EditorAssetLibrary.get_metadata_tag_values()`. It also\n    stores and monitor all changes in assets in path where it resides. List of\n    those assets is available as `assets` property.\n\n    This is list of strings starting with asset type and ending with its path:\n    `Material /Game/Ayon/Test/TestMaterial.TestMaterial`\n\n    \"\"\"\n    # 1 - create directory for container\n    root = \"/Game\"\n    container_name = f\"{name}{suffix}\"\n    new_name = move_assets_to_path(root, container_name, nodes)\n\n    # 2 - create Asset Container there\n    path = f\"{root}/{new_name}\"\n    create_container(container=container_name, path=path)\n\n    namespace = path\n\n    data = {\n        \"schema\": \"ayon:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": new_name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n    # 3 - imprint data\n    imprint(f\"{path}/{container_name}\", data)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.create_container","title":"<code>create_container(container, path)</code>","text":"<p>Helper function to create Asset Container class on given path.</p> <p>This Asset Class helps to mark given path as Container and enable asset version control on it.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>Asset Container name</p> required <code>path</code> <code>str</code> <p>Path where to create Asset Container. This path should point into container folder</p> required <p>Returns:</p> Type Description <code>Object</code> <p>class:<code>unreal.Object</code>: instance of created asset</p> <p>Example:</p> <pre><code>create_container(\n    \"/Game/modelingFooCharacter_CON\",\n    \"modelingFooCharacter_CON\"\n)\n</code></pre> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def create_container(container: str, path: str) -&gt; unreal.Object:\n    \"\"\"Helper function to create Asset Container class on given path.\n\n    This Asset Class helps to mark given path as Container\n    and enable asset version control on it.\n\n    Args:\n        container (str): Asset Container name\n        path (str): Path where to create Asset Container. This path should\n            point into container folder\n\n    Returns:\n        :class:`unreal.Object`: instance of created asset\n\n    Example:\n\n        create_container(\n            \"/Game/modelingFooCharacter_CON\",\n            \"modelingFooCharacter_CON\"\n        )\n\n    \"\"\"\n    factory = unreal.AyonAssetContainerFactory()\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n\n    return tools.create_asset(container, path, None, factory)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.create_folder","title":"<code>create_folder(root, name)</code>","text":"<p>Create new folder.</p> <p>If folder exists, append number at the end and try again, incrementing if needed.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>path root</p> required <code>name</code> <code>str</code> <p>folder name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>folder name</p> Example <p>create_folder(\"/Game/Foo\") /Game/Foo create_folder(\"/Game/Foo\") /Game/Foo1</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def create_folder(root: str, name: str) -&gt; str:\n    \"\"\"Create new folder.\n\n    If folder exists, append number at the end and try again, incrementing\n    if needed.\n\n    Args:\n        root (str): path root\n        name (str): folder name\n\n    Returns:\n        str: folder name\n\n    Example:\n        &gt;&gt;&gt; create_folder(\"/Game/Foo\")\n        /Game/Foo\n        &gt;&gt;&gt; create_folder(\"/Game/Foo\")\n        /Game/Foo1\n\n    \"\"\"\n    eal = unreal.EditorAssetLibrary\n    index = 1\n    while True:\n        if eal.does_directory_exist(f\"{root}/{name}\"):\n            name = f\"{name}{index}\"\n            index += 1\n        else:\n            eal.make_directory(f\"{root}/{name}\")\n            break\n\n    return name\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.create_publish_instance","title":"<code>create_publish_instance(instance, path)</code>","text":"<p>Helper function to create Ayon Publish Instance on given path.</p> <p>This behaves similarly as :func:<code>create_ayon_container</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path where to create Publish Instance. This path should point into container folder</p> required <code>instance</code> <code>str</code> <p>Publish Instance name</p> required <p>Returns:</p> Type Description <code>Object</code> <p>class:<code>unreal.Object</code>: instance of created asset</p> <p>Example:</p> <pre><code>create_publish_instance(\n    \"/Game/modelingFooCharacter_INST\",\n    \"modelingFooCharacter_INST\"\n)\n</code></pre> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def create_publish_instance(instance: str, path: str) -&gt; unreal.Object:\n    \"\"\"Helper function to create Ayon Publish Instance on given path.\n\n    This behaves similarly as :func:`create_ayon_container`.\n\n    Args:\n        path (str): Path where to create Publish Instance.\n            This path should point into container folder\n        instance (str): Publish Instance name\n\n    Returns:\n        :class:`unreal.Object`: instance of created asset\n\n    Example:\n\n        create_publish_instance(\n            \"/Game/modelingFooCharacter_INST\",\n            \"modelingFooCharacter_INST\"\n        )\n\n    \"\"\"\n    factory = unreal.AyonPublishInstanceFactory()\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    return tools.create_asset(instance, path, None, factory)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.find_camera_actors_in_camera_tracks","title":"<code>find_camera_actors_in_camera_tracks(sequence)</code>","text":"<p>Find the camera actors in the tracks from the Level Sequence</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>Object</code> <p>Level Seqence Asset</p> required <p>Returns:</p> Name Type Description <code>Object</code> <code>list[Any]</code> <p>Camera Actor</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def find_camera_actors_in_camera_tracks(sequence) -&gt; list[Any]:\n    \"\"\"Find the camera actors in the tracks from the Level Sequence\n\n    Args:\n        tracks (Object): Level Seqence Asset\n\n    Returns:\n        Object: Camera Actor\n    \"\"\"\n    camera_tracks = []\n    camera_objects = []\n    camera_tracks = get_camera_tracks(sequence)\n    if camera_tracks:\n        for camera_track in camera_tracks:\n            sections = camera_track.get_sections()\n            for section in sections:\n                binding_id = section.get_camera_binding_id()\n                bound_objects = unreal.LevelSequenceEditorBlueprintLibrary.get_bound_objects(\n                    binding_id)\n                for camera_object in bound_objects:\n                    camera_objects.append(camera_object.get_path_name())\n    world =  unreal.EditorLevelLibrary.get_editor_world()\n    sel_actors = unreal.GameplayStatics().get_all_actors_of_class(\n        world, unreal.CameraActor)\n    actors = [a for a in sel_actors if a.get_path_name() in camera_objects]\n    return actors\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.format_asset_directory","title":"<code>format_asset_directory(context, directory_template)</code>","text":"<p>Setting up the asset directory path and name. Args:     name (str): Instance name     context (dict): context     directory_template (str): directory template path     extension (str, optional): file extension. Defaults to \"abc\". Returns:     tuple[str, str]: asset directory, asset name</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def format_asset_directory(context, directory_template):\n    \"\"\"Setting up the asset directory path and name.\n    Args:\n        name (str): Instance name\n        context (dict): context\n        directory_template (str): directory template path\n        extension (str, optional): file extension. Defaults to \"abc\".\n    Returns:\n        tuple[str, str]: asset directory, asset name\n    \"\"\"\n\n    data = copy.deepcopy(context)\n    if \"{product[type]}\" in directory_template:\n        unreal.warning(\n            \"Deprecated settings: AYON is using settings \"\n            \"that won't work in future releases. \"\n            \"Details: {product[type]} in the template should \"\n            \"be replaced with {product[productType]}.\"\n        )\n        directory_template = directory_template.replace(\n            \"{product[type]}\", \"{product[productType]}\")\n\n    if \"{folder[type]}\" in directory_template:\n        unreal.warning(\n            \"Deprecated settings: AYON is using settings \"\n            \"that won't work in future releases. \"\n            \"Details: {folder[type]} in the template should \"\n            \"be replaced with {folder[folderType]}.\"\n        )\n        directory_template = directory_template.replace(\n            \"{folder[type]}\", \"{folder[folderType]}\")\n\n    version = data[\"version\"][\"version\"]\n\n    # if user set {version[version]},\n    # the copied data from data[\"version\"][\"version\"] convert\n    # to set the version of the exclusive version folder\n    if version &lt; 0:\n        data[\"version\"][\"version\"] = \"hero\"\n    else:\n        data[\"version\"][\"version\"] = f\"v{version:03d}\"\n    asset_name_with_version = set_asset_name(data)\n    asset_dir = StringTemplate(directory_template).format_strict(data)\n    return f\"{AYON_ROOT_DIR}/{asset_dir}\", asset_name_with_version\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_camera_tracks","title":"<code>get_camera_tracks(sequence)</code>","text":"<p>Get the list of movie scene camera cut tracks in the level sequence</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Object</code> <p>Level Sequence</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of movie scene camera cut tracks</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_camera_tracks(sequence):\n    \"\"\"Get the list of movie scene camera cut tracks in the level sequence\n\n    Args:\n        sequence (Object): Level Sequence\n\n    Returns:\n        list: list of movie scene camera cut tracks\n    \"\"\"\n    camera_tracks = []\n    tracks = get_tracks(sequence)\n    for track in tracks:\n        if str(track).count(\"MovieSceneCameraCutTrack\"):\n            camera_tracks.append(track)\n    return camera_tracks\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_frame_range","title":"<code>get_frame_range(sequence)</code>","text":"<p>Get the Clip in/out value from the camera tracks located inside the level sequence</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Object</code> <p>Level Sequence</p> required <p>Returns:</p> Type Description <p>int32, int32 : Start Frame, End Frame</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_frame_range(sequence):\n    \"\"\"Get the Clip in/out value from the camera tracks located inside\n    the level sequence\n\n    Args:\n        sequence (Object): Level Sequence\n\n    Returns:\n        int32, int32 : Start Frame, End Frame\n    \"\"\"\n    camera_tracks = get_camera_tracks(sequence)\n    if not camera_tracks:\n        return sequence.get_playback_start(), sequence.get_playback_end()\n    for camera_track in camera_tracks:\n        sections = camera_track.get_sections()\n        for section in sections:\n            return section.get_start_frame(), section.get_end_frame()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_frame_range_from_folder_attributes","title":"<code>get_frame_range_from_folder_attributes(folder_entity=None)</code>","text":"<p>Get the current clip In/Out value Args:     folder_entity (dict): folder Entity.</p> <p>Returns:</p> Type Description <p>int, int: clipIn, clipOut.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_frame_range_from_folder_attributes(folder_entity=None):\n    \"\"\"Get the current clip In/Out value\n    Args:\n        folder_entity (dict): folder Entity.\n\n    Returns:\n        int, int: clipIn, clipOut.\n    \"\"\"\n    if folder_entity is None:\n        folder_entity = get_current_folder_entity(fields={\"attrib\"})\n    folder_attributes = folder_entity[\"attrib\"]\n    frame_start = (\n        int(folder_attributes.get(\"frameStart\"))\n        if folder_attributes.get(\"frameStart\") else 1\n    )\n    frame_end = (\n        int(folder_attributes.get(\"frameEnd\"))\n        if folder_attributes.get(\"frameEnd\") else 1\n    )\n    return frame_start, frame_end\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_sequence","title":"<code>get_sequence(files)</code>","text":"<p>Get sequence from filename.</p> <p>This will only return files if they exist on disk as it tries to collect the sequence using the filename pattern and searching for them on disk.</p> <p>Supports negative frame ranges like -001, 0000, 0001 and -0001, 0000, 0001.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>str</code> <p>List of files</p> required <p>Returns:</p> Type Description <p>Optional[list[str]]: file sequence.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_sequence(files):\n    \"\"\"Get sequence from filename.\n\n    This will only return files if they exist on disk as it tries\n    to collect the sequence using the filename pattern and searching\n    for them on disk.\n\n    Supports negative frame ranges like -001, 0000, 0001 and -0001,\n    0000, 0001.\n\n    Arguments:\n        files (str): List of files\n\n    Returns:\n        Optional[list[str]]: file sequence.\n\n    \"\"\"\n    collections, _remainder = clique.assemble(\n        files,\n        patterns=[clique.PATTERNS[\"frames\"]],\n        minimum_items=1)\n\n    if len(collections) &gt; 1:\n        raise ValueError(\n            f\"Multiple collections found for {collections}. \"\n            \"This is a bug.\")\n\n    return [os.path.basename(filename) for filename in collections[0]]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_subsequences","title":"<code>get_subsequences(sequence)</code>","text":"<p>Get list of subsequences from sequence.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>LevelSequence</code> <p>Sequence</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>LevelSequence</code> <p>List of subsequences</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_subsequences(sequence: unreal.LevelSequence):\n    \"\"\"Get list of subsequences from sequence.\n\n    Args:\n        sequence (unreal.LevelSequence): Sequence\n\n    Returns:\n        list(unreal.LevelSequence): List of subsequences\n\n    \"\"\"\n    tracks = get_tracks(sequence)\n    subscene_track = next(\n        (\n            t\n            for t in tracks\n            if t.get_class() == unreal.MovieSceneSubTrack.static_class()\n        ),\n        None,\n    )\n    if subscene_track is not None and subscene_track.get_sections():\n        return subscene_track.get_sections()\n    return []\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_top_hierarchy_folder","title":"<code>get_top_hierarchy_folder(path)</code>","text":"<p>Get top hierarchy of the path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>top hierarchy directory</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_top_hierarchy_folder(path):\n    \"\"\"Get top hierarchy of the path\n\n    Args:\n        path (str): path\n\n    Returns:\n        str: top hierarchy directory\n    \"\"\"\n    # Split the path by the directory separator '/'\n    path = path.replace(f\"{AYON_ROOT_DIR}/\", \"\")\n    # Return the first part\n    parts = [part for part in path.split('/') if part]\n    return parts[0]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.get_tracks","title":"<code>get_tracks(sequence)</code>","text":"<p>Backward compatibility for deprecated function of get_master_tracks() in UE 5.5</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>LevelSequence</code> <p>Level Sequence</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>MovieSceneTracks</code> <p>Movie scene tracks</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def get_tracks(sequence):\n    \"\"\"Backward compatibility for deprecated function of get_master_tracks() in UE 5.5\n\n    Args:\n        sequence (unreal.LevelSequence): Level Sequence\n\n    Returns:\n        Array(MovieSceneTracks): Movie scene tracks\n    \"\"\"\n    if (\n        UNREAL_VERSION.major == 5\n        and UNREAL_VERSION.minor &gt; 4\n    ):\n        return sequence.get_tracks()\n    else:\n        return sequence.get_master_tracks()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.has_asset_existing_directory","title":"<code>has_asset_existing_directory(asset_name, asset_dir)</code>","text":"<p>Check if the asset already existed Args:     asset_name (str): asset name</p> <p>Returns:</p> Name Type Description <code>str</code> <p>package path</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def has_asset_existing_directory(asset_name, asset_dir):\n    \"\"\"Check if the asset already existed\n    Args:\n        asset_name (str): asset name\n\n    Returns:\n        str: package path\n    \"\"\"\n    asset_registry = unreal.AssetRegistryHelpers.get_asset_registry()\n    all_assets = asset_registry.get_assets_by_path('/Game', recursive=True)\n    for game_asset in all_assets:\n        if game_asset.asset_name == asset_name:\n            asset_path = game_asset.get_asset().get_path_name()\n            existing_asset_dir = unreal.Paths.split(asset_path)[0]\n            existing_version_folder = existing_asset_dir.split(\"/\")[-1]\n            existing_asset_dir = existing_asset_dir.replace(existing_version_folder, \"\")\n            if existing_asset_dir != asset_dir:\n                return asset_path\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.install","title":"<code>install()</code>","text":"<p>Install Unreal configuration for AYON.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Unreal configuration for AYON.\"\"\"\n    print(\"-=\" * 40)\n    logo = '''.\n.\n                    \u00b7\n                    \u2502\n                   \u00b7\u2219/\n                 \u00b7-\u2219\u2022\u2219-\u00b7\n              / \\\\  /\u2219\u00b7  / \\\\\n             \u2219   \\\\  \u2502  /   \u2219\n              \\\\   \\\\ \u00b7 /   /\n              \\\\\\\\   \u2219 \u2219  //\n                \\\\\\\\/   \\\\//\n                   ___\n                  \u2502   \u2502\n                  \u2502   \u2502\n                  \u2502   \u2502\n                  \u2502___\u2502\n                    -\u00b7\n\n         \u00b7-\u2500\u2550\u2500-\u2219 A Y O N \u2219-\u2500\u2550\u2500-\u00b7\n                by  YNPUT\n.\n'''\n    print(logo)\n    print(\"installing Ayon for Unreal ...\")\n    print(\"-=\" * 40)\n    logger.info(\"installing Ayon for Unreal\")\n    pyblish.api.register_host(\"unreal\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n    register_inventory_action_path(str(INVENTORY_PATH))\n    _register_callbacks()\n    _register_events()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.instantiate","title":"<code>instantiate(root, name, data, assets=None, suffix='_INS')</code>","text":"<p>Bundles nodes into container.</p> <p>Marking it with metadata as publishable instance. If assets are provided, they are moved to new path where <code>AyonPublishInstance</code> class asset is created and imprinted with metadata.</p> <p>This can then be collected for publishing by Pyblish for example.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>root path where to create instance container</p> required <code>name</code> <code>str</code> <p>name of the container</p> required <code>data</code> <code>dict</code> <p>data to imprint on container</p> required <code>assets</code> <code>list of str</code> <p>list of asset paths to include in publish                   instance</p> <code>None</code> <code>suffix</code> <code>str</code> <p>suffix string to append to instance name</p> <code>'_INS'</code> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def instantiate(root, name, data, assets=None, suffix=\"_INS\"):\n    \"\"\"Bundles *nodes* into *container*.\n\n    Marking it with metadata as publishable instance. If assets are provided,\n    they are moved to new path where `AyonPublishInstance` class asset is\n    created and imprinted with metadata.\n\n    This can then be collected for publishing by Pyblish for example.\n\n    Args:\n        root (str): root path where to create instance container\n        name (str): name of the container\n        data (dict): data to imprint on container\n        assets (list of str): list of asset paths to include in publish\n                              instance\n        suffix (str): suffix string to append to instance name\n\n    \"\"\"\n    container_name = f\"{name}{suffix}\"\n\n    # if we specify assets, create new folder and move them there. If not,\n    # just create empty folder\n    if assets:\n        new_name = move_assets_to_path(root, container_name, assets)\n    else:\n        new_name = create_folder(root, name)\n\n    path = f\"{root}/{new_name}\"\n    create_publish_instance(instance=container_name, path=path)\n\n    imprint(f\"{path}/{container_name}\", data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List all containers.</p> <p>List all found in Content Manager of Unreal and return metadata from them. Adding <code>objectName</code> to set.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List all containers.\n\n    List all found in *Content Manager* of Unreal and return\n    metadata from them. Adding `objectName` to set.\n\n    \"\"\"\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n    # UE 5.1 changed how class name is specified\n    class_name = [\"/Script/Ayon\", \"AyonAssetContainer\"] if UNREAL_VERSION.major == 5 and UNREAL_VERSION.minor &gt; 0 else \"AyonAssetContainer\"  # noqa\n    ayon_containers = ar.get_assets_by_class(class_name, True)\n\n    # get_asset_by_class returns AssetData. To get all metadata we need to\n    # load asset. get_tag_values() work only on metadata registered in\n    # Asset Registry Project settings (and there is no way to set it with\n    # python short of editing ini configuration file).\n    for asset_data in ayon_containers:\n        asset = asset_data.get_asset()\n        data = unreal.EditorAssetLibrary.get_metadata_tag_values(asset)\n        data[\"objectName\"] = asset_data.asset_name\n        yield cast_map_to_str_dict(data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Stub to be either implemented or replaced.</p> <p>This is needed for old publisher implementation, but it is not supported (yet) in UE.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@contextmanager\ndef maintained_selection():\n    \"\"\"Stub to be either implemented or replaced.\n\n    This is needed for old publisher implementation, but\n    it is not supported (yet) in UE.\n    \"\"\"\n    try:\n        yield\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.move_assets_to_path","title":"<code>move_assets_to_path(root, name, assets)</code>","text":"<p>Moving (renaming) list of asset paths to new destination.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>root of the path (eg. <code>/Game</code>)</p> required <code>name</code> <code>str</code> <p>name of destination directory (eg. <code>Foo</code> )</p> required <code>assets</code> <code>list of str</code> <p>list of asset paths</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>folder name</p> Example <p>This will get paths of all assets under <code>/Game/Test</code> and move them to <code>/Game/NewTest</code>. If <code>/Game/NewTest</code> already exists, then resulting path will be <code>/Game/NewTest1</code></p> <p>assets = unreal.EditorAssetLibrary.list_assets(\"/Game/Test\") move_assets_to_path(\"/Game\", \"NewTest\", assets) NewTest</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def move_assets_to_path(root: str, name: str, assets: List[str]) -&gt; str:\n    \"\"\"Moving (renaming) list of asset paths to new destination.\n\n    Args:\n        root (str): root of the path (eg. `/Game`)\n        name (str): name of destination directory (eg. `Foo` )\n        assets (list of str): list of asset paths\n\n    Returns:\n        str: folder name\n\n    Example:\n        This will get paths of all assets under `/Game/Test` and move them\n        to `/Game/NewTest`. If `/Game/NewTest` already exists, then resulting\n        path will be `/Game/NewTest1`\n\n        &gt;&gt;&gt; assets = unreal.EditorAssetLibrary.list_assets(\"/Game/Test\")\n        &gt;&gt;&gt; move_assets_to_path(\"/Game\", \"NewTest\", assets)\n        NewTest\n\n    \"\"\"\n    eal = unreal.EditorAssetLibrary\n    name = create_folder(root, name)\n\n    unreal.log(assets)\n    for asset in assets:\n        loaded = eal.load_asset(asset)\n        eal.rename_asset(asset, f\"{root}/{name}/{loaded.get_name()}\")\n\n    return name\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.parse_container","title":"<code>parse_container(container)</code>","text":"<p>To get data from container, AyonAssetContainer must be loaded.</p> <p>Parameters:</p> Name Type Description Default <code>container(str)</code> <p>path to container</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>metadata stored on container</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def parse_container(container):\n    \"\"\"To get data from container, AyonAssetContainer must be loaded.\n\n    Args:\n        container(str): path to container\n\n    Returns:\n        dict: metadata stored on container\n    \"\"\"\n    asset = unreal.EditorAssetLibrary.load_asset(container)\n    data = unreal.EditorAssetLibrary.get_metadata_tag_values(asset)\n    data[\"objectName\"] = asset.get_name()\n    data = cast_map_to_str_dict(data)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n    import pyblish.util\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.select_camera","title":"<code>select_camera(sequence)</code>","text":"<p>Select camera during context Args:     sequence (Objects): Level Sequence Object</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>@contextmanager\ndef select_camera(sequence):\n    \"\"\"Select camera during context\n    Args:\n        sequence (Objects): Level Sequence Object\n    \"\"\"\n    camera_actors = find_camera_actors_in_camera_tracks(sequence)\n    actor_subsys = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)\n    selected_actors = actor_subsys.get_selected_level_actors()\n    actor_subsys.select_nothing()\n    for actor in camera_actors:\n        actor_subsys.set_actor_selection_state(actor, True)\n    try:\n        yield\n    finally:\n        for actor in camera_actors:\n            if actor in selected_actors:\n                actor_subsys.set_actor_selection_state(actor, True)\n            else:\n                actor_subsys.set_actor_selection_state(actor, False)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.set_asset_name","title":"<code>set_asset_name(data)</code>","text":"<p>Set the name of the asset during loading</p> <p>Parameters:</p> Name Type Description Default <code>folder_name</code> <code>str</code> <p>folder name</p> required <code>name</code> <code>str</code> <p>instance name</p> required <code>extension</code> <code>str</code> <p>extension</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>asset name</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def set_asset_name(data):\n    \"\"\"Set the name of the asset during loading\n\n    Args:\n        folder_name (str): folder name\n        name (str): instance name\n        extension (str): extension\n\n    Returns:\n        str: asset name\n    \"\"\"\n    asset_name = None,\n    name = data[\"product\"][\"name\"]\n    version = data[\"version\"][\"version\"]\n    folder_name = data[\"folder\"][\"name\"]\n    extension = data[\"representation\"][\"name\"]\n    if not extension:\n        asset_name = name\n    elif folder_name:\n        asset_name = \"{}_{}_{}_{}\".format(\n            folder_name, name, version, extension)\n    else:\n        asset_name = \"{}_{}_{}\".format(name, version, extension)\n    return asset_name\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.show_tools_dialog","title":"<code>show_tools_dialog()</code>","text":"<p>Show dialog with tools.</p> <p>Dialog will stay visible.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def show_tools_dialog():\n    \"\"\"Show dialog with tools.\n\n    Dialog will stay visible.\n    \"\"\"\n    from ayon_unreal.api import tools_ui\n\n    tools_ui.show_tools_dialog()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.show_tools_popup","title":"<code>show_tools_popup()</code>","text":"<p>Show popup with tools.</p> <p>Popup will disappear on click or losing focus.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def show_tools_popup():\n    \"\"\"Show popup with tools.\n\n    Popup will disappear on click or losing focus.\n    \"\"\"\n    from ayon_unreal.api import tools_ui\n\n    tools_ui.show_tools_popup()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/pipeline.html#client.ayon_unreal.api.pipeline.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Unreal configuration for Ayon.</p> Source code in <code>client/ayon_unreal/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Unreal configuration for Ayon.\"\"\"\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n    deregister_inventory_action_path(str(INVENTORY_PATH))\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.LayoutLoader","title":"<code>LayoutLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Layout from a JSON file</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class LayoutLoader(Loader):\n    \"\"\"Load Layout from a JSON file\"\"\"\n\n    product_types = {\"layout\"}\n    representations = {\"json\"}\n\n    label = \"Load Layout\"\n    icon = \"code-fork\"\n    color = \"orange\"\n    loaded_layout_dir = \"{folder[path]}/{product[name]}\"\n    remove_loaded_assets = False\n\n    @staticmethod\n    def _get_fbx_loader(loaders, family):\n        name = \"\"\n        if family in ['rig', 'skeletalMesh']:\n            name = \"SkeletalMeshFBXLoader\"\n        elif family in ['model', 'staticMesh']:\n            name = \"StaticMeshFBXLoader\"\n        elif family == 'camera':\n            name = \"CameraLoader\"\n\n        if name == \"\":\n\n            return None\n\n        for loader in loaders:\n            if loader.__name__ == name:\n                return loader\n\n        return None\n\n    @staticmethod\n    def _get_abc_loader(loaders, family):\n        name = \"\"\n        if family in ['rig', 'skeletalMesh']:\n            name = \"SkeletalMeshAlembicLoader\"\n        elif family in ['model', 'staticMesh']:\n            name = \"StaticMeshAlembicLoader\"\n\n        if name == \"\":\n            return None\n\n        for loader in loaders:\n            if loader.__name__ == name:\n                return loader\n\n        return None\n\n    def _transform_from_basis(self, transform, basis, unreal_import=False):\n        \"\"\"Transform a transform from a basis to a new basis.\"\"\"\n        # Get the basis matrix\n        basis_matrix = unreal.Matrix(\n            basis[0],\n            basis[1],\n            basis[2],\n            basis[3]\n        )\n        transform_matrix = unreal.Matrix(\n            transform[0],\n            transform[1],\n            transform[2],\n            transform[3]\n        )\n\n        new_transform = None\n        if unreal_import:\n            new_transform = transform_matrix * basis_matrix\n        else:\n            new_transform = (\n                basis_matrix.get_inverse() * transform_matrix * basis_matrix)\n\n        return new_transform.transform()\n\n    def _get_repre_entities_by_version_id(self, project_name, data, repre_extension, force_loaded=False):\n        version_ids = {\n            element.get(\"version\")\n            for element in data\n            if element.get(\"representation\")\n        }\n        version_ids.discard(None)\n        output = collections.defaultdict(list)\n        if not version_ids:\n            return output\n        # Extract extensions from data with backward compatibility for \"ma\"\n        extensions = {\n            element.get(\"extension\", \"ma\")\n            for element in data\n            if element.get(\"representation\")\n        }\n\n        # Update extensions based on the force_loaded flag\n        updated_extensions = set()\n\n        for ext in extensions:\n            if not force_loaded or repre_extension == \"json\":\n                if ext == \"ma\":\n                    updated_extensions.update({\"fbx\", \"abc\"})\n                else:\n                    updated_extensions.add(ext)\n            else:\n                updated_extensions.update({repre_extension})\n\n        repre_entities = ayon_api.get_representations(\n            project_name,\n            representation_names=updated_extensions,\n            version_ids=version_ids,\n            fields={\"id\", \"versionId\", \"name\"}\n        )\n        for repre_entity in repre_entities:\n            version_id = repre_entity[\"versionId\"]\n            output[version_id].append(repre_entity)\n        return output\n\n    def imprint(\n        self,\n        context,\n        folder_path,\n        folder_name,\n        loaded_assets,\n        asset_dir,\n        asset_name,\n        container_name,\n        project_name,\n        hierarchy_dir=None\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"asset\": folder_name,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"family\": context[\"product\"][\"productType\"],\n            \"loaded_assets\": loaded_assets,\n            \"project_name\": project_name\n        }\n        if hierarchy_dir is not None:\n            data[\"master_directory\"] = hierarchy_dir\n        imprint(\n            \"{}/{}\".format(asset_dir, container_name), data)\n\n    def _load_assets(self, instance_name, repre_id, product_type, repr_format):\n        all_loaders = discover_loader_plugins()\n        loaders = loaders_from_representation(\n            all_loaders, repre_id)\n\n        loader = None\n\n        if repr_format == 'fbx':\n            loader = self._get_fbx_loader(loaders, product_type)\n        elif repr_format == 'abc':\n            loader = self._get_abc_loader(loaders, product_type)\n\n        if not loader:\n            if repr_format == \"ma\":\n                msg = (\n                    f\"No valid {product_type} loader found for {repre_id} ({repr_format}), \"\n                    f\"consider using {product_type} loader (fbx/abc) instead.\"\n                )\n                self.log.warning(msg)\n            else:\n                self.log.error(\n                    f\"No valid loader found for {repre_id} \"\n                    f\"({repr_format}) \"\n                    f\"{product_type}\")\n            return\n\n        options = {\n            # \"asset_dir\": asset_dir\n        }\n\n        assets = load_container(\n            loader,\n            repre_id,\n            namespace=instance_name,\n            options=options\n        )\n        return assets\n\n    def _remove_Loaded_asset(self, container):\n        \"\"\"\n        Delete the layout. First, check if the assets loaded with the layout\n        are used by other layouts. If not, delete the assets.\n        \"\"\"\n        if self.remove_loaded_assets:\n            remove_asset_confirmation_dialog = unreal.EditorDialog.show_message(\n                \"The removal of the loaded assets\",\n                \"The layout will be removed. Do you want to delete all associated assets as well?\",\n                unreal.AppMsgType.YES_NO)\n            if (remove_asset_confirmation_dialog == unreal.AppReturnType.YES):\n                remove_loaded_asset(container)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>LoaderPlugin</code>, <code>ABC</code></p> <p>This serves as skeleton for future Ayon specific functionality</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class Loader(LoaderPlugin, ABC):\n    \"\"\"This serves as skeleton for future Ayon specific functionality\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealActorCreator","title":"<code>UnrealActorCreator</code>","text":"<p>               Bases: <code>UnrealBaseCreator</code></p> <p>Base class for Unreal creator plugins based on actors.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealActorCreator(UnrealBaseCreator):\n    \"\"\"Base class for Unreal creator plugins based on actors.\"\"\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Create instance of the asset.\n\n        Args:\n            product_name (str): Name of the product.\n            instance_data (dict): Data for the instance.\n            pre_create_data (dict): Data for the instance.\n\n        Returns:\n            CreatedInstance: Created instance.\n        \"\"\"\n        try:\n            if UNREAL_VERSION.major == 5:\n                world = unreal.UnrealEditorSubsystem().get_editor_world()\n            else:\n                world = unreal.EditorLevelLibrary.get_editor_world()\n\n            # Check if the level is saved\n            if world.get_path_name().startswith(\"/Temp/\"):\n                raise CreatorError(\n                    \"Level must be saved before creating instances.\")\n\n            # Check if instance data has members, filled by the plugin.\n            # If not, use selection.\n            if not instance_data.get(\"members\"):\n                actor_subsystem = unreal.EditorActorSubsystem()\n                sel_actors = actor_subsystem.get_selected_level_actors()\n                selection = [a.get_path_name() for a in sel_actors]\n\n                instance_data[\"members\"] = selection\n            instance_data[\"level\"] = world.get_path_name()\n\n            super(UnrealActorCreator, self).create(\n                product_name,\n                instance_data,\n                pre_create_data)\n\n        except Exception as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n\n    def get_pre_create_attr_defs(self):\n        return [\n            UILabelDef(\"Select actors to create instance from them.\"),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealActorCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create instance of the asset.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the product.</p> required <code>instance_data</code> <code>dict</code> <p>Data for the instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data for the instance.</p> required <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <p>Created instance.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Create instance of the asset.\n\n    Args:\n        product_name (str): Name of the product.\n        instance_data (dict): Data for the instance.\n        pre_create_data (dict): Data for the instance.\n\n    Returns:\n        CreatedInstance: Created instance.\n    \"\"\"\n    try:\n        if UNREAL_VERSION.major == 5:\n            world = unreal.UnrealEditorSubsystem().get_editor_world()\n        else:\n            world = unreal.EditorLevelLibrary.get_editor_world()\n\n        # Check if the level is saved\n        if world.get_path_name().startswith(\"/Temp/\"):\n            raise CreatorError(\n                \"Level must be saved before creating instances.\")\n\n        # Check if instance data has members, filled by the plugin.\n        # If not, use selection.\n        if not instance_data.get(\"members\"):\n            actor_subsystem = unreal.EditorActorSubsystem()\n            sel_actors = actor_subsystem.get_selected_level_actors()\n            selection = [a.get_path_name() for a in sel_actors]\n\n            instance_data[\"members\"] = selection\n        instance_data[\"level\"] = world.get_path_name()\n\n        super(UnrealActorCreator, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    except Exception as exc:\n        raise CreatorError(f\"Creator error: {exc}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealAssetCreator","title":"<code>UnrealAssetCreator</code>","text":"<p>               Bases: <code>UnrealBaseCreator</code></p> <p>Base class for Unreal creator plugins based on assets.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealAssetCreator(UnrealBaseCreator):\n    \"\"\"Base class for Unreal creator plugins based on assets.\"\"\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Create instance of the asset.\n\n        Args:\n            product_name (str): Name of the product.\n            instance_data (dict): Data for the instance.\n            pre_create_data (dict): Data for the instance.\n\n        Returns:\n            CreatedInstance: Created instance.\n        \"\"\"\n        try:\n            # Check if instance data has members, filled by the plugin.\n            # If not, use selection.\n            if not pre_create_data.get(\"members\"):\n                pre_create_data[\"members\"] = []\n\n                if pre_create_data.get(\"use_selection\"):\n                    utilib = unreal.EditorUtilityLibrary\n                    sel_objects = utilib.get_selected_assets()\n                    pre_create_data[\"members\"] = [\n                        a.get_path_name() for a in sel_objects]\n\n            super(UnrealAssetCreator, self).create(\n                product_name,\n                instance_data,\n                pre_create_data)\n\n        except Exception as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\", label=\"Use selection\", default=True)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealAssetCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create instance of the asset.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Name of the product.</p> required <code>instance_data</code> <code>dict</code> <p>Data for the instance.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data for the instance.</p> required <p>Returns:</p> Name Type Description <code>CreatedInstance</code> <p>Created instance.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Create instance of the asset.\n\n    Args:\n        product_name (str): Name of the product.\n        instance_data (dict): Data for the instance.\n        pre_create_data (dict): Data for the instance.\n\n    Returns:\n        CreatedInstance: Created instance.\n    \"\"\"\n    try:\n        # Check if instance data has members, filled by the plugin.\n        # If not, use selection.\n        if not pre_create_data.get(\"members\"):\n            pre_create_data[\"members\"] = []\n\n            if pre_create_data.get(\"use_selection\"):\n                utilib = unreal.EditorUtilityLibrary\n                sel_objects = utilib.get_selected_assets()\n                pre_create_data[\"members\"] = [\n                    a.get_path_name() for a in sel_objects]\n\n        super(UnrealAssetCreator, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    except Exception as exc:\n        raise CreatorError(f\"Creator error: {exc}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealBaseAutoCreator","title":"<code>UnrealBaseAutoCreator</code>","text":"<p>               Bases: <code>AutoCreator</code>, <code>UnrealCreateLogic</code></p> <p>Base class for Unreal auto creator plugins.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealBaseAutoCreator(AutoCreator, UnrealCreateLogic):\n    \"\"\"Base class for Unreal auto creator plugins.\"\"\"\n\n    def collect_instances(self):\n        return self._default_collect_instances()\n\n    def update_instances(self, update_list):\n        return self._default_update_instances(update_list)\n\n    def remove_instances(self, instances):\n        return self._default_remove_instances(instances)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealBaseCreator","title":"<code>UnrealBaseCreator</code>","text":"<p>               Bases: <code>UnrealCreateLogic</code>, <code>Creator</code></p> <p>Base class for Unreal creator plugins.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealBaseCreator(UnrealCreateLogic, Creator):\n    \"\"\"Base class for Unreal creator plugins.\"\"\"\n\n    def create(self, subset_name, instance_data, pre_create_data):\n        self.create_unreal(subset_name, instance_data, pre_create_data)\n\n    def collect_instances(self):\n        return self._default_collect_instances()\n\n    def update_instances(self, update_list):\n        return self._default_update_instances(update_list)\n\n    def remove_instances(self, instances):\n        return self._default_remove_instances(instances)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealCreateLogic","title":"<code>UnrealCreateLogic</code>","text":"<p>Universal class for logic that Unreal creators could inherit from.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>class UnrealCreateLogic():\n    \"\"\"Universal class for logic that Unreal creators could inherit from.\"\"\"\n    root = \"/Game/Ayon/AyonPublishInstances\"\n    suffix = \"_INS\"\n\n\n    @staticmethod\n    def get_cached_instances(shared_data):\n        \"\"\"Cache instances for Creators to shared data.\n\n        Create `unreal_cached_subsets` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `unreal_cached_legacy_subsets` there and fill it with\n        all legacy subsets under product_type as a key.\n\n        Args:\n            Dict[str, Any]: Shared data.\n\n        Return:\n            Dict[str, Any]: Shared data dictionary.\n\n        \"\"\"\n        if shared_data.get(\"unreal_cached_subsets\") is None:\n            unreal_cached_subsets = collections.defaultdict(list)\n            unreal_cached_legacy_subsets = collections.defaultdict(list)\n            for instance in ls_inst():\n                creator_id = instance.get(\"creator_identifier\")\n                if creator_id:\n                    unreal_cached_subsets[creator_id].append(instance)\n                else:\n                    product_type = instance.get(\"product_type\")\n                    unreal_cached_legacy_subsets[product_type].append(instance)\n\n            shared_data[\"unreal_cached_subsets\"] = unreal_cached_subsets\n            shared_data[\"unreal_cached_legacy_subsets\"] = (\n                unreal_cached_legacy_subsets\n            )\n        return shared_data\n\n    def _default_collect_instances(self):\n        # cache instances if missing\n        self.get_cached_instances(self.collection_shared_data)\n        for instance in self.collection_shared_data[\n                \"unreal_cached_subsets\"].get(self.identifier, []):\n            # Unreal saves metadata as string, so we need to convert it back\n            instance['creator_attributes'] = ast.literal_eval(\n                instance.get('creator_attributes', '{}'))\n            instance['publish_attributes'] = ast.literal_eval(\n                instance.get('publish_attributes', '{}'))\n            instance['members'] = ast.literal_eval(\n                instance.get('members', '[]'))\n            instance['families'] = ast.literal_eval(\n                instance.get('families', '[]'))\n            instance['active'] = ast.literal_eval(\n                instance.get('active', ''))\n            created_instance = CreatedInstance.from_existing(instance, self)\n            self._add_instance_to_context(created_instance)\n\n    def _default_update_instances(self, update_list):\n        for created_inst, changes in update_list:\n            instance_node = created_inst.get(\"instance_path\", \"\")\n\n            if not instance_node:\n                unreal.log_warning(\n                    f\"Instance node not found for {created_inst}\")\n                continue\n\n            new_values = {\n                key: changes[key].new_value\n                for key in changes.changed_keys\n            }\n            imprint(\n                instance_node,\n                new_values\n            )\n\n    def _default_remove_instances(self, instances):\n        for instance in instances:\n            instance_node = instance.data.get(\"instance_path\", \"\")\n            if instance_node:\n                unreal.EditorAssetLibrary.delete_asset(instance_node)\n\n            self._remove_instance_from_context(instance)\n\n\n    def create_unreal(self, product_name, instance_data, pre_create_data):\n        try:\n            instance_name = f\"{product_name}{self.suffix}\"\n            pub_instance = create_publish_instance(instance_name, self.root)\n\n            instance_data[\"product_name\"] = product_name\n            instance_data[\"instance_path\"] = f\"{self.root}/{instance_name}\"\n\n            instance = CreatedInstance(\n                self.product_type,\n                product_name,\n                instance_data,\n                self)\n            self._add_instance_to_context(instance)\n\n            pub_instance.set_editor_property('add_external_assets', True)\n            assets = pub_instance.get_editor_property('asset_data_external')\n\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n            for member in pre_create_data.get(\"members\", []):\n                obj = ar.get_asset_by_object_path(member).get_asset()\n                assets.add(obj)\n\n            imprint(f\"{self.root}/{instance_name}\",\n                    instance.data_to_store())\n\n            return instance\n\n        except Exception as exc:\n            raise CreatorError(f\"Creator error: {exc}\") from exc\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/plugin.html#client.ayon_unreal.api.plugin.UnrealCreateLogic.get_cached_instances","title":"<code>get_cached_instances(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators to shared data.</p> <p>Create <code>unreal_cached_subsets</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>unreal_cached_legacy_subsets</code> there and fill it with all legacy subsets under product_type as a key.</p> <p>Parameters:</p> Name Type Description Default <code>Dict[str,</code> <code>Any]</code> <p>Shared data.</p> required Return <p>Dict[str, Any]: Shared data dictionary.</p> Source code in <code>client/ayon_unreal/api/plugin.py</code> <pre><code>@staticmethod\ndef get_cached_instances(shared_data):\n    \"\"\"Cache instances for Creators to shared data.\n\n    Create `unreal_cached_subsets` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `unreal_cached_legacy_subsets` there and fill it with\n    all legacy subsets under product_type as a key.\n\n    Args:\n        Dict[str, Any]: Shared data.\n\n    Return:\n        Dict[str, Any]: Shared data dictionary.\n\n    \"\"\"\n    if shared_data.get(\"unreal_cached_subsets\") is None:\n        unreal_cached_subsets = collections.defaultdict(list)\n        unreal_cached_legacy_subsets = collections.defaultdict(list)\n        for instance in ls_inst():\n            creator_id = instance.get(\"creator_identifier\")\n            if creator_id:\n                unreal_cached_subsets[creator_id].append(instance)\n            else:\n                product_type = instance.get(\"product_type\")\n                unreal_cached_legacy_subsets[product_type].append(instance)\n\n        shared_data[\"unreal_cached_subsets\"] = unreal_cached_subsets\n        shared_data[\"unreal_cached_legacy_subsets\"] = (\n            unreal_cached_legacy_subsets\n        )\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/rendering.html","title":"rendering","text":""},{"location":"autoapi/client/ayon_unreal/api/rendering.html#client.ayon_unreal.api.rendering.get_render_config","title":"<code>get_render_config(project_name, project_render_settings=None)</code>","text":"<p>Returns Unreal asset from render config.</p> <p>Expects configured location of render config set in Settings. This path must contain stored render config in Unreal project Args:     project_name (str):     project_settings (dict): Project render settings from get_project_settings Returns     (str, uasset): path and UAsset Raises:     RuntimeError if no path to config is set</p> Source code in <code>client/ayon_unreal/api/rendering.py</code> <pre><code>def get_render_config(project_name, project_render_settings=None):\n    \"\"\"Returns Unreal asset from render config.\n\n    Expects configured location of render config set in Settings. This path\n    must contain stored render config in Unreal project\n    Args:\n        project_name (str):\n        project_settings (dict): Project render settings from get_project_settings\n    Returns\n        (str, uasset): path and UAsset\n    Raises:\n        RuntimeError if no path to config is set\n    \"\"\"\n    if not project_render_settings:\n        project_settings = get_project_settings(project_name)\n        project_render_settings = project_settings[\"unreal\"][\"unreal_setup\"]\n\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n    config_path = project_render_settings[\"render_config_path\"]\n\n    if not config_path:\n        raise RuntimeError(\"Please provide location for stored render \"\n            \"config in `ayon+settings://unreal/render_setup/render_config_path`\")\n\n    unreal.log(f\"Configured config path {config_path}\")\n    if not unreal.EditorAssetLibrary.does_asset_exist(config_path):\n        raise RuntimeError(f\"No config found at {config_path}\")\n\n    unreal.log(\"Found saved render configuration\")\n    config = ar.get_asset_by_object_path(config_path).get_asset()\n\n    return config_path, config\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/rendering.html#client.ayon_unreal.api.rendering.set_output_extension_from_settings","title":"<code>set_output_extension_from_settings(render_format, config)</code>","text":"<p>Forces output extension from Settings if available.</p> <p>Clear all other extensions if there is value in Settings. Args:     render_format (str): \"png\"|\"jpg\"|\"exr\"|\"bmp\"     config (unreal.MoviePipelineMasterConfig) Returns     (unreal.MoviePipelineMasterConfig)</p> Source code in <code>client/ayon_unreal/api/rendering.py</code> <pre><code>def set_output_extension_from_settings(render_format, config):\n    \"\"\"Forces output extension from Settings if available.\n\n    Clear all other extensions if there is value in Settings.\n    Args:\n        render_format (str): \"png\"|\"jpg\"|\"exr\"|\"bmp\"\n        config (unreal.MoviePipelineMasterConfig)\n    Returns\n        (unreal.MoviePipelineMasterConfig)\n    \"\"\"\n    if not render_format:\n        return config\n\n    cls_from_map = SUPPORTED_EXTENSION_MAP.get(render_format.lower())\n    if not cls_from_map:\n        return config\n\n    for ext, cls in SUPPORTED_EXTENSION_MAP.items():\n        current_sett = config.find_setting_by_class(cls)\n        if current_sett and ext == render_format:\n            return config\n        config.remove_setting(current_sett)\n\n    config.find_or_add_setting_by_class(cls_from_map)\n    return config\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/rendering.html#client.ayon_unreal.api.rendering.start_rendering","title":"<code>start_rendering()</code>","text":"<p>Start the rendering process.</p> Source code in <code>client/ayon_unreal/api/rendering.py</code> <pre><code>def start_rendering():\n    \"\"\"\n    Start the rendering process.\n    \"\"\"\n    unreal.log(\"Starting rendering...\")\n\n    # Get selected sequences\n    assets = unreal.EditorUtilityLibrary.get_selected_assets()\n\n    if not assets:\n        show_message_dialog(\n            title=\"No assets selected\",\n            message=\"No assets selected. Select a render instance.\",\n            level=\"warning\")\n        raise RuntimeError(\n            \"No assets selected. You need to select a render instance.\")\n\n    # instances = pipeline.ls_inst()\n    instances = [\n        a for a in assets\n        if a.get_class().get_name() == \"AyonPublishInstance\"]\n    if not instances:\n        show_message_dialog(\n            title=\"No AyonPublishInstance selected\",\n            message=\"No AyonPublishInstance selected. Select render instance data asset.\",      # noqa\n            level=\"warning\"\n        )\n        raise RuntimeError(\n            \"No AyonPublishInstance selected. Select render instance data asset.\")\n    inst_data = []\n\n    for i in instances:\n        data = pipeline.parse_container(i.get_path_name())\n        if data[\"productType\"] == \"render\":\n            inst_data.append(data)\n\n    try:\n        project_name = os.environ.get(\"AYON_PROJECT_NAME\")\n        anatomy = Anatomy(project_name)\n        root = anatomy.roots['renders']\n    except Exception as e:\n        raise Exception(\n            \"Could not find render root in anatomy settings.\") from e\n\n    render_dir = f\"{root}/{project_name}\"\n\n    # subsystem = unreal.get_editor_subsystem(\n    #     unreal.MoviePipelineQueueSubsystem)\n    # queue = subsystem.get_queue()\n    global queue\n    queue = unreal.MoviePipelineQueue()\n\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n    project_settings = get_project_settings(project_name)\n    render_settings = project_settings[\"unreal\"][\"render_setup\"]\n    _, config = get_render_config(project_name, render_settings)\n\n    les = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)\n    current_level = les.get_current_level()\n    current_level_name = current_level.get_outer().get_path_name()\n\n    for i in inst_data:\n        sequence = ar.get_asset_by_object_path(i[\"sequence\"]).get_asset()\n\n        sequences = [{\n            \"sequence\": sequence,\n            \"output\": f\"{i['output']}\",\n            \"frame_range\": (\n                int(float(i[\"frameStart\"])),\n                int(float(i[\"frameEnd\"])) + 1)\n        }]\n        render_list = []\n\n        # Get all the sequences to render. If there are subsequences,\n        # add them and their frame ranges to the render list. We also\n        # use the names for the output paths.\n        for seq in sequences:\n            subscenes = pipeline.get_subsequences(seq.get('sequence'))\n\n            if subscenes:\n                for sub_seq in subscenes:\n                    sequences.append({\n                        \"sequence\": sub_seq.get_sequence(),\n                        \"output\": (f\"{seq.get('output')}/\"\n                                   f\"{sub_seq.get_sequence().get_name()}\"),\n                        \"frame_range\": (\n                            sub_seq.get_start_frame(), sub_seq.get_end_frame())\n                    })\n            else:\n                # Avoid rendering camera sequences\n                if \"_camera\" not in seq.get('sequence').get_name():\n                    render_list.append(seq)\n\n        if i[\"master_level\"] != current_level_name:\n            unreal.log_warning(\n                \"{} is not the persistent level, use {} for rendering\".format(\n                i[\"master_level\"], current_level_name)\n            )\n            i[\"master_level\"] = current_level_name\n\n        # Create the rendering jobs and add them to the queue.\n        for render_setting in render_list:\n            job = queue.allocate_new_job(unreal.MoviePipelineExecutorJob)\n            job.sequence = unreal.SoftObjectPath(i[\"master_sequence\"])\n            job.map = unreal.SoftObjectPath(i[\"master_level\"])\n            job.author = \"Ayon\"\n\n            # If we have a saved configuration, copy it to the job.\n            if config:\n                job.get_configuration().copy_from(config)\n\n            job_config = job.get_configuration()\n            # User data could be used to pass data to the job, that can be\n            # read in the job's OnJobFinished callback. We could,\n            # for instance, pass the AyonPublishInstance's path to the job.\n            # job.user_data = \"\"\n\n            output_dir = render_setting.get('output')\n            shot_name = render_setting.get('sequence').get_name()\n\n            settings = job_config.find_or_add_setting_by_class(\n                unreal.MoviePipelineOutputSetting)\n            settings.output_resolution = unreal.IntPoint(1920, 1080)\n            settings.custom_start_frame = render_setting.get(\"frame_range\")[0]\n            settings.custom_end_frame = render_setting.get(\"frame_range\")[1]\n            settings.use_custom_playback_range = True\n            settings.file_name_format = f\"{shot_name}\" + \".{frame_number}\"\n            settings.output_directory.path = f\"{render_dir}/{output_dir}\"\n\n            job_config.find_or_add_setting_by_class(\n                unreal.MoviePipelineDeferredPassBase)\n\n            render_format = render_settings.get(\"render_format\",\n                                                \"png\")\n\n            set_output_extension_from_settings(render_format,\n                                               job_config)\n\n    # If there are jobs in the queue, start the rendering process.\n    if queue.get_jobs():\n        global executor\n        executor = unreal.MoviePipelinePIEExecutor()\n        preroll_frames = render_settings.get(\"preroll_frames\", 0)\n\n        settings = unreal.MoviePipelinePIEExecutorSettings()\n        settings.set_editor_property(\n            \"initial_delay_frame_count\", preroll_frames)\n\n        executor.on_executor_finished_delegate.add_callable_unique(\n            _queue_finish_callback)\n        executor.on_individual_job_finished_delegate.add_callable_unique(\n            _job_finish_callback)  # Only available on PIE Executor\n        executor.execute(queue)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/tools_ui.html","title":"tools_ui","text":""},{"location":"autoapi/client/ayon_unreal/api/tools_ui.html#client.ayon_unreal.api.tools_ui.ToolsBtnsWidget","title":"<code>ToolsBtnsWidget</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Widget containing buttons which are clickable.</p> Source code in <code>client/ayon_unreal/api/tools_ui.py</code> <pre><code>class ToolsBtnsWidget(QtWidgets.QWidget):\n    \"\"\"Widget containing buttons which are clickable.\"\"\"\n    tool_required = QtCore.Signal(str)\n\n    def __init__(self, parent=None):\n        super(ToolsBtnsWidget, self).__init__(parent)\n\n        load_btn = QtWidgets.QPushButton(\"Load...\", self)\n        publish_btn = QtWidgets.QPushButton(\"Publish...\", self)\n        manage_btn = QtWidgets.QPushButton(\"Manage...\", self)\n        render_btn = QtWidgets.QPushButton(\"Render...\", self)\n        sequence_btn = QtWidgets.QPushButton(\n            \"Build sequence hierarchy...\", self)\n        experimental_tools_btn = QtWidgets.QPushButton(\n            \"Experimental tools...\", self\n        )\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(load_btn, 0)\n        layout.addWidget(manage_btn, 0)\n        layout.addWidget(render_btn, 0)\n        layout.addWidget(publish_btn, 0)\n        layout.addWidget(sequence_btn, 0)\n        layout.addWidget(experimental_tools_btn, 0)\n        layout.addStretch(1)\n\n        load_btn.clicked.connect(self._on_load)\n        manage_btn.clicked.connect(self._on_manage)\n        render_btn.clicked.connect(self._on_render)\n        publish_btn.clicked.connect(self._on_publish)\n        sequence_btn.clicked.connect(self._on_sequence)\n        experimental_tools_btn.clicked.connect(self._on_experimental)\n\n    def _on_create(self):\n        self.tool_required.emit(\"creator\")\n\n    def _on_load(self):\n        self.tool_required.emit(\"loader\")\n\n    def _on_publish(self):\n        self.tool_required.emit(\"publisher\")\n\n    def _on_manage(self):\n        self.tool_required.emit(\"sceneinventory\")\n\n    def _on_render(self):\n        rendering.start_rendering()\n\n    def _on_sequence(self):\n        hierarchy.build_sequence_hierarchy()\n\n    def _on_experimental(self):\n        self.tool_required.emit(\"experimental_tools\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/tools_ui.html#client.ayon_unreal.api.tools_ui.ToolsDialog","title":"<code>ToolsDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog with tool buttons that will stay opened until user close it.</p> Source code in <code>client/ayon_unreal/api/tools_ui.py</code> <pre><code>class ToolsDialog(QtWidgets.QDialog):\n    \"\"\"Dialog with tool buttons that will stay opened until user close it.\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(ToolsDialog, self).__init__(*args, **kwargs)\n\n        self.setWindowTitle(\"Ayon tools\")\n        icon = QtGui.QIcon(resources.get_ayon_icon_filepath())\n        self.setWindowIcon(icon)\n\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n        self.setFocusPolicy(QtCore.Qt.StrongFocus)\n\n        tools_widget = ToolsBtnsWidget(self)\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.addWidget(tools_widget)\n\n        tools_widget.tool_required.connect(self._on_tool_require)\n        self._tools_widget = tools_widget\n\n        self._first_show = True\n\n    def sizeHint(self):\n        result = super(ToolsDialog, self).sizeHint()\n        result.setWidth(result.width() * 2)\n        return result\n\n    def showEvent(self, event):\n        super(ToolsDialog, self).showEvent(event)\n        if self._first_show:\n            self.setStyleSheet(style.load_stylesheet())\n            self._first_show = False\n\n    def _on_tool_require(self, tool_name):\n        host_tools.show_tool_by_name(tool_name, parent=self)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/tools_ui.html#client.ayon_unreal.api.tools_ui.ToolsPopup","title":"<code>ToolsPopup</code>","text":"<p>               Bases: <code>ToolsDialog</code></p> <p>Popup with tool buttons that will close when loose focus.</p> Source code in <code>client/ayon_unreal/api/tools_ui.py</code> <pre><code>class ToolsPopup(ToolsDialog):\n    \"\"\"Popup with tool buttons that will close when loose focus.\"\"\"\n    def __init__(self, *args, **kwargs):\n        super(ToolsPopup, self).__init__(*args, **kwargs)\n\n        self.setWindowFlags(\n            QtCore.Qt.FramelessWindowHint\n            | QtCore.Qt.Popup\n        )\n\n    def showEvent(self, event):\n        super(ToolsPopup, self).showEvent(event)\n        app = QtWidgets.QApplication.instance()\n        app.processEvents()\n        pos = QtGui.QCursor.pos()\n        self.move(pos)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/api/tools_ui.html#client.ayon_unreal.api.tools_ui.WindowCache","title":"<code>WindowCache</code>","text":"<p>Cached objects and methods to be used in global scope.</p> Source code in <code>client/ayon_unreal/api/tools_ui.py</code> <pre><code>class WindowCache:\n    \"\"\"Cached objects and methods to be used in global scope.\"\"\"\n    _dialog = None\n    _popup = None\n    _first_show = True\n\n    @classmethod\n    def _before_show(cls):\n        \"\"\"Create QApplication if does not exists yet.\"\"\"\n        if not cls._first_show:\n            return\n\n        cls._first_show = False\n        if not QtWidgets.QApplication.instance():\n            QtWidgets.QApplication(sys.argv)\n\n    @classmethod\n    def show_popup(cls):\n        cls._before_show()\n        with qt_app_context():\n            if cls._popup is None:\n                cls._popup = ToolsPopup()\n\n            cls._popup.show()\n\n    @classmethod\n    def show_dialog(cls):\n        cls._before_show()\n        with qt_app_context():\n            if cls._dialog is None:\n                cls._dialog = ToolsDialog()\n\n            cls._dialog.show()\n            cls._dialog.raise_()\n            cls._dialog.activateWindow()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":"<p>Install PySide2 python module to unreal's python.</p> <p>If unreal doesn't have PySide module installed, it will try to install it.</p> Note <p>This needs to be changed in the future so the UI is decoupled from the host application.</p>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding","title":"<code>InstallQtBinding</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Install Qt binding to unreal's python packages.</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>class InstallQtBinding(PreLaunchHook):\n    \"\"\"Install Qt binding to unreal's python packages.\"\"\"\n\n    app_groups = (\"unreal\")\n    launch_types = (LaunchTypes.local)\n\n    def execute(self) -&gt; None:\n        \"\"\"Entry point for the hook.\"\"\"\n        try:\n            self._execute()\n        except Exception:  # noqa: BLE001\n            self.log.warning(\n                \"Processing of %s crashed.\",\n                self.__class__.__name__, exc_info=True\n            )\n\n    @staticmethod\n    def _find_python_executable(\n            path: Path) -&gt; tuple[Union[Path, None], Union[int, None]]:\n        \"\"\"Find python executable in unreal's directory.\n\n        Args:\n            path (Path): Python Executable path.\n\n        Returns:\n            valid_path (Path): Path to python executable.\n\n        \"\"\"\n        result = subprocess.check_output([path.as_posix(), \"--version\"])\n        version_str = result.decode().strip().split()[1]\n        version_parts = version_str.split('.')\n        version_int = int(version_parts[1])\n        for version in python_versions:\n            if int(version) == version_int:\n                return version\n        return None, None\n\n\n    def _execute(self) -&gt; None:  # noqa: PLR0912, C901\n        \"\"\"Execute the hook.\n\n        Todo:\n            * This method is too complex (PLR0912). It should be refactored\n              to smaller methods.\n\n        \"\"\"\n        platform = system().lower()\n        executable = self.launch_context.executable.executable_path\n        expected_executable = \"UnrealEditor\"\n        if platform == \"windows\":\n            expected_executable += \".exe\"\n\n        if os.path.basename(executable) != expected_executable:\n            self.log.info((\n                f\"Executable does not lead to {expected_executable} file.\"\n                \"Can't determine Unreal's python to check/install\"\n                \" Qt binding.\"\n            ))\n            return\n        versions_dir = self.find_parent_directory(executable)\n        unreal_python_dir = None\n        if platform == \"windows\":\n            unreal_python_dir = os.path.join(\n                versions_dir, \"ThirdParty\", \"Python3\", \"Win64\")\n        elif platform == \"darwin\":\n            unreal_python_dir = os.path.join(\n                versions_dir, \"ThirdParty\", \"Python3\", \"Mac\", \"bin\", \"python3\")\n        else:\n            unreal_python_dir = os.path.join(\n                versions_dir, \"ThirdParty\", \"Python3\", \"Linux\", \"bin\")\n\n        if not os.path.exists(unreal_python_dir):\n            self.log.warning(\n                \"Couldn't find the directory for python executable \"\n                \"for unreal in %s\", unreal_python_dir)\n            return\n\n        if platform == \"windows\":\n            python_executable = Path(unreal_python_dir) / \"python.exe\"\n        else:\n            python_executable = Path(unreal_python_dir) / \"python\"\n\n        if not python_executable.exists():\n            self.log.warning(\n                \"Couldn't find python executable \"\n                \"for unreal %s\", python_executable.as_posix())\n\n            return\n\n        py_version = self._find_python_executable(python_executable)\n\n        unreal_settings = self.data[\"project_settings\"][\"unreal\"]\n        prelaunch_settings = unreal_settings[\"prelaunch_settings\"]\n\n        pyside_name = \"PySide6\"\n        if py_version &lt;= MAX_PYSIDE2_PYTHON_VERSION:\n            pyside_name = \"PySide2\"\n\n        # Check if PySide2 is installed and skip if yes\n        if self.is_pyside_installed(python_executable, pyside_name):\n            self.log.debug(\n                \"unreal has already installed %s.\", pyside_name)\n            return\n\n        # Install PySide2/PySide6 in unreal's python\n        if platform == \"windows\":\n            result = self.install_pyside_windows(\n                python_executable, pyside_name, prelaunch_settings)\n        else:\n            result = self.install_pyside(\n                python_executable, pyside_name, prelaunch_settings)\n\n        if result:\n            self.log.info(\n                \"Successfully installed %s module to unreal.\", pyside_name)\n        else:\n            self.log.warning(\n                \"Failed to install %s module to unreal.\", pyside_name)\n\n    def install_pyside_windows(\n            self, python_executable: Path, pyside_name: str, settings: dict) -&gt; Union[None, int]:\n        \"\"\"Install PySide2 python module to unreal's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n\n        Note:\n            This is asking for administrative right always, no matter if\n            it is actually needed or not. Unfortunately getting\n            correct permissions for directory on Windows isn't that trivial.\n            You can either use `win32security` module or run `icacls` command\n            in subprocess and parse its output.\n\n        \"\"\"\n        if settings[\"arbitrary_site_package_location\"]:\n            qt_binding_dir = self.use_arbitrary_location_for_qt(python_executable)\n        else:\n            qt_binding_dir = os.path.join(os.path.dirname(python_executable), \"Lib\")\n        args = [\n            python_executable.as_posix(),\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            pyside_name,\n            \"--target\",\n            f\"{qt_binding_dir}\"\n        ]\n\n        args = self.use_dependency_path(args, settings)\n        return_code = self.pip_install(args)\n\n        return return_code\n\n    def install_pyside(\n            self, python_executable: Path, pyside_name: str, settings: dict) -&gt; int:\n        \"\"\"Install PySide2 python module to unreal's python.\"\"\"\n        args = [\n            python_executable.as_posix(),\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            pyside_name\n        ]\n        if settings[\"arbitrary_site_package_location\"]:\n            qt_binding_dir = self.use_arbitrary_location_for_qt(python_executable)\n            args += [\"--target\", f\"{qt_binding_dir}\"]\n\n        args = self.use_dependency_path(args, settings)\n        return_code = self.pip_install(args)\n        return return_code\n\n    @staticmethod\n    def is_pyside_installed(python_executable: Path, pyside_name: str) -&gt; bool:\n        \"\"\"Check if PySide2/6 module is in unreal python env.\n\n        Args:\n            python_executable (Path): Path to python executable.\n            pyside_name (str): Name of pyside (to distinguish between PySide2\n                and PySide6).\n\n        Returns:\n            bool: True if PySide2 is installed, False otherwise.\n\n        \"\"\"\n        # Get pip list from unreal's python executable\n        args = [python_executable.as_posix(), \"-m\", \"pip\", \"list\"]\n        process = subprocess.Popen(args, stdout=subprocess.PIPE)\n        stdout, _ = process.communicate()\n        lines = stdout.decode().split(os.linesep)\n        # Second line contain dashes that define maximum length of module name.\n        #   Second column of dashes define maximum length of module version.\n        package_dashes, *_ = lines[1].split(\" \")\n        package_len = len(package_dashes)\n\n        # Got through printed lines starting at line 3\n        for idx in range(2, len(lines)):\n            line = lines[idx]\n            if not line:\n                continue\n            package_name = line[:package_len].strip()\n            if package_name.lower() == pyside_name.lower():\n                return True\n        return False\n\n    def find_parent_directory(self, file_path: str, target_dir=\"Binaries\") -&gt; str:\n        # Split the path into components\n        path_components = file_path.split(os.sep)\n\n        # Traverse the path components to find the target directory\n        for i in range(len(path_components) - 1, -1, -1):\n            if path_components[i] == target_dir:\n                # Join the components to form the target directory path\n                return os.sep.join(path_components[:i + 1])\n        return None\n\n    def use_dependency_path(self, commands: list, settings: dict) -&gt; list:\n        if not settings.get(\"use_dependency\"):\n            self.log.warning(\n                \"Skipping to install Pyside with dependency path.\")\n            return commands\n        if dependency_path := settings.get(\"dependency_path\"):\n            commands.extend(\n                [\n                    \"--no-index\",\n                    f\"--find-links={dependency_path}\"\n                ]\n            )\n        else:\n            self.log.warning(\"No dependency path filled in the setting.\")\n            return commands\n        self.log.info(f\"Using dependency path: {dependency_path}\")\n        return commands\n\n    def pip_install(self, args: list):\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2/6 and argument\n            #   \"--ignore-installed\" is to force install module to unreal\n            #   site-packages and make sure it is binary compatible\n\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True\n            )\n            process.communicate()\n\n        except PermissionError:\n            self.log.warning(\n                'Permission denied with command: \"%s\".', \" \".join(args),\n                exc_info=True)\n        except OSError as error:\n            self.log.warning(\n                'OS error has occurred: \"%s\".', error, exc_info=True)\n        except subprocess.SubprocessError:\n            pass\n        else:\n            return process.returncode == 0\n\n    def use_arbitrary_location_for_qt(self, python_executable):\n        \"\"\"Use custom location for storing PySide-related site-packages\n        and add the package paths as part of the unreal python environment\n\n        Args:\n            python_executable (Path): Python Executable\n\n        Returns:\n            str: Qt-binding directory\n        \"\"\"\n        ue_python_hash = hashlib.sha512(\n            python_executable.as_posix().encode(\"utf-8\")).hexdigest()[:8]\n\n        qt_binding_dir = (\n            Path(get_launcher_local_dir()) / \"unreal_dependencies\" / ue_python_hash\n        )\n\n        # add arbitrary_site_packages as part of the unreal python path\n        ue_pythonpath = self.launch_context.env.get(\"UE_PYTHONPATH\")\n        if ue_pythonpath:\n            ue_pythonpath = os.pathsep.join(\n                [ue_pythonpath, qt_binding_dir.as_posix()])\n        else:\n            ue_pythonpath = qt_binding_dir\n\n        self.launch_context.env[\"UE_PYTHONPATH\"] = ue_pythonpath\n\n        return qt_binding_dir.as_posix()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding.execute","title":"<code>execute()</code>","text":"<p>Entry point for the hook.</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>def execute(self) -&gt; None:\n    \"\"\"Entry point for the hook.\"\"\"\n    try:\n        self._execute()\n    except Exception:  # noqa: BLE001\n        self.log.warning(\n            \"Processing of %s crashed.\",\n            self.__class__.__name__, exc_info=True\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding.install_pyside","title":"<code>install_pyside(python_executable, pyside_name, settings)</code>","text":"<p>Install PySide2 python module to unreal's python.</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside(\n        self, python_executable: Path, pyside_name: str, settings: dict) -&gt; int:\n    \"\"\"Install PySide2 python module to unreal's python.\"\"\"\n    args = [\n        python_executable.as_posix(),\n        \"-m\",\n        \"pip\",\n        \"install\",\n        \"--ignore-installed\",\n        pyside_name\n    ]\n    if settings[\"arbitrary_site_package_location\"]:\n        qt_binding_dir = self.use_arbitrary_location_for_qt(python_executable)\n        args += [\"--target\", f\"{qt_binding_dir}\"]\n\n    args = self.use_dependency_path(args, settings)\n    return_code = self.pip_install(args)\n    return return_code\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding.install_pyside_windows","title":"<code>install_pyside_windows(python_executable, pyside_name, settings)</code>","text":"<p>Install PySide2 python module to unreal's python.</p> <p>Installation requires administration rights that's why it is required to use \"pywin32\" module which can execute command's and ask for administration rights.</p> Note <p>This is asking for administrative right always, no matter if it is actually needed or not. Unfortunately getting correct permissions for directory on Windows isn't that trivial. You can either use <code>win32security</code> module or run <code>icacls</code> command in subprocess and parse its output.</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside_windows(\n        self, python_executable: Path, pyside_name: str, settings: dict) -&gt; Union[None, int]:\n    \"\"\"Install PySide2 python module to unreal's python.\n\n    Installation requires administration rights that's why it is required\n    to use \"pywin32\" module which can execute command's and ask for\n    administration rights.\n\n    Note:\n        This is asking for administrative right always, no matter if\n        it is actually needed or not. Unfortunately getting\n        correct permissions for directory on Windows isn't that trivial.\n        You can either use `win32security` module or run `icacls` command\n        in subprocess and parse its output.\n\n    \"\"\"\n    if settings[\"arbitrary_site_package_location\"]:\n        qt_binding_dir = self.use_arbitrary_location_for_qt(python_executable)\n    else:\n        qt_binding_dir = os.path.join(os.path.dirname(python_executable), \"Lib\")\n    args = [\n        python_executable.as_posix(),\n        \"-m\",\n        \"pip\",\n        \"install\",\n        \"--ignore-installed\",\n        pyside_name,\n        \"--target\",\n        f\"{qt_binding_dir}\"\n    ]\n\n    args = self.use_dependency_path(args, settings)\n    return_code = self.pip_install(args)\n\n    return return_code\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding.is_pyside_installed","title":"<code>is_pyside_installed(python_executable, pyside_name)</code>  <code>staticmethod</code>","text":"<p>Check if PySide2/6 module is in unreal python env.</p> <p>Parameters:</p> Name Type Description Default <code>python_executable</code> <code>Path</code> <p>Path to python executable.</p> required <code>pyside_name</code> <code>str</code> <p>Name of pyside (to distinguish between PySide2 and PySide6).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if PySide2 is installed, False otherwise.</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>@staticmethod\ndef is_pyside_installed(python_executable: Path, pyside_name: str) -&gt; bool:\n    \"\"\"Check if PySide2/6 module is in unreal python env.\n\n    Args:\n        python_executable (Path): Path to python executable.\n        pyside_name (str): Name of pyside (to distinguish between PySide2\n            and PySide6).\n\n    Returns:\n        bool: True if PySide2 is installed, False otherwise.\n\n    \"\"\"\n    # Get pip list from unreal's python executable\n    args = [python_executable.as_posix(), \"-m\", \"pip\", \"list\"]\n    process = subprocess.Popen(args, stdout=subprocess.PIPE)\n    stdout, _ = process.communicate()\n    lines = stdout.decode().split(os.linesep)\n    # Second line contain dashes that define maximum length of module name.\n    #   Second column of dashes define maximum length of module version.\n    package_dashes, *_ = lines[1].split(\" \")\n    package_len = len(package_dashes)\n\n    # Got through printed lines starting at line 3\n    for idx in range(2, len(lines)):\n        line = lines[idx]\n        if not line:\n            continue\n        package_name = line[:package_len].strip()\n        if package_name.lower() == pyside_name.lower():\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_pyside_install.html#client.ayon_unreal.hooks.pre_pyside_install.InstallQtBinding.use_arbitrary_location_for_qt","title":"<code>use_arbitrary_location_for_qt(python_executable)</code>","text":"<p>Use custom location for storing PySide-related site-packages and add the package paths as part of the unreal python environment</p> <p>Parameters:</p> Name Type Description Default <code>python_executable</code> <code>Path</code> <p>Python Executable</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Qt-binding directory</p> Source code in <code>client/ayon_unreal/hooks/pre_pyside_install.py</code> <pre><code>def use_arbitrary_location_for_qt(self, python_executable):\n    \"\"\"Use custom location for storing PySide-related site-packages\n    and add the package paths as part of the unreal python environment\n\n    Args:\n        python_executable (Path): Python Executable\n\n    Returns:\n        str: Qt-binding directory\n    \"\"\"\n    ue_python_hash = hashlib.sha512(\n        python_executable.as_posix().encode(\"utf-8\")).hexdigest()[:8]\n\n    qt_binding_dir = (\n        Path(get_launcher_local_dir()) / \"unreal_dependencies\" / ue_python_hash\n    )\n\n    # add arbitrary_site_packages as part of the unreal python path\n    ue_pythonpath = self.launch_context.env.get(\"UE_PYTHONPATH\")\n    if ue_pythonpath:\n        ue_pythonpath = os.pathsep.join(\n            [ue_pythonpath, qt_binding_dir.as_posix()])\n    else:\n        ue_pythonpath = qt_binding_dir\n\n    self.launch_context.env[\"UE_PYTHONPATH\"] = ue_pythonpath\n\n    return qt_binding_dir.as_posix()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_workfile_preparation.html","title":"pre_workfile_preparation","text":"<p>Hook to launch Unreal and prepare projects.</p>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_workfile_preparation.html#client.ayon_unreal.hooks.pre_workfile_preparation.UnrealPrelaunchHook","title":"<code>UnrealPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Hook to handle launching Unreal.</p> <p>This hook will check if current workfile path has Unreal project inside. IF not, it initializes it, and finally it pass path to the project by environment variable to Unreal launcher shell script.</p> Source code in <code>client/ayon_unreal/hooks/pre_workfile_preparation.py</code> <pre><code>class UnrealPrelaunchHook(PreLaunchHook):\n    \"\"\"Hook to handle launching Unreal.\n\n    This hook will check if current workfile path has Unreal\n    project inside. IF not, it initializes it, and finally it pass\n    path to the project by environment variable to Unreal launcher\n    shell script.\n\n    \"\"\"\n    app_groups = {\"unreal\"}\n    launch_types = {LaunchTypes.local}\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.signature = f\"( {self.__class__.__name__} )\"\n\n    def _get_work_filename(self):\n        # Use last workfile if was found\n        if self.data.get(\"last_workfile_path\"):\n            last_workfile = Path(self.data.get(\"last_workfile_path\"))\n            if last_workfile and last_workfile.exists():\n                return last_workfile.name\n\n        # Prepare data for fill data and for getting workfile template key\n        anatomy = self.data[\"anatomy\"]\n        project_entity = self.data[\"project_entity\"]\n\n        # Use already prepared workdir data\n        workdir_data = copy.deepcopy(self.data[\"workdir_data\"])\n        task_type = workdir_data.get(\"task\", {}).get(\"type\")\n\n        # QUESTION raise exception if version is part of filename template?\n        workdir_data[\"version\"] = 1\n        workdir_data[\"ext\"] = \"uproject\"\n\n        # Get workfile template key for current context\n        workfile_template_key = get_workfile_template_key(\n            project_entity[\"name\"],\n            task_type,\n            self.host_name,\n        )\n        # Fill templates\n        template_obj = anatomy.get_template_item(\n            \"work\", workfile_template_key, \"file\"\n        )\n\n        # Return filename\n        return template_obj.format_strict(workdir_data)\n\n    def exec_plugin_install(self, engine_path: Path, env: dict = None):\n        # set up the QThread and worker with necessary signals\n        env = env or os.environ\n        q_thread = QtCore.QThread()\n        ue_plugin_worker = UEPluginInstallWorker()\n\n        q_thread.started.connect(ue_plugin_worker.run)\n        ue_plugin_worker.setup(engine_path, env)\n        ue_plugin_worker.moveToThread(q_thread)\n\n        splash_screen = SplashScreen(\n            \"Installing plugin\",\n            resources.get_resource(\"app_icons\", \"ue4.png\")\n        )\n\n        # set up the splash screen with necessary triggers\n        ue_plugin_worker.installing.connect(\n            splash_screen.update_top_label_text\n        )\n        ue_plugin_worker.progress.connect(splash_screen.update_progress)\n        ue_plugin_worker.log.connect(splash_screen.append_log)\n        ue_plugin_worker.finished.connect(splash_screen.quit_and_close)\n        ue_plugin_worker.failed.connect(splash_screen.fail)\n\n        splash_screen.start_thread(q_thread)\n        splash_screen.show_ui()\n\n        if not splash_screen.was_proc_successful():\n            raise ApplicationLaunchFailed(\"Couldn't run the application! \"\n                                          \"Plugin failed to install!\")\n\n    def exec_ue_project_gen(self,\n                            engine_version: str,\n                            unreal_project_name: str,\n                            engine_path: Path,\n                            project_dir: Path):\n        self.log.info((\n            f\"{self.signature} Creating unreal \"\n            f\"project [ {unreal_project_name} ]\"\n        ))\n\n        q_thread = QtCore.QThread()\n        ue_project_worker = UEProjectGenerationWorker()\n        ue_project_worker.setup(\n            engine_version,\n            self.data[\"project_name\"],\n            unreal_project_name,\n            engine_path,\n            project_dir\n        )\n        ue_project_worker.moveToThread(q_thread)\n        q_thread.started.connect(ue_project_worker.run)\n\n        splash_screen = SplashScreen(\n            \"Initializing UE project\",\n            resources.get_resource(\"app_icons\", \"ue4.png\")\n        )\n\n        ue_project_worker.stage_begin.connect(\n            splash_screen.update_top_label_text\n        )\n        ue_project_worker.progress.connect(splash_screen.update_progress)\n        ue_project_worker.log.connect(splash_screen.append_log)\n        ue_project_worker.finished.connect(splash_screen.quit_and_close)\n        ue_project_worker.failed.connect(splash_screen.fail)\n\n        splash_screen.start_thread(q_thread)\n        splash_screen.show_ui()\n\n        if not splash_screen.was_proc_successful():\n            raise ApplicationLaunchFailed(\"Couldn't run the application! \"\n                                          \"Failed to generate the project!\")\n\n    def execute(self):\n        \"\"\"Hook entry method.\"\"\"\n        workdir = self.launch_context.env[\"AYON_WORKDIR\"]\n        executable = str(self.launch_context.executable)\n        engine_version = self.app_name.split(\"/\")[-1].replace(\"-\", \".\")\n        try:\n            if int(engine_version.split(\".\")[0]) &lt; 4 and \\\n                    int(engine_version.split(\".\")[1]) &lt; 26:\n                raise ApplicationLaunchFailed((\n                    f\"{self.signature} Old unsupported version of UE \"\n                    f\"detected - {engine_version}\"))\n        except ValueError:\n            # there can be string in minor version and in that case\n            # int cast is failing. This probably happens only with\n            # early access versions and is of no concert for this check\n            # so let's keep it quiet.\n            ...\n\n        unreal_project_filename = self._get_work_filename()\n        unreal_project_name = os.path.splitext(unreal_project_filename)[0]\n        # Unreal is sensitive about project names longer then 20 chars\n        if len(unreal_project_name) &gt; 20:\n            raise ApplicationLaunchFailed(\n                f\"Project name exceeds 20 characters ({unreal_project_name})!\"\n            )\n\n        # Unreal doesn't accept non alphabet characters at the start\n        # of the project name. This is because project name is then used\n        # in various places inside c++ code and there variable names cannot\n        # start with non-alpha. We append 'P' before project name to solve it.\n        # \ud83d\ude31\n        if not unreal_project_name[:1].isalpha():\n            self.log.warning((\n                \"Project name doesn't start with alphabet \"\n                f\"character ({unreal_project_name}). Appending 'P'\"\n            ))\n            unreal_project_name = f\"P{unreal_project_name}\"\n            unreal_project_filename = f'{unreal_project_name}.uproject'\n\n        last_workfile_path = self.data.get(\"last_workfile_path\")\n        if last_workfile_path and os.path.exists(last_workfile_path):\n            project_path = Path(os.path.dirname(last_workfile_path))\n            unreal_project_filename = Path(os.path.basename(last_workfile_path))\n        else:\n            project_path = Path(os.path.join(workdir, unreal_project_name))\n            project_path.mkdir(parents=True, exist_ok=True)\n\n        self.log.info((\n            f\"{self.signature} requested UE version: \"\n            f\"[ {engine_version} ]\"\n        ))\n\n        # engine_path points to the specific Unreal Engine root\n        # so, we are going up from the executable itself 3 levels.\n        # on macOS it's 6 levels up as the executable lives under\n        # ./UnrealEditor.app/Contents/MacOS/UnrealEditor\n        if platform.system().lower() == \"darwin\":\n            engine_path: Path = Path(executable).parents[6]\n        else:\n            engine_path: Path = Path(executable).parents[3]\n\n        # Check if new env variable exists, and if it does, if the path\n        # actually contains the plugin. If not, install it.\n\n        built_plugin_path = self.launch_context.env.get(\n            \"AYON_BUILT_UNREAL_PLUGIN\", None)\n\n        if unreal_lib.check_built_plugin_existance(built_plugin_path):\n            self.log.info((\n                f\"{self.signature} using existing built Ayon plugin from \"\n                f\"{built_plugin_path}\"\n            ))\n            unreal_lib.copy_built_plugin(engine_path, Path(built_plugin_path))\n        else:\n            # Set \"AYON_UNREAL_PLUGIN\" to current process environment for\n            # execution of `create_unreal_project`\n            env_key = \"AYON_UNREAL_PLUGIN\"\n            if self.launch_context.env.get(env_key):\n                self.log.info((\n                    f\"{self.signature} using Ayon plugin from \"\n                    f\"{self.launch_context.env.get(env_key)}\"\n                ))\n            if self.launch_context.env.get(env_key):\n                os.environ[env_key] = self.launch_context.env[env_key]\n\n            if not unreal_lib.check_plugin_existence(engine_path):\n                self.exec_plugin_install(engine_path)\n\n        project_file = project_path / unreal_project_filename\n\n        if not project_file.is_file():\n\n            #Get project settings -&gt; allow project creation\n            current_project = get_current_project_name()\n            unreal_settings = get_project_settings(current_project).get(\"unreal\")\n            allow_project_creation = unreal_settings[\"project_setup\"].get(\n            \"allow_project_creation\")\n            if allow_project_creation:\n                with tempfile.TemporaryDirectory() as temp_dir:\n                    self.exec_ue_project_gen(engine_version,\n                                             unreal_project_name,\n                                             engine_path,\n                                             Path(temp_dir))\n                    try:\n                        self.log.info((\n                            f\"Moving from {temp_dir} to \"\n                            f\"{project_path.as_posix()}\"\n                        ))\n                        shutil.copytree(\n                            temp_dir, project_path, dirs_exist_ok=True)\n\n                    except shutil.Error as e:\n                        raise ApplicationLaunchFailed((\n                            f\"{self.signature} Cannot copy directory {temp_dir} \"\n                            f\"to {project_path.as_posix()} - {e}\"\n                        )) from e\n            else:\n                raise ApplicationLaunchFailed(\n                    f\"Could not open project; Project file not found.\\n\\n\"\n                    f\"'{project_path.as_posix()}' \\n\\n\"\n                    f\"Please contact administrator.\\n\"\n                    f\"Make sure the project is in the correct folder. Or enable 'allow project creation' in studio settings\"\n                )\n\n        self.launch_context.env[\"AYON_UNREAL_VERSION\"] = engine_version\n        # Append project file to launch arguments\n        self.launch_context.launch_args.append(\n            f\"\\\"{project_file.as_posix()}\\\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/hooks/pre_workfile_preparation.html#client.ayon_unreal.hooks.pre_workfile_preparation.UnrealPrelaunchHook.execute","title":"<code>execute()</code>","text":"<p>Hook entry method.</p> Source code in <code>client/ayon_unreal/hooks/pre_workfile_preparation.py</code> <pre><code>def execute(self):\n    \"\"\"Hook entry method.\"\"\"\n    workdir = self.launch_context.env[\"AYON_WORKDIR\"]\n    executable = str(self.launch_context.executable)\n    engine_version = self.app_name.split(\"/\")[-1].replace(\"-\", \".\")\n    try:\n        if int(engine_version.split(\".\")[0]) &lt; 4 and \\\n                int(engine_version.split(\".\")[1]) &lt; 26:\n            raise ApplicationLaunchFailed((\n                f\"{self.signature} Old unsupported version of UE \"\n                f\"detected - {engine_version}\"))\n    except ValueError:\n        # there can be string in minor version and in that case\n        # int cast is failing. This probably happens only with\n        # early access versions and is of no concert for this check\n        # so let's keep it quiet.\n        ...\n\n    unreal_project_filename = self._get_work_filename()\n    unreal_project_name = os.path.splitext(unreal_project_filename)[0]\n    # Unreal is sensitive about project names longer then 20 chars\n    if len(unreal_project_name) &gt; 20:\n        raise ApplicationLaunchFailed(\n            f\"Project name exceeds 20 characters ({unreal_project_name})!\"\n        )\n\n    # Unreal doesn't accept non alphabet characters at the start\n    # of the project name. This is because project name is then used\n    # in various places inside c++ code and there variable names cannot\n    # start with non-alpha. We append 'P' before project name to solve it.\n    # \ud83d\ude31\n    if not unreal_project_name[:1].isalpha():\n        self.log.warning((\n            \"Project name doesn't start with alphabet \"\n            f\"character ({unreal_project_name}). Appending 'P'\"\n        ))\n        unreal_project_name = f\"P{unreal_project_name}\"\n        unreal_project_filename = f'{unreal_project_name}.uproject'\n\n    last_workfile_path = self.data.get(\"last_workfile_path\")\n    if last_workfile_path and os.path.exists(last_workfile_path):\n        project_path = Path(os.path.dirname(last_workfile_path))\n        unreal_project_filename = Path(os.path.basename(last_workfile_path))\n    else:\n        project_path = Path(os.path.join(workdir, unreal_project_name))\n        project_path.mkdir(parents=True, exist_ok=True)\n\n    self.log.info((\n        f\"{self.signature} requested UE version: \"\n        f\"[ {engine_version} ]\"\n    ))\n\n    # engine_path points to the specific Unreal Engine root\n    # so, we are going up from the executable itself 3 levels.\n    # on macOS it's 6 levels up as the executable lives under\n    # ./UnrealEditor.app/Contents/MacOS/UnrealEditor\n    if platform.system().lower() == \"darwin\":\n        engine_path: Path = Path(executable).parents[6]\n    else:\n        engine_path: Path = Path(executable).parents[3]\n\n    # Check if new env variable exists, and if it does, if the path\n    # actually contains the plugin. If not, install it.\n\n    built_plugin_path = self.launch_context.env.get(\n        \"AYON_BUILT_UNREAL_PLUGIN\", None)\n\n    if unreal_lib.check_built_plugin_existance(built_plugin_path):\n        self.log.info((\n            f\"{self.signature} using existing built Ayon plugin from \"\n            f\"{built_plugin_path}\"\n        ))\n        unreal_lib.copy_built_plugin(engine_path, Path(built_plugin_path))\n    else:\n        # Set \"AYON_UNREAL_PLUGIN\" to current process environment for\n        # execution of `create_unreal_project`\n        env_key = \"AYON_UNREAL_PLUGIN\"\n        if self.launch_context.env.get(env_key):\n            self.log.info((\n                f\"{self.signature} using Ayon plugin from \"\n                f\"{self.launch_context.env.get(env_key)}\"\n            ))\n        if self.launch_context.env.get(env_key):\n            os.environ[env_key] = self.launch_context.env[env_key]\n\n        if not unreal_lib.check_plugin_existence(engine_path):\n            self.exec_plugin_install(engine_path)\n\n    project_file = project_path / unreal_project_filename\n\n    if not project_file.is_file():\n\n        #Get project settings -&gt; allow project creation\n        current_project = get_current_project_name()\n        unreal_settings = get_project_settings(current_project).get(\"unreal\")\n        allow_project_creation = unreal_settings[\"project_setup\"].get(\n        \"allow_project_creation\")\n        if allow_project_creation:\n            with tempfile.TemporaryDirectory() as temp_dir:\n                self.exec_ue_project_gen(engine_version,\n                                         unreal_project_name,\n                                         engine_path,\n                                         Path(temp_dir))\n                try:\n                    self.log.info((\n                        f\"Moving from {temp_dir} to \"\n                        f\"{project_path.as_posix()}\"\n                    ))\n                    shutil.copytree(\n                        temp_dir, project_path, dirs_exist_ok=True)\n\n                except shutil.Error as e:\n                    raise ApplicationLaunchFailed((\n                        f\"{self.signature} Cannot copy directory {temp_dir} \"\n                        f\"to {project_path.as_posix()} - {e}\"\n                    )) from e\n        else:\n            raise ApplicationLaunchFailed(\n                f\"Could not open project; Project file not found.\\n\\n\"\n                f\"'{project_path.as_posix()}' \\n\\n\"\n                f\"Please contact administrator.\\n\"\n                f\"Make sure the project is in the correct folder. Or enable 'allow project creation' in studio settings\"\n            )\n\n    self.launch_context.env[\"AYON_UNREAL_VERSION\"] = engine_version\n    # Append project file to launch arguments\n    self.launch_context.launch_args.append(\n        f\"\\\"{project_file.as_posix()}\\\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_camera.html","title":"create_camera","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_camera.html#client.ayon_unreal.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>UnrealAssetCreator</code></p> <p>Create Camera.</p> Source code in <code>client/ayon_unreal/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(UnrealAssetCreator):\n    \"\"\"Create Camera.\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.camera\"\n    label = \"Camera\"\n    product_type = \"camera\"\n    icon = \"fa.camera\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        if pre_create_data.get(\"use_selection\"):\n            sel_objects = unreal.EditorUtilityLibrary.get_selected_assets()\n            selection = [a.get_path_name() for a in sel_objects]\n\n            if len(selection) != 1:\n                raise CreatorError(\"Please select only one object.\")\n\n        # Add the current level path to the metadata\n        if UNREAL_VERSION.major == 5:\n            world = unreal.UnrealEditorSubsystem().get_editor_world()\n        else:\n            world = unreal.EditorLevelLibrary.get_editor_world()\n\n        instance_data[\"level\"] = world.get_path_name()\n\n        super(CreateCamera, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/create/create_layout.html","title":"create_layout","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_layout.html#client.ayon_unreal.plugins.create.create_layout.CreateLayout","title":"<code>CreateLayout</code>","text":"<p>               Bases: <code>UnrealActorCreator</code></p> <p>Layout output for character rigs.</p> Source code in <code>client/ayon_unreal/plugins/create/create_layout.py</code> <pre><code>class CreateLayout(UnrealActorCreator):\n    \"\"\"Layout output for character rigs.\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.layout\"\n    label = \"Layout\"\n    product_type = \"layout\"\n    icon = \"cubes\"\n\n    def get_pre_create_attr_defs(self):\n        defs = super(CreateLayout, self).get_pre_create_attr_defs()\n        return defs + [\n            BoolDef(\n                \"export_blender\",\n                label=\"Export to Blender\",\n                default=False\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/create/create_render.html","title":"create_render","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_render.html#client.ayon_unreal.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>UnrealAssetCreator</code></p> <p>Create instance for sequence for rendering</p> Source code in <code>client/ayon_unreal/plugins/create/create_render.py</code> <pre><code>class CreateRender(UnrealAssetCreator):\n    \"\"\"Create instance for sequence for rendering\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.render\"\n    label = \"Render\"\n    product_type = \"render\"\n    icon = \"eye\"\n\n    def create_instance(\n            self, instance_data, product_name, pre_create_data,\n            selected_asset_path, master_seq, master_lvl, seq_data\n    ):\n        instance_data[\"members\"] = [selected_asset_path]\n        instance_data[\"sequence\"] = selected_asset_path\n        instance_data[\"master_sequence\"] = master_seq\n        instance_data[\"master_level\"] = master_lvl\n        instance_data[\"output\"] = seq_data.get('output')\n        instance_data[\"frameStart\"] = seq_data.get('frame_range')[0]\n        instance_data[\"frameEnd\"] = seq_data.get('frame_range')[1]\n\n        super().create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    def update_instance(self, instance, instance_data, pre_create_data):\n        instance_data[\"label\"] = f'instance_data.get(\"folderPath\") - {instance_data.get(\"productName\")}'\n        super().update_instance(\n            instance,\n            instance_data,\n            pre_create_data)\n\n\n    def create_with_new_sequence(\n            self, product_name, instance_data, pre_create_data\n    ):\n        # If the option to create a new level sequence is selected,\n        # create a new level sequence and a master level.\n\n        root = \"/Game/Ayon/Sequences\"\n\n        # Create a new folder for the sequence in root\n        sequence_dir_name = create_folder(root, product_name)\n        sequence_dir = f\"{root}/{sequence_dir_name}\"\n\n        unreal.log_warning(f\"sequence_dir: {sequence_dir}\")\n\n        # Create the level sequence\n        asset_tools = unreal.AssetToolsHelpers.get_asset_tools()\n        seq = asset_tools.create_asset(\n            asset_name=product_name,\n            package_path=sequence_dir,\n            asset_class=unreal.LevelSequence,\n            factory=unreal.LevelSequenceFactoryNew())\n\n        seq.set_playback_start(pre_create_data.get(\"start_frame\"))\n        seq.set_playback_end(pre_create_data.get(\"end_frame\"))\n\n        pre_create_data[\"members\"] = [seq.get_path_name()]\n\n        unreal.EditorAssetLibrary.save_asset(seq.get_path_name())\n\n        # Create the master level\n        curr_level = None\n        if UNREAL_VERSION.major &gt;= 5:\n            if UNREAL_VERSION.minor &gt;= 3:\n                les = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)\n                curr_level = les.get_current_level()\n            else:\n                curr_level = unreal.LevelEditorSubsystem().get_current_level()\n\n        else:\n            world = unreal.EditorLevelLibrary.get_editor_world()\n            levels = unreal.EditorLevelUtils.get_levels(world)\n            curr_level = levels[0] if len(levels) else None\n\n            if not curr_level:\n                raise RuntimeError(\"No level loaded.\")\n        curr_level_path = curr_level.get_outer().get_path_name()\n\n        # If the level path does not start with \"/Game/\", the current\n        # level is a temporary, unsaved level.\n        if curr_level_path.startswith(\"/Game/\"):\n            if UNREAL_VERSION.major &gt;= 5:\n                unreal.LevelEditorSubsystem().save_current_level()\n            else:\n                unreal.EditorLevelLibrary.save_current_level()\n\n        ml_path = f\"{sequence_dir}/{product_name}_MasterLevel\"\n\n        if UNREAL_VERSION.major &gt;= 5:\n            unreal.LevelEditorSubsystem().new_level(ml_path)\n        else:\n            unreal.EditorLevelLibrary.new_level(ml_path)\n\n        seq_data = {\n            \"sequence\": seq,\n            \"output\": f\"{seq.get_name()}\",\n            \"frame_range\": (\n                seq.get_playback_start(),\n                seq.get_playback_end())}\n\n        self.create_instance(\n            instance_data, product_name, pre_create_data,\n            seq.get_path_name(), seq.get_path_name(), ml_path, seq_data)\n\n    def create_from_existing_sequence(\n            self, product_name, instance_data, pre_create_data\n    ):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        sel_objects = unreal.EditorUtilityLibrary.get_selected_assets()\n        selection = [\n            a.get_path_name() for a in sel_objects\n            if a.get_class().get_name() == \"LevelSequence\"]\n\n        if len(selection) == 0:\n            raise RuntimeError(\"Please select at least one Level Sequence.\")\n\n        seq_data = None\n\n        for sel in selection:\n            selected_asset = ar.get_asset_by_object_path(sel).get_asset()\n            selected_asset_path = selected_asset.get_path_name()\n\n            # Check if the selected asset is a level sequence asset.\n            if selected_asset.get_class().get_name() != \"LevelSequence\":\n                unreal.log_warning(\n                    f\"Skipping {selected_asset.get_name()}. It isn't a Level \"\n                    \"Sequence.\")\n\n            if pre_create_data.get(\"use_hierarchy\"):\n                # The asset name is the the third element of the path which\n                # contains the map.\n                # To take the asset name, we remove from the path the prefix\n                # \"/Game/Ayon/\" and then we split the path by \"/\".\n                sel_path = selected_asset_path\n                asset_name = sel_path.replace(\n                    \"/Game/Ayon/Sequences/\", \"\").split(\"/\")[0]\n\n                search_path = f\"/Game/Ayon/Sequences/{asset_name}\"\n            else:\n                search_path = Path(selected_asset_path).parent.as_posix()\n\n            # Get the master sequence and the master level.\n            # There should be only one sequence and one level in the directory.\n            try:\n                ar_filter = unreal.ARFilter(\n                    class_names=[\"LevelSequence\"],\n                    package_paths=[search_path],\n                    recursive_paths=False)\n                sequences = ar.get_assets(ar_filter)\n                master_seq_obj = sequences[0].get_asset()\n                master_seq = master_seq_obj.get_path_name()\n                ar_filter = unreal.ARFilter(\n                    class_names=[\"World\"],\n                    package_paths=[search_path],\n                    recursive_paths=False)\n                levels = ar.get_assets(ar_filter)\n                master_lvl = levels[0].get_asset().get_path_name()\n            except IndexError:\n                raise RuntimeError(\n                    \"Could not find the hierarchy for the selected sequence.\")\n\n            # If the selected asset is the master sequence, we get its data\n            # and then we create the instance for the master sequence.\n            # Otherwise, we cycle from the master sequence to find the selected\n            # sequence and we get its data. This data will be used to create\n            # the instance for the selected sequence. In particular,\n            # we get the frame range of the selected sequence and its final\n            # output path.\n            master_seq_data = {\n                \"sequence\": master_seq_obj,\n                \"output\": f\"{master_seq_obj.get_name()}\",\n                \"frame_range\": (\n                    master_seq_obj.get_playback_start(),\n                    master_seq_obj.get_playback_end())}\n\n            if (selected_asset_path == master_seq or\n                    pre_create_data.get(\"use_hierarchy\")):\n                seq_data = master_seq_data\n            else:\n                seq_data_list = [master_seq_data]\n\n                for seq in seq_data_list:\n                    subscenes = get_subsequences(seq.get('sequence'))\n\n                    for sub_seq in subscenes:\n                        sub_seq_obj = sub_seq.get_sequence()\n                        curr_data = {\n                            \"sequence\": sub_seq_obj,\n                            \"output\": (f\"{seq.get('output')}/\"\n                                       f\"{sub_seq_obj.get_name()}\"),\n                            \"frame_range\": (\n                                sub_seq.get_start_frame(),\n                                sub_seq.get_end_frame() - 1)}\n\n                        # If the selected asset is the current sub-sequence,\n                        # we get its data and we break the loop.\n                        # Otherwise, we add the current sub-sequence data to\n                        # the list of sequences to check.\n                        if sub_seq_obj.get_path_name() == selected_asset_path:\n                            seq_data = curr_data\n                            break\n\n                        seq_data_list.append(curr_data)\n\n                    # If we found the selected asset, we break the loop.\n                    if seq_data is not None:\n                        break\n\n            # If we didn't find the selected asset, we don't create the\n            # instance.\n            if not seq_data:\n                unreal.log_warning(\n                    f\"Skipping {selected_asset.get_name()}. It isn't a \"\n                    \"sub-sequence of the master sequence.\")\n                continue\n\n            self.create_instance(\n                instance_data, product_name, pre_create_data,\n                selected_asset_path, master_seq, master_lvl, seq_data)\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance_data[\"label\"] = f'{instance_data.get(\"folderPath\")} - {product_name}'\n        if not instance_data.get(\"creator_attributes\"):\n            instance_data[\"creator_attributes\"] = {}\n        instance_data[\"creator_attributes\"][\"render_target\"] = pre_create_data.get(\"render_target\")\n        if pre_create_data.get(\"create_seq\"):\n            self.create_with_new_sequence(\n                product_name, instance_data, pre_create_data)\n        else:\n            self.create_from_existing_sequence(\n                product_name, instance_data, pre_create_data)\n\n    def get_pre_create_attr_defs(self):\n        rendering_targets = {\n            \"local\": \"Local machine rendering\",\n            \"farm\": \"Farm rendering\",\n        }\n        return [\n            UILabelDef(\n                \"Select a Level Sequence to render or create a new one.\"\n            ),\n            BoolDef(\n                \"create_seq\",\n                label=\"Create a new Level Sequence\",\n                default=False\n            ),\n            UILabelDef(\n                \"WARNING: If you create a new Level Sequence, the current\\n\"\n                \"level will be saved and a new Master Level will be created.\"\n            ),\n\n            EnumDef(\n                \"render_target\", items=rendering_targets, label=\"Render target\"\n            ),\n            NumberDef(\n                \"start_frame\",\n                label=\"Start Frame\",\n                default=0,\n                minimum=-999999,\n                maximum=999999\n            ),\n            NumberDef(\n                \"end_frame\",\n                label=\"Start Frame\",\n                default=150,\n                minimum=-999999,\n                maximum=999999\n            ),\n            UISeparatorDef(),\n            UILabelDef(\n                \"The following settings are valid only if you are not\\n\"\n                \"creating a new sequence.\"\n            ),\n            BoolDef(\n                \"use_hierarchy\",\n                label=\"Use Hierarchy\",\n                default=False\n            ),\n        ]\n\n    def get_instance_attr_defs(self):\n        rendering_targets = {\n            \"local\": \"Local machine rendering\",\n            \"farm\": \"Farm rendering\",\n        }\n        return [\n            EnumDef(\n                \"render_target\", items=rendering_targets,\n                label=\"Render target\",\n                default=\"local\"\n            ),\n            BoolDef(\n                \"review\",\n                label=\"Generate review\",\n                default=True\n            ),\n        ]\n\n    def _on_value_changed(self, event):\n        for changed_item in event[\"changes\"]:\n            instance = changed_item[\"instance\"]\n            changes = changed_item[\"changes\"]\n            if  (\n                instance is not None\n                and \"folderPath\" in changes\n                and instance.creator_identifier == self.identifier\n            ):\n                instance.data[\"label\"] = (\n                    f'{instance.data.get(\"folderPath\")} - '\n                    f'{instance.data.get(\"productName\")}'\n                )\n\n    def register_callbacks(self):\n        self.create_context.add_value_changed_callback(self._on_value_changed)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/create/create_staticmeshfbx.html","title":"create_staticmeshfbx","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_staticmeshfbx.html#client.ayon_unreal.plugins.create.create_staticmeshfbx.CreateStaticMeshFBX","title":"<code>CreateStaticMeshFBX</code>","text":"<p>               Bases: <code>UnrealAssetCreator</code></p> <p>Create Static Meshes as FBX geometry.</p> Source code in <code>client/ayon_unreal/plugins/create/create_staticmeshfbx.py</code> <pre><code>class CreateStaticMeshFBX(UnrealAssetCreator):\n    \"\"\"Create Static Meshes as FBX geometry.\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.staticmeshfbx\"\n    label = \"Static Mesh (FBX)\"\n    product_type = \"staticMesh\"\n    icon = \"cube\"\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/create/create_uasset.html","title":"create_uasset","text":""},{"location":"autoapi/client/ayon_unreal/plugins/create/create_uasset.html#client.ayon_unreal.plugins.create.create_uasset.CreateUAsset","title":"<code>CreateUAsset</code>","text":"<p>               Bases: <code>UnrealAssetCreator</code></p> <p>Create UAsset.</p> Source code in <code>client/ayon_unreal/plugins/create/create_uasset.py</code> <pre><code>class CreateUAsset(UnrealAssetCreator):\n    \"\"\"Create UAsset.\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.uasset\"\n    label = \"UAsset\"\n    product_type = \"uasset\"\n    icon = \"cube\"\n\n    extension = \".uasset\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        if pre_create_data.get(\"use_selection\"):\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n            sel_objects = unreal.EditorUtilityLibrary.get_selected_assets()\n            selection = [a.get_path_name() for a in sel_objects]\n\n            if len(selection) != 1:\n                raise CreatorError(\"Please select only one object.\")\n\n            obj = selection[0]\n\n            asset = ar.get_asset_by_object_path(obj).get_asset()\n            sys_path = unreal.SystemLibrary.get_system_path(asset)\n\n            if not sys_path:\n                raise CreatorError(\n                    f\"{Path(obj).name} is not on the disk. Likely it needs to\"\n                    \"be saved first.\")\n\n            if Path(sys_path).suffix != self.extension:\n                raise CreatorError(\n                    f\"{Path(sys_path).name} is not a {self.label}.\")\n\n        super(CreateUAsset, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/create/create_uasset.html#client.ayon_unreal.plugins.create.create_uasset.CreateUMap","title":"<code>CreateUMap</code>","text":"<p>               Bases: <code>CreateUAsset</code></p> <p>Create Level.</p> Source code in <code>client/ayon_unreal/plugins/create/create_uasset.py</code> <pre><code>class CreateUMap(CreateUAsset):\n    \"\"\"Create Level.\"\"\"\n\n    identifier = \"io.ayon.creators.unreal.umap\"\n    label = \"Level\"\n    product_type = \"uasset\"\n    extension = \".umap\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        instance_data[\"families\"] = [\"umap\"]\n\n        super(CreateUMap, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_unreal/plugins/inventory/connect_animation_to_sequence.html","title":"connect_animation_to_sequence","text":""},{"location":"autoapi/client/ayon_unreal/plugins/inventory/connect_animation_to_sequence.html#client.ayon_unreal.plugins.inventory.connect_animation_to_sequence.ConnectAlembicAnimation","title":"<code>ConnectAlembicAnimation</code>","text":"<p>               Bases: <code>ConnectFbxAnimation</code></p> <p>Add Animation Sequence to Level Sequence when the skeletal Mesh already binds into the Sequence. Applied only for animation and layout product type. This is done in hacky way which replace the loaded fbx skeletal mesh with the alembic one in the current update. It will be removed after support the alembic export of rig product type.</p> Source code in <code>client/ayon_unreal/plugins/inventory/connect_animation_to_sequence.py</code> <pre><code>class ConnectAlembicAnimation(ConnectFbxAnimation):\n    \"\"\"Add Animation Sequence to Level Sequence when the skeletal Mesh\n    already binds into the Sequence. Applied only for animation and\n    layout product type.\n    This is done in hacky way which replace the loaded fbx skeletal mesh with the alembic one\n    in the current update. It will be removed after support the alembic export of rig product\n    type.\n    \"\"\"\n\n    label = \"Connect Alembic Animation to Level Sequence\"\n    icon = \"arrow-up\"\n    color = \"red\"\n    order = 1\n\n    def import_animation_sequence(self, asset_content, sequence, frameStart, frameEnd):\n        update_skeletal_mesh(asset_content, sequence)\n        import_animation_sequence(asset_content, sequence, frameStart, frameEnd)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/inventory/connect_animation_to_sequence.html#client.ayon_unreal.plugins.inventory.connect_animation_to_sequence.ConnectFbxAnimation","title":"<code>ConnectFbxAnimation</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Add Animation Sequence to Level Sequence when the skeletal Mesh already binds into the Sequence. Applied only for animation and layout product type</p> Source code in <code>client/ayon_unreal/plugins/inventory/connect_animation_to_sequence.py</code> <pre><code>class ConnectFbxAnimation(InventoryAction):\n    \"\"\"Add Animation Sequence to Level Sequence when the skeletal Mesh\n    already binds into the Sequence. Applied only for animation and\n    layout product type\n    \"\"\"\n\n    label = \"Connect Fbx Animation to Level Sequence\"\n    icon = \"arrow-up\"\n    color = \"red\"\n    order = 1\n\n    def process(self, containers):\n        allowed_families = [\"animation\", \"layout\", \"camera\"]\n        sequence = None\n        for container in containers:\n            container_dir = container.get(\"namespace\")\n            if container.get(\"family\") not in allowed_families:\n                unreal.log_warning(\n                    f\"Container {container_dir} is not supported.\"\n                )\n                continue\n        sequence = self.get_layout_asset(containers)\n        if not sequence:\n            raise RuntimeError(\n                \"No level sequence found in layout asset directory. \"\n                \"Please select the layout container.\"\n            )\n        self.import_animation(containers, sequence)\n        self.import_camera(containers, sequence)\n        self.save_layout_asset(containers)\n\n    def get_layout_asset(self, containers, asset_name=\"LevelSequence\"):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        layout_path = next((\n            container.get(\"namespace\") for container in containers\n            if container.get(\"family\") == \"layout\"), None)\n        if not layout_path:\n            return None\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            layout_path, recursive=False, include_folder=False\n        )\n        for asset in asset_content:\n            data = ar.get_asset_by_object_path(asset)\n            if data.asset_class_path.asset_name == asset_name:\n                return data.get_asset()\n\n    def import_animation(self, containers, sequence):\n        has_animation_product = [\n            container for container in containers\n            if container.get(\"family\") == \"animation\"]\n        if not has_animation_product:\n            return\n        anim_path = next((\n            container.get(\"namespace\") for container in containers\n            if container.get(\"family\") == \"animation\"), None)\n        start_frame, end_frame = get_frame_range_from_folder_attributes()\n        # use the clipIn/Out value for the frameStart and frameEnd\n        frameStart = next((\n            int(container.get(\"frameStart\", start_frame)) for container in containers\n            if container.get(\"family\") == \"animation\"), None)\n        frameEnd = next((\n            int(container.get(\"frameEnd\", end_frame)) for container in containers\n            if container.get(\"family\") == \"animation\"), None)\n        if anim_path:\n            asset_content = unreal.EditorAssetLibrary.list_assets(\n                anim_path, recursive=False, include_folder=False\n            )\n            self.import_animation_sequence(\n                asset_content, sequence, frameStart, frameEnd)\n\n    def import_camera(self, containers, sequence):\n        has_camera_product = [\n            container for container in containers\n            if container.get(\"family\") == \"camera\"]\n        if not has_camera_product:\n            return\n        parent_id = next((\n            container.get(\"parent\") for container in containers\n            if container.get(\"family\") == \"camera\"), None)\n        version_id = next((\n            container.get(\"representation\") for container in containers\n            if container.get(\"family\") == \"camera\"), None)\n        namespace = next((\n            container.get(\"namespace\") for container in containers\n            if container.get(\"family\") == \"camera\"), None)\n        start_frame, end_frame = get_frame_range_from_folder_attributes()\n        # use the clipIn/Out value for the frameStart and frameEnd\n        frameStart = next((\n            int(container.get(\"frameStart\", start_frame)) for container in containers\n            if container.get(\"family\") == \"camera\"), None)\n        frameEnd = next((\n            int(container.get(\"frameEnd\", end_frame)) for container in containers\n            if container.get(\"family\") == \"camera\"), None)\n        layout_world = self.get_layout_asset(containers, asset_name=\"World\")\n        import_camera_to_level_sequence(\n            sequence, parent_id, version_id,\n            namespace, layout_world, frameStart,\n            frameEnd)\n\n    def import_animation_sequence(self, asset_content, sequence, frameStart, frameEnd):\n        import_animation_sequence(asset_content, sequence, frameStart, frameEnd)\n\n    def save_layout_asset(self, containers):\n        layout_path = next((\n            container.get(\"namespace\") for container in containers\n            if container.get(\"family\") == \"layout\"), None)\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            layout_path, recursive=False, include_folder=False\n        )\n        for asset in asset_content:\n            unreal.EditorAssetLibrary.save_asset(asset)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/inventory/delete_unused_assets.html","title":"delete_unused_assets","text":""},{"location":"autoapi/client/ayon_unreal/plugins/inventory/delete_unused_assets.html#client.ayon_unreal.plugins.inventory.delete_unused_assets.DeleteUnusedAssets","title":"<code>DeleteUnusedAssets</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Delete all the assets that are not used in any level.</p> Source code in <code>client/ayon_unreal/plugins/inventory/delete_unused_assets.py</code> <pre><code>class DeleteUnusedAssets(InventoryAction):\n    \"\"\"Delete all the assets that are not used in any level.\n    \"\"\"\n\n    label = \"Delete Unused Assets\"\n    icon = \"trash\"\n    color = \"red\"\n    order = 1\n\n    dialog = None\n\n    def _delete_unused_assets(self, containers):\n        allowed_families = [\"model\", \"rig\"]\n\n        for container in containers:\n            container_dir = container.get(\"namespace\")\n            if container.get(\"family\") not in allowed_families:\n                unreal.log_warning(\n                    f\"Container {container_dir} is not supported.\")\n                continue\n\n            asset_content = unreal.EditorAssetLibrary.list_assets(\n                container_dir, recursive=True, include_folder=False\n            )\n\n            delete_asset_if_unused(container, asset_content)\n\n    def _show_confirmation_dialog(self, containers):\n        from qtpy import QtCore\n        from ayon_core.tools.utils import SimplePopup\n        from ayon_core.style import load_stylesheet\n\n        dialog = SimplePopup()\n        dialog.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n        dialog.setFocusPolicy(QtCore.Qt.StrongFocus)\n        dialog.setWindowTitle(\"Delete all unused assets\")\n        dialog.set_message(\n            \"You are about to delete all the assets in the project that \\n\"\n            \"are not used in any level. Are you sure you want to continue?\"\n        )\n        dialog.set_button_text(\"Delete\")\n\n        dialog.on_clicked.connect(\n            lambda: self._delete_unused_assets(containers)\n        )\n\n        dialog.show()\n        dialog.raise_()\n        dialog.activateWindow()\n        dialog.setStyleSheet(load_stylesheet())\n\n        self.dialog = dialog\n\n    def process(self, containers):\n        with qt_app_context():\n            self._show_confirmation_dialog(containers)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/inventory/update_actors.html","title":"update_actors","text":""},{"location":"autoapi/client/ayon_unreal/plugins/inventory/update_actors.html#client.ayon_unreal.plugins.inventory.update_actors.UpdateAllActors","title":"<code>UpdateAllActors</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Update all the Actors in the current level to the version of the asset selected in the scene manager.</p> Source code in <code>client/ayon_unreal/plugins/inventory/update_actors.py</code> <pre><code>class UpdateAllActors(InventoryAction):\n    \"\"\"Update all the Actors in the current level to the version of the asset\n    selected in the scene manager.\n    \"\"\"\n\n    label = \"Replace all Actors in level to this version\"\n    icon = \"arrow-up\"\n\n    def process(self, containers):\n        update_assets(containers, False)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/inventory/update_actors.html#client.ayon_unreal.plugins.inventory.update_actors.UpdateSelectedActors","title":"<code>UpdateSelectedActors</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Update only the selected Actors in the current level to the version of the asset selected in the scene manager.</p> Source code in <code>client/ayon_unreal/plugins/inventory/update_actors.py</code> <pre><code>class UpdateSelectedActors(InventoryAction):\n    \"\"\"Update only the selected Actors in the current level to the version\n    of the asset selected in the scene manager.\n    \"\"\"\n\n    label = \"Replace selected Actors in level to this version\"\n    icon = \"arrow-up\"\n\n    def process(self, containers):\n        update_assets(containers, True)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_unreal/plugins/load/load_alembic_animation.html","title":"load_alembic_animation","text":"<p>Load Alembic Animation.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_alembic_animation.html#client.ayon_unreal.plugins.load.load_alembic_animation.AnimationAlembicLoader","title":"<code>AnimationAlembicLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal SkeletalMesh from Alembic</p> Source code in <code>client/ayon_unreal/plugins/load/load_alembic_animation.py</code> <pre><code>class AnimationAlembicLoader(plugin.Loader):\n    \"\"\"Load Unreal SkeletalMesh from Alembic\"\"\"\n\n    product_types = {\"animation\"}\n    label = \"Import Alembic Animation\"\n    representations = {\"abc\"}\n    icon = \"cube\"\n    color = \"orange\"\n    abc_conversion_preset = \"maya\"\n    # check frame padding\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(AnimationAlembicLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.abc_conversion_preset = unreal_settings[\"abc_conversion_preset\"]\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"abc_conversion_preset\",\n                label=\"Alembic Conversion Preset\",\n                items={\n                    \"3dsmax\": \"3dsmax\",\n                    \"maya\": \"maya\",\n                    \"custom\": \"custom\"\n                },\n                default=cls.abc_conversion_preset\n            )\n        ]\n\n    def get_task(self, filename, asset_dir, asset_name, replace, loaded_options=None):\n        task = unreal.AssetImportTask()\n        options = unreal.AbcImportSettings()\n        sm_settings = unreal.AbcStaticMeshSettings()\n        conversion_settings = unreal.AbcConversionSettings()\n        abc_conversion_preset = loaded_options.get(\"abc_conversion_preset\")\n        if abc_conversion_preset == \"maya\":\n            if unreal_pipeline.UNREAL_VERSION.major &gt;= 5 and (\n                unreal_pipeline.UNREAL_VERSION.minor &gt;= 4):\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset= unreal.AbcConversionPreset.MAYA)\n            else:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=False, flip_v=True,\n                    rotation=[90.0, 0.0, 0.0],\n                    scale=[1.0, -1.0, 1.0])\n        elif abc_conversion_preset == \"3dsmax\":\n            if unreal_pipeline.UNREAL_VERSION.major &gt;= 5:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.MAX)\n            else:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=False, flip_v=True,\n                    rotation=[0.0, 0.0, 0.0],\n                    scale=[1.0, -1.0, 1.0])\n        else:\n            data = get_current_project_settings()\n            preset = (\n                data[\"unreal\"][\"import_settings\"][\"custom\"]\n            )\n            conversion_settings = unreal.AbcConversionSettings(\n                preset=unreal.AbcConversionPreset.CUSTOM,\n                flip_u=preset[\"flip_u\"],\n                flip_v=preset[\"flip_v\"],\n                rotation=[\n                    preset[\"rot_x\"],\n                    preset[\"rot_y\"],\n                    preset[\"rot_z\"]\n                ],\n                scale=[\n                    preset[\"scl_x\"],\n                    preset[\"scl_y\"],\n                    preset[\"scl_z\"]\n                ]\n            )\n\n        options.sampling_settings.frame_start = loaded_options.get(\"frameStart\")\n        options.sampling_settings.frame_end = loaded_options.get(\"frameEnd\")\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', not self.show_dialog)\n        task.set_editor_property('save', True)\n\n        options.set_editor_property(\n            'import_type', unreal.AlembicImportType.SKELETAL)\n\n        options.static_mesh_settings = sm_settings\n        options.conversion_settings = conversion_settings\n        task.options = options\n\n        return task\n\n    def import_and_containerize(\n        self, filepath, asset_dir, asset_name, container_name, loaded_options=None,\n        asset_path=None\n    ):\n        task = None\n        if asset_path:\n            loaded_asset_dir = os.path.dirname(asset_path)\n            task = self.get_task(filepath, loaded_asset_dir, asset_name, True, loaded_options)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(\n                        filepath, asset_dir, asset_name, False, loaded_options\n                    )\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n        # avoid duplicate container asset data being created\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n            # Create Asset Container\n            unreal_pipeline.create_container(\n                container=container_name, path=asset_dir)\n\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        frameStart,\n        frameEnd,\n        representation,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"product_type\": product_type,\n            \"frameStart\": frameStart,\n            \"frameEnd\": frameEnd,\n            # TODO these should be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n        unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        This is two-step process. First, import FBX to temporary path and\n        then call `containerise()` on it - this moves all content to new\n        directory and then it will create AssetContainer there and imprint it\n        with metadata. This will mark this path as container.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted. This is not used\n                         now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n\n        # Create directory for asset and ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = context[\"folder\"][\"path\"]\n        hierarchy = folder_path.lstrip(\"/\").split(\"/\")\n        folder_name = hierarchy.pop(-1)\n        product_type = context[\"product\"][\"productType\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n            asset_name, asset_dir, folder_name, extension=ext)\n\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n        loaded_options = {\n            \"abc_conversion_preset\": options.get(\n                \"abc_conversion_preset\", self.abc_conversion_preset),\n            \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n            \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n        }\n\n        path = self.filepath_from_context(context)\n        self.import_and_containerize(\n            path, asset_dir, asset_name,\n            container_name, loaded_options,\n            asset_path=asset_path\n        )\n\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n\n        # update metadata\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            folder_entity[\"attrib\"][\"frameStart\"],\n            folder_entity[\"attrib\"][\"frameEnd\"],\n            context[\"representation\"],\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n\n        # Create directory for folder and Ayon container\n        suffix = \"_CON\"\n        source_path = get_representation_path(repre_entity)\n\n        ext = os.path.splitext(source_path)[-1].lstrip(\".\")\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n        # do import fbx and replace existing data\n        asset_tools = unreal.AssetToolsHelpers.get_asset_tools()\n        asset_dir, container_name = asset_tools.create_unique_asset_name(\n             asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"abc_conversion_preset\": self.abc_conversion_preset,\n            \"frameStart\": int(container.get(\"frameStart\", \"1\")),\n            \"frameEnd\": int(container.get(\"frameEnd\", \"1\"))\n        }\n\n        self.import_and_containerize(\n            source_path, asset_dir, asset_name,\n            container_name, loaded_options\n        )\n\n        # update metadata\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            container.get(\"frameStart\", \"1\"),\n            container.get(\"frameEnd\", \"1\"),\n            repre_entity,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_alembic_animation.html#client.ayon_unreal.plugins.load.load_alembic_animation.AnimationAlembicLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>This is two-step process. First, import FBX to temporary path and then call <code>containerise()</code> on it - this moves all content to new directory and then it will create AssetContainer there and imprint it with metadata. This will mark this path as container.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used          now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_alembic_animation.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    This is two-step process. First, import FBX to temporary path and\n    then call `containerise()` on it - this moves all content to new\n    directory and then it will create AssetContainer there and imprint it\n    with metadata. This will mark this path as container.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted. This is not used\n                     now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n\n    # Create directory for asset and ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = context[\"folder\"][\"path\"]\n    hierarchy = folder_path.lstrip(\"/\").split(\"/\")\n    folder_name = hierarchy.pop(-1)\n    product_type = context[\"product\"][\"productType\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n    asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n        asset_name, asset_dir, folder_name, extension=ext)\n\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n    loaded_options = {\n        \"abc_conversion_preset\": options.get(\n            \"abc_conversion_preset\", self.abc_conversion_preset),\n        \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n        \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n    }\n\n    path = self.filepath_from_context(context)\n    self.import_and_containerize(\n        path, asset_dir, asset_name,\n        container_name, loaded_options,\n        asset_path=asset_path\n    )\n\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n\n    # update metadata\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        folder_entity[\"attrib\"][\"frameStart\"],\n        folder_entity[\"attrib\"][\"frameEnd\"],\n        context[\"representation\"],\n        product_type,\n        context[\"project\"][\"name\"]\n    )\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_animation.html","title":"load_animation","text":"<p>Load FBX with animations.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_animation.html#client.ayon_unreal.plugins.load.load_animation.AnimationFBXLoader","title":"<code>AnimationFBXLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal SkeletalMesh from FBX.</p> Source code in <code>client/ayon_unreal/plugins/load/load_animation.py</code> <pre><code>class AnimationFBXLoader(plugin.Loader):\n    \"\"\"Load Unreal SkeletalMesh from FBX.\"\"\"\n\n    product_types = {\"animation\"}\n    label = \"Import FBX Animation\"\n    representations = {\"fbx\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    root = unreal_pipeline.AYON_ROOT_DIR\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(AnimationFBXLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    def _import_latest_skeleton(self, version_ids):\n        version_ids = set(version_ids)\n        project_name = get_current_project_name()\n        repre_entities = ayon_api.get_representations(\n            project_name,\n            representation_names={\"fbx\"},\n            version_ids=version_ids,\n            fields={\"id\"}\n        )\n        repre_entity = next(\n            (repre_entity for repre_entity\n             in repre_entities), None)\n        if not repre_entity:\n            raise LoadError(\n                f\"No valid representation for version {version_ids}\")\n        repre_id = repre_entity[\"id\"]\n\n        target_loader = None\n        all_loaders = discover_loader_plugins()\n        loaders = loaders_from_representation(\n            all_loaders, repre_id)\n        for loader in loaders:\n            if loader.__name__ == \"SkeletalMeshFBXLoader\":\n                target_loader = loader\n        assets = load_container(\n            target_loader,\n            repre_id,\n            namespace=None,\n            options={}\n        )\n        return assets\n\n\n    @classmethod\n    def _import_animation(\n        cls, path, asset_dir, asset_name,\n        skeleton, automated, replace=False,\n        loaded_options=None\n    ):\n        task = unreal.AssetImportTask()\n        task.options = unreal.FbxImportUI()\n\n        folder_entity = get_current_folder_entity(fields=[\"attrib.fps\"])\n\n        task.set_editor_property('filename', path)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', not cls.show_dialog)\n        task.set_editor_property('save', False)\n\n        # set import options here\n        task.options.set_editor_property(\n            'automated_import_should_detect_type', True)\n        task.options.set_editor_property(\n            'original_import_type', unreal.FBXImportType.FBXIT_SKELETAL_MESH)\n        task.options.set_editor_property(\n            'mesh_type_to_import', unreal.FBXImportType.FBXIT_ANIMATION)\n        task.options.set_editor_property('import_mesh', False)\n        task.options.set_editor_property('import_animations', True)\n        task.options.set_editor_property('override_full_name', True)\n        task.options.set_editor_property('skeleton', skeleton)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'animation_length',\n            unreal.FBXAnimationLengthImportType.FBXALIT_SET_RANGE\n        )\n        task.options.anim_sequence_import_data.set_editor_property(\n            'frame_import_range', unreal.Int32Interval(\n                min=loaded_options.get(\"frameStart\"),\n                max=loaded_options.get(\"frameEnd\")\n        ))\n        task.options.anim_sequence_import_data.set_editor_property(\n            'import_meshes_in_bone_hierarchy', False)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'use_default_sample_rate', False)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'custom_sample_rate', folder_entity.get(\"attrib\", {}).get(\"fps\"))\n        task.options.anim_sequence_import_data.set_editor_property(\n            'import_custom_attribute', True)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'import_bone_tracks', True)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'remove_redundant_keys', False)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'convert_scene', True)\n        task.options.anim_sequence_import_data.set_editor_property(\n            'force_front_x_axis', False)\n        if unreal_pipeline.UNREAL_VERSION.major == 5 and (\n            unreal_pipeline.UNREAL_VERSION.minor &lt;=4\n            ):\n                task.options.anim_sequence_import_data.set_editor_property(\n                    'import_rotation',\n                    unreal.Rotator(roll=90.0, pitch=0.0, yaw=0.0)\n                )\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n    def _process(self, path, asset_dir, asset_name,\n                 instance_name, loaded_options=None):\n        automated = False\n        actor = None\n\n        if instance_name:\n            automated = True\n            # Old method to get the actor\n            # actor_name = 'PersistentLevel.' + instance_name\n            # actor = unreal.EditorLevelLibrary.get_actor_reference(actor_name)\n            actors = unreal.EditorLevelLibrary.get_all_level_actors()\n            for a in actors:\n                if a.get_class().get_name() != \"SkeletalMeshActor\":\n                    continue\n                if a.get_actor_label() == instance_name:\n                    actor = a\n                    break\n            if not actor:\n                raise LoadError(f\"Could not find actor {instance_name}\")\n            skeleton = actor.skeletal_mesh_component.skeletal_mesh.skeleton\n\n        if not actor:\n            return None\n\n        self._import_animation(\n            path, asset_dir, asset_name,\n            skeleton, automated, loaded_options=loaded_options)\n\n        asset_content = EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        animation = None\n\n        for a in asset_content:\n            imported_asset_data = EditorAssetLibrary.find_asset_data(a)\n            imported_asset = unreal.AssetRegistryHelpers.get_asset(\n                imported_asset_data)\n            if imported_asset.__class__ == unreal.AnimSequence:\n                animation = imported_asset\n                break\n\n        if animation:\n            animation.set_editor_property('enable_root_motion', True)\n            actor.skeletal_mesh_component.set_editor_property(\n                'animation_mode', unreal.AnimationMode.ANIMATION_SINGLE_NODE)\n            actor.skeletal_mesh_component.animation_data.set_editor_property(\n                'anim_to_play', animation)\n\n        return animation\n\n    def _load_from_json(\n        self, libpath, path, asset_dir, asset_name, hierarchy_dir,\n        loaded_options=None\n    ):\n        with open(libpath, \"r\") as fp:\n            data = json.load(fp)\n\n        instance_name = data.get(\"instance_name\")\n\n        animation = self._process(\n            path, asset_dir, asset_name,\n            instance_name, loaded_options=loaded_options)\n\n        asset_content = EditorAssetLibrary.list_assets(\n            hierarchy_dir, recursive=True, include_folder=False)\n\n        # Get the sequence for the layout, excluding the camera one.\n        sequences = [a for a in asset_content\n                     if (EditorAssetLibrary.find_asset_data(a).get_class() ==\n                         unreal.LevelSequence.static_class() and\n                         \"_camera\" not in a.split(\"/\")[-1])]\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        for s in sequences:\n            sequence = ar.get_asset_by_object_path(s).get_asset()\n            possessables = [\n                p for p in sequence.get_possessables()\n                if p.get_display_name() == instance_name]\n\n            for p in possessables:\n                tracks = [\n                    t for t in p.get_tracks()\n                    if (t.get_class() ==\n                        MovieSceneSkeletalAnimationTrack.static_class())]\n\n                for t in tracks:\n                    sections = [\n                        s for s in t.get_sections()\n                        if (s.get_class() ==\n                            MovieSceneSkeletalAnimationSection.static_class())]\n\n                    for section in sections:\n                        section.params.set_editor_property('animation', animation)\n\n    @staticmethod\n    def is_skeleton(asset):\n        return asset.get_class() == unreal.Skeleton.static_class()\n\n    def _load_standalone_animation(\n        self, path, asset_dir, asset_name,\n        version_id, loaded_options=None\n    ):\n        selection = unreal.EditorUtilityLibrary.get_selected_assets()\n        skeleton = None\n        if selection:\n            skeleton = selection[0]\n            if not self.is_skeleton(skeleton):\n                self.log.warning(\n                    f\"Selected asset {skeleton.get_name()} is not \"\n                    f\"a skeleton. It is {skeleton.get_class().get_name()}\")\n                skeleton = None\n\n        print(\"Trying to find original rig with links.\")\n        # If no skeleton is selected, we try to find the skeleton by\n        # checking linked rigs.\n        project_name = get_current_project_name()\n        server = ayon_api.get_server_api_connection()\n\n        v_links = server.get_version_links(\n            project_name, version_id=version_id)\n        entities = [v_link[\"entityId\"] for v_link in v_links]\n        linked_versions = list(server.get_versions(project_name, entities))\n        unreal.log(\"linked_versions\")\n        unreal.log(linked_versions)\n        rigs = [\n            version[\"id\"] for version in linked_versions\n            if \"rig\" in version[\"attrib\"][\"families\"]]\n\n        self.log.debug(f\"Found rigs: {rigs}\")\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        containers = unreal_pipeline.ls()\n        for container in containers:\n            self.log.debug(f\"Checking container: {container}\")\n            if container[\"parent\"] not in rigs:\n                unreal.log(\"{}\".format(container[\"parent\"]))\n                # we found loaded version of the linked rigs\n                if container[\"loader\"] != \"SkeletalMeshFBXLoader\":\n                    continue\n                namespace = container[\"namespace\"]\n\n                _filter = unreal.ARFilter(\n                    class_names=[\"Skeleton\"],\n                    package_paths=[namespace],\n                    recursive_paths=False)\n                if skeletons := ar.get_assets(_filter):\n                    skeleton = skeletons[0].get_asset()\n                    break\n\n        if not skeleton:\n           ar = unreal.AssetRegistryHelpers.get_asset_registry()\n           skeleton_asset = self._import_latest_skeleton(rigs)\n           for asset in skeleton_asset:\n               obj = ar.get_asset_by_object_path(asset).get_asset()\n               if obj.get_class().get_name() == 'Skeleton':\n                    skeleton = obj\n\n        if not self.is_skeleton(skeleton):\n            raise LoadError(\"Selected asset is not a skeleton.\")\n\n        self.log.info(f\"Using skeleton: {skeleton.get_name()}\")\n        self._import_animation(\n            path, asset_dir, asset_name,\n            skeleton, True, loaded_options=loaded_options)\n\n    def _import_animation_with_json(self, path, context, hierarchy,\n                                    asset_dir, folder_name,\n                                    asset_name, asset_path=None,\n                                    loaded_options=None):\n            libpath = path.replace(\".fbx\", \".json\")\n\n            master_level = None\n            if asset_path:\n                asset_dir = unreal.Paths.split(asset_path)[0]\n            # check if json file exists.\n            if os.path.exists(libpath):\n                ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n                _filter = unreal.ARFilter(\n                    class_names=[\"World\"],\n                    package_paths=[f\"{self.root}/{hierarchy[0]}\"],\n                    recursive_paths=False)\n                levels = ar.get_assets(_filter)\n                master_level = levels[0].get_asset().get_path_name()\n\n                hierarchy_dir = self.root\n                for h in hierarchy:\n                    hierarchy_dir = f\"{hierarchy_dir}/{h}\"\n                hierarchy_dir = f\"{hierarchy_dir}/{folder_name}\"\n\n                _filter = unreal.ARFilter(\n                    class_names=[\"World\"],\n                    package_paths=[f\"{hierarchy_dir}/\"],\n                    recursive_paths=True)\n                levels = ar.get_assets(_filter)\n                level = levels[0].get_asset().get_path_name()\n\n                unreal.EditorLevelLibrary.save_all_dirty_levels()\n                unreal.EditorLevelLibrary.load_level(level)\n\n                self._load_from_json(\n                    libpath, path, asset_dir, asset_name, hierarchy_dir)\n            else:\n                version_id = context[\"representation\"][\"versionId\"]\n                if not unreal.EditorAssetLibrary.does_asset_exist(\n                    f\"{asset_dir}/{asset_name}\"):\n                        self._load_standalone_animation(\n                            path, asset_dir, asset_name,\n                            version_id, loaded_options=loaded_options)\n\n            return master_level\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        product_type,\n        folder_entity,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"folder_path\": folder_path,\n            \"product_type\": product_type,\n            # TODO these shold be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n            \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"],\n            \"project_name\": project_name\n        }\n        unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"\n        Load and containerise representation into Content Browser.\n\n        This is two step process. First, import FBX to temporary path and\n        then call `containerise()` on it - this moves all content to new\n        directory and then it will create AssetContainer there and imprint it\n        with metadata. This will mark this path as container.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted. This is not used\n                         now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        hierarchy = folder_path.lstrip(\"/\").split(\"/\")\n        folder_name = hierarchy.pop(-1)\n        product_type = context[\"product\"][\"productType\"]\n\n        suffix = \"_CON\"\n\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        asset_path = unreal_pipeline.has_asset_directory_pattern_matched(asset_name, asset_dir, name)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n            \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n        }\n        master_level = self._import_animation_with_json(\n            path, context, hierarchy,\n            asset_dir, folder_name,\n            asset_name, asset_path=asset_path,\n            loaded_options=loaded_options\n        )\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                unreal_pipeline.create_container(\n                    container=container_name, path=asset_dir)\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            product_type,\n            folder_entity,\n            context[\"project\"][\"name\"]\n        )\n\n        imported_content = EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False)\n\n        for asset in imported_content:\n            loaded_asset = EditorAssetLibrary.load_asset(asset)\n            # Enable root motion for animations so they are oriented correctly\n            if loaded_asset.get_class() == unreal.AnimSequence.static_class():\n                loaded_asset.set_editor_property(\"enable_root_motion\", True)\n                loaded_asset.set_editor_property(\n                    \"root_motion_root_lock\",\n                    unreal.RootMotionRootLock.ANIM_FIRST_FRAME)\n            EditorAssetLibrary.save_asset(asset)\n\n        if master_level:\n            unreal.EditorLevelLibrary.save_current_level()\n            unreal.EditorLevelLibrary.load_level(master_level)\n\n    def update(self, container, context):\n        # Create directory for folder and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        hierarchy = folder_path.lstrip(\"/\").split(\"/\")\n        folder_name = hierarchy.pop(-1)\n        folder_name = context[\"folder\"][\"name\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n        folder_entity = context[\"folder\"]\n\n        suffix = \"_CON\"\n        source_path = get_representation_path(repre_entity)\n        ext = os.path.splitext(source_path)[-1].lstrip(\".\")\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            EditorAssetLibrary.make_directory(asset_dir)\n\n        master_level = self._import_animation_with_json(\n            source_path, context, hierarchy,\n            asset_dir, folder_name, asset_name\n        )\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                unreal_pipeline.create_container(\n                    container=container_name, path=asset_dir\n                )\n        # update metadata\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            folder_entity,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            EditorAssetLibrary.save_asset(a)\n\n        if master_level:\n            unreal.EditorLevelLibrary.save_current_level()\n            unreal.EditorLevelLibrary.load_level(master_level)\n\n        return asset_content\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_animation.html#client.ayon_unreal.plugins.load.load_animation.AnimationFBXLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>This is two step process. First, import FBX to temporary path and then call <code>containerise()</code> on it - this moves all content to new directory and then it will create AssetContainer there and imprint it with metadata. This will mark this path as container.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used          now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_animation.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"\n    Load and containerise representation into Content Browser.\n\n    This is two step process. First, import FBX to temporary path and\n    then call `containerise()` on it - this moves all content to new\n    directory and then it will create AssetContainer there and imprint it\n    with metadata. This will mark this path as container.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted. This is not used\n                     now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = folder_entity[\"path\"]\n    hierarchy = folder_path.lstrip(\"/\").split(\"/\")\n    folder_name = hierarchy.pop(-1)\n    product_type = context[\"product\"][\"productType\"]\n\n    suffix = \"_CON\"\n\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n    asset_path = unreal_pipeline.has_asset_directory_pattern_matched(asset_name, asset_dir, name)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        EditorAssetLibrary.make_directory(asset_dir)\n    loaded_options = {\n        \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n        \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n    }\n    master_level = self._import_animation_with_json(\n        path, context, hierarchy,\n        asset_dir, folder_name,\n        asset_name, asset_path=asset_path,\n        loaded_options=loaded_options\n    )\n    if not unreal.EditorAssetLibrary.does_asset_exist(\n        f\"{asset_dir}/{container_name}\"):\n            unreal_pipeline.create_container(\n                container=container_name, path=asset_dir)\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        product_type,\n        folder_entity,\n        context[\"project\"][\"name\"]\n    )\n\n    imported_content = EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=False)\n\n    for asset in imported_content:\n        loaded_asset = EditorAssetLibrary.load_asset(asset)\n        # Enable root motion for animations so they are oriented correctly\n        if loaded_asset.get_class() == unreal.AnimSequence.static_class():\n            loaded_asset.set_editor_property(\"enable_root_motion\", True)\n            loaded_asset.set_editor_property(\n                \"root_motion_root_lock\",\n                unreal.RootMotionRootLock.ANIM_FIRST_FRAME)\n        EditorAssetLibrary.save_asset(asset)\n\n    if master_level:\n        unreal.EditorLevelLibrary.save_current_level()\n        unreal.EditorLevelLibrary.load_level(master_level)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_camera.html","title":"load_camera","text":"<p>Load camera from FBX.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_camera.html#client.ayon_unreal.plugins.load.load_camera.CameraLoader","title":"<code>CameraLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal StaticMesh from FBX</p> Source code in <code>client/ayon_unreal/plugins/load/load_camera.py</code> <pre><code>class CameraLoader(plugin.Loader):\n    \"\"\"Load Unreal StaticMesh from FBX\"\"\"\n\n    product_types = {\"camera\"}\n    label = \"Load Camera\"\n    representations = {\"fbx\"}\n    icon = \"cube\"\n    color = \"orange\"\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(CameraLoader, cls).apply_settings(\n            project_settings\n        )\n        cls.loaded_asset_dir = (\n            project_settings[\"unreal\"]\n                            [\"import_settings\"]\n                            [\"loaded_asset_dir\"]\n        )\n\n    def _import_camera(\n        self, world, sequence, bindings, import_fbx_settings, import_filename\n    ):\n        ue_version = unreal.SystemLibrary.get_engine_version().split('.')\n        ue_major = int(ue_version[0])\n        ue_minor = int(ue_version[1])\n\n        if ue_major == 4 and ue_minor &lt;= 26:\n            unreal.SequencerTools.import_fbx(\n                world,\n                sequence,\n                bindings,\n                import_fbx_settings,\n                import_filename\n            )\n        elif (ue_major == 4 and ue_minor &gt;= 27) or ue_major == 5:\n            unreal.SequencerTools.import_level_sequence_fbx(\n                world,\n                sequence,\n                bindings,\n                import_fbx_settings,\n                import_filename\n            )\n        else:\n            raise NotImplementedError(\n                f\"Unreal version {ue_major} not supported\")\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        folder_name,\n        product_type,\n        folder_entity,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"product_type\": product_type,\n            # TODO these should be probably removed\n            \"asset\": folder_name,\n            \"family\": product_type,\n            \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n            \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"],\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def _create_map_camera(self, context, path, tools, hierarchy_dir,\n                           master_dir_name, asset_dir, asset_name):\n        cam_seq, master_level, level, sequences, frame_ranges = (\n            generate_master_level_sequence(\n                tools, asset_dir, asset_name,\n                hierarchy_dir, master_dir_name,\n                suffix=\"camera\")\n        )\n        folder_entity = context[\"folder\"]\n        folder_attributes = folder_entity[\"attrib\"]\n        clip_in = folder_attributes.get(\"clipIn\")\n        clip_out = folder_attributes.get(\"clipOut\")\n\n        cam_seq.set_display_rate(\n            unreal.FrameRate(folder_attributes.get(\"fps\"), 1.0))\n        cam_seq.set_playback_start(clip_in)\n        cam_seq.set_playback_end(clip_out + 1)\n        set_sequence_hierarchy(\n            sequences[-1], cam_seq,\n            frame_ranges[-1][1],\n            clip_in, clip_out,\n            [level])\n\n        settings = unreal.MovieSceneUserImportFBXSettings()\n        settings.set_editor_property('reduce_keys', False)\n\n        if cam_seq:\n            self._import_camera(\n                EditorLevelLibrary.get_editor_world(),\n                cam_seq,\n                cam_seq.get_bindings(),\n                settings,\n                path\n            )\n            camera_actors = unreal.GameplayStatics().get_all_actors_of_class(\n            EditorLevelLibrary.get_editor_world(), unreal.CameraActor)\n            unreal.log(f\"Spawning camera: {asset_name}\")\n            for actor in camera_actors:\n                actor.set_actor_label(asset_name)\n\n        # Set range of all sections\n        # Changing the range of the section is not enough. We need to change\n        # the frame of all the keys in the section.\n        for possessable in cam_seq.get_possessables():\n            for tracks in possessable.get_tracks():\n                for section in tracks.get_sections():\n                    section.set_range(clip_in, clip_out + 1)\n                    for channel in section.get_all_channels():\n                        for key in channel.get_keys():\n                            old_time = key.get_time().get_editor_property(\n                                'frame_number')\n                            old_time_value = old_time.get_editor_property(\n                                'value')\n                            new_time = old_time_value + (\n                                clip_in - folder_attributes.get('frameStart')\n                            )\n                            key.set_time(unreal.FrameNumber(value=new_time))\n        return master_level\n\n    def load(self, context, name, namespace, options):\n        \"\"\"\n        Load and containerise representation into Content Browser.\n\n        This is two step process. First, import FBX to temporary path and\n        then call `containerise()` on it - this moves all content to new\n        directory and then it will create AssetContainer there and imprint it\n        with metadata. This will mark this path as container.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted. This is not used\n                         now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        folder_name = folder_entity[\"name\"]\n        asset_root, asset_name = format_asset_directory(\n            context, self.loaded_asset_dir)\n        master_dir_name = get_top_hierarchy_folder(asset_root)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, hierarchy_dir, container_name, _ = (\n            generate_hierarchy_path(\n                name, folder_name, asset_root, master_dir_name\n            )\n        )\n        path = self.filepath_from_context(context)\n        master_level = self._create_map_camera(\n            context, path, tools, hierarchy_dir,\n            master_dir_name, asset_dir, asset_name\n        )\n\n        # Create Asset Container\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"\n        ):\n            create_container(\n                container=container_name, path=asset_dir)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            folder_name,\n            context[\"product\"][\"productType\"],\n            folder_entity,\n            context[\"project\"][\"name\"]\n        )\n\n        EditorLevelLibrary.save_all_dirty_levels()\n        EditorLevelLibrary.load_level(master_level)\n\n        # Save all assets in the hierarchy\n        asset_content = EditorAssetLibrary.list_assets(\n            hierarchy_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        # Create directory for asset and Ayon container\n        repre_entity = context[\"representation\"]\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        asset_root, asset_name = format_asset_directory(\n            context, self.loaded_asset_dir)\n        master_dir_name = get_top_hierarchy_folder(asset_root)\n        hierarchy_dir = f\"{AYON_ROOT_DIR}/{master_dir_name}\"\n        suffix = \"_CON\"\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=\"\")\n\n        container_name += suffix\n        master_level = None\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            EditorAssetLibrary.make_directory(asset_dir)\n            path = get_representation_path(repre_entity)\n            master_level = self._create_map_camera(\n                context, path, tools, hierarchy_dir,\n                master_dir_name, asset_dir, asset_name\n            )\n\n        # Create Asset Container\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"\n        ):\n            create_container(\n                container=container_name, path=asset_dir)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            folder_entity[\"name\"],\n            context[\"product\"][\"productType\"],\n            folder_entity,\n            context[\"project\"][\"name\"]\n        )\n\n        EditorLevelLibrary.save_all_dirty_levels()\n        EditorLevelLibrary.load_level(master_level)\n\n        # Save all assets in the hierarchy\n        asset_content = EditorAssetLibrary.list_assets(\n            hierarchy_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            EditorAssetLibrary.save_asset(a)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        remove_map_and_sequence(container)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_camera.html#client.ayon_unreal.plugins.load.load_camera.CameraLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>This is two step process. First, import FBX to temporary path and then call <code>containerise()</code> on it - this moves all content to new directory and then it will create AssetContainer there and imprint it with metadata. This will mark this path as container.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used          now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_camera.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"\n    Load and containerise representation into Content Browser.\n\n    This is two step process. First, import FBX to temporary path and\n    then call `containerise()` on it - this moves all content to new\n    directory and then it will create AssetContainer there and imprint it\n    with metadata. This will mark this path as container.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted. This is not used\n                     now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = folder_entity[\"path\"]\n    folder_name = folder_entity[\"name\"]\n    asset_root, asset_name = format_asset_directory(\n        context, self.loaded_asset_dir)\n    master_dir_name = get_top_hierarchy_folder(asset_root)\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, hierarchy_dir, container_name, _ = (\n        generate_hierarchy_path(\n            name, folder_name, asset_root, master_dir_name\n        )\n    )\n    path = self.filepath_from_context(context)\n    master_level = self._create_map_camera(\n        context, path, tools, hierarchy_dir,\n        master_dir_name, asset_dir, asset_name\n    )\n\n    # Create Asset Container\n    if not unreal.EditorAssetLibrary.does_asset_exist(\n        f\"{asset_dir}/{container_name}\"\n    ):\n        create_container(\n            container=container_name, path=asset_dir)\n\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        folder_name,\n        context[\"product\"][\"productType\"],\n        folder_entity,\n        context[\"project\"][\"name\"]\n    )\n\n    EditorLevelLibrary.save_all_dirty_levels()\n    EditorLevelLibrary.load_level(master_level)\n\n    # Save all assets in the hierarchy\n    asset_content = EditorAssetLibrary.list_assets(\n        hierarchy_dir, recursive=True, include_folder=False\n    )\n\n    for a in asset_content:\n        EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_geometrycache_abc.html","title":"load_geometrycache_abc","text":"<p>Loader for published alembics.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_geometrycache_abc.html#client.ayon_unreal.plugins.load.load_geometrycache_abc.PointCacheAlembicLoader","title":"<code>PointCacheAlembicLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Point Cache from Alembic</p> Source code in <code>client/ayon_unreal/plugins/load/load_geometrycache_abc.py</code> <pre><code>class PointCacheAlembicLoader(plugin.Loader):\n    \"\"\"Load Point Cache from Alembic\"\"\"\n\n    product_types = {\"model\", \"pointcache\"}\n    label = \"Import Alembic Point Cache\"\n    representations = {\"abc\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    abc_conversion_preset = \"maya\"\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(PointCacheAlembicLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.abc_conversion_preset = unreal_settings[\"abc_conversion_preset\"]\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"abc_conversion_preset\",\n                label=\"Alembic Conversion Preset\",\n                items={\n                    \"3dsmax\": \"3dsmax\",\n                    \"maya\": \"maya\",\n                    \"custom\": \"custom\"\n                },\n                default=cls.abc_conversion_preset\n            )\n        ]\n\n    @staticmethod\n    def get_task(\n        filename, asset_dir, asset_name, replace,\n        frame_start=None, frame_end=None, loaded_options=None\n    ):\n        task = unreal.AssetImportTask()\n        options = unreal.AbcImportSettings()\n        gc_settings = unreal.AbcGeometryCacheSettings()\n        conversion_settings = unreal.AbcConversionSettings()\n        sampling_settings = unreal.AbcSamplingSettings()\n        abc_conversion_preset = loaded_options.get(\"abc_conversion_preset\")\n        if abc_conversion_preset == \"maya\":\n            if UNREAL_VERSION.major &gt;= 5 and UNREAL_VERSION.minor &gt;= 4:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.MAYA)\n            else:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=False, flip_v=True,\n                    rotation=[90.0, 0.0, 0.0],\n                    scale=[1.0, -1.0, 1.0])\n        elif abc_conversion_preset == \"3dsmax\":\n            if UNREAL_VERSION.major &gt;= 5:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.MAX)\n            else:\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=False, flip_v=True,\n                    rotation=[0.0, 0.0, 0.0],\n                    scale=[1.0, -1.0, 1.0])\n        else:\n            data = get_current_project_settings()\n            preset = (\n                data[\"unreal\"][\"import_settings\"][\"custom\"]\n            )\n            conversion_settings = unreal.AbcConversionSettings(\n                preset=unreal.AbcConversionPreset.CUSTOM,\n                flip_u=preset[\"flip_u\"],\n                flip_v=preset[\"flip_v\"],\n                rotation=[\n                    preset[\"rot_x\"],\n                    preset[\"rot_y\"],\n                    preset[\"rot_z\"]\n                ],\n                scale=[\n                    preset[\"scl_x\"],\n                    preset[\"scl_y\"],\n                    preset[\"scl_z\"]\n                ]\n            )\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property(\n            'automated', not loaded_options.get(\"show_dialog\"))\n        task.set_editor_property('save', True)\n\n        options.set_editor_property(\n            'import_type', unreal.AlembicImportType.GEOMETRY_CACHE)\n        options.sampling_settings.frame_start = frame_start\n        options.sampling_settings.frame_end = frame_end\n\n        gc_settings.set_editor_property('flatten_tracks', False)\n\n        if frame_start is not None:\n            sampling_settings.set_editor_property('frame_start', frame_start)\n        if frame_end is not None:\n            sampling_settings.set_editor_property('frame_end', frame_end)\n\n        options.geometry_cache_settings = gc_settings\n        options.conversion_settings = conversion_settings\n        options.sampling_settings = sampling_settings\n        task.options = options\n\n        return task\n\n    def import_and_containerize(\n        self, filepath, asset_dir, asset_name, container_name,\n        frame_start, frame_end, loaded_options=None, asset_path=None\n    ):\n        task = None\n        if asset_path:\n            loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n            task = self.get_task(\n                filepath, loaded_asset_dir, asset_name, True, frame_start, frame_end, loaded_options)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(\n                        filepath, asset_dir, asset_name, False,\n                        frame_start, frame_end, loaded_options\n                    )\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        frame_start,\n        frame_end,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"frame_start\": frame_start,\n            \"frame_end\": frame_end,\n            \"product_type\": product_type,\n            \"folder_path\": folder_path,\n            # TODO these should be probably removed\n            \"family\": product_type,\n            \"asset\": folder_path,\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        folder_attributes = folder_entity[\"attrib\"]\n\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n\n        container_name += suffix\n\n        frame_start = folder_attributes.get(\"frameStart\")\n        frame_end = folder_attributes.get(\"frameEnd\")\n\n        # If frame start and end are the same, we increase the end frame by\n        # one, otherwise Unreal will not import it\n        if frame_start == frame_end:\n            frame_end += 1\n        asset_path = has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name, extension=ext)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"abc_conversion_preset\": options.get(\n                \"abc_conversion_preset\", self.abc_conversion_preset),\n            \"show_dialog\": options.get(\"show_dialog\", self.show_dialog),\n        }\n        self.import_and_containerize(\n            path, asset_dir, asset_name, container_name,\n            frame_start, frame_end,\n            loaded_options, asset_path=asset_path\n        )\n\n\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            frame_start,\n            frame_end,\n            context[\"product\"][\"productType\"],\n            context[\"project\"][\"name\"]\n        )\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        # Create directory for folder and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n        asset_dir = container[\"namespace\"]\n        suffix = \"_CON\"\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n\n        frame_start = int(container.get(\"frame_start\"))\n        frame_end = int(container.get(\"frame_end\"))\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"abc_conversion_preset\": self.abc_conversion_preset,\n            \"show_dialog\": self.show_dialog,\n        }\n        self.import_and_containerize(\n            path, asset_dir, asset_name, container_name,\n            frame_start, frame_end, loaded_options)\n\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            frame_start,\n            frame_end,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_geometrycache_abc.html#client.ayon_unreal.plugins.load.load_geometrycache_abc.PointCacheAlembicLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_geometrycache_abc.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = folder_entity[\"path\"]\n    folder_attributes = folder_entity[\"attrib\"]\n\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n\n    container_name += suffix\n\n    frame_start = folder_attributes.get(\"frameStart\")\n    frame_end = folder_attributes.get(\"frameEnd\")\n\n    # If frame start and end are the same, we increase the end frame by\n    # one, otherwise Unreal will not import it\n    if frame_start == frame_end:\n        frame_end += 1\n    asset_path = has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name, extension=ext)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n    loaded_options = {\n        \"abc_conversion_preset\": options.get(\n            \"abc_conversion_preset\", self.abc_conversion_preset),\n        \"show_dialog\": options.get(\"show_dialog\", self.show_dialog),\n    }\n    self.import_and_containerize(\n        path, asset_dir, asset_name, container_name,\n        frame_start, frame_end,\n        loaded_options, asset_path=asset_path\n    )\n\n\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        frame_start,\n        frame_end,\n        context[\"product\"][\"productType\"],\n        context[\"project\"][\"name\"]\n    )\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_image_png.html","title":"load_image_png","text":"<p>Load textures from PNG.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_image_png.html#client.ayon_unreal.plugins.load.load_image_png.TexturePNGLoader","title":"<code>TexturePNGLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal texture from PNG file.</p> Source code in <code>client/ayon_unreal/plugins/load/load_image_png.py</code> <pre><code>class TexturePNGLoader(plugin.Loader):\n    \"\"\"Load Unreal texture from PNG file.\"\"\"\n\n    product_types = {\"image\", \"texture\", \"render\"}\n    label = \"Import image texture 2d\"\n    representations = {\"*\"}\n    extensions = {\"png\", \"jpg\", \"tiff\", \"exr\"}\n    icon = \"wallpaper\"\n    color = \"orange\"\n\n    # Defined by settings\n    show_dialog = False\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(TexturePNGLoader, cls).apply_settings(project_settings)\n        unreal_settings = project_settings.get(\"unreal\", {})\n        # Apply import settings\n        import_settings = unreal_settings.get(\"import_settings\", {})\n        cls.use_interchange = import_settings.get(\"interchange\", {}).get(\n            \"enabled\", cls.use_interchange\n        )\n        cls.show_dialog = import_settings.get(\"show_dialog\", cls.show_dialog)\n        cls.loaded_asset_dir = import_settings.get(\n            \"loaded_asset_dir\", cls.loaded_asset_dir)\n\n    @classmethod\n    def get_task(cls, filename, asset_dir, asset_name, replace):\n        task = unreal.AssetImportTask()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', bool(not cls.show_dialog))\n        task.set_editor_property('save', True)\n\n        # set import options here\n\n        return task\n\n    @classmethod\n    def import_and_containerize(\n        self, filepath, asset_dir, container_name\n    ):\n        unreal.log(\"Import using interchange method\")\n        unreal.SystemLibrary.execute_console_command(\n            None, \"Interchange.FeatureFlags.Import.PNG 1\")\n        unreal.SystemLibrary.execute_console_command(\n            None, \"Interchange.FeatureFlags.Import.JPG 1\")\n        unreal.SystemLibrary.execute_console_command(\n            None, \"Interchange.FeatureFlags.Import.TIFF 1\")\n        unreal.SystemLibrary.execute_console_command(\n            None, \"Interchange.FeatureFlags.Import.EXR 1\")\n\n        import_asset_parameters = unreal.ImportAssetParameters()\n        import_asset_parameters.is_automated = bool(not self.show_dialog)\n\n        source_data = unreal.InterchangeManager.create_source_data(\n            filepath)\n        interchange_manager = unreal.InterchangeManager.get_interchange_manager_scripted()  # noqa\n        interchange_manager.import_asset(asset_dir, source_data,\n                                            import_asset_parameters)\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        repre_entity,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"folder_path\": folder_path,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"product_type\": product_type,\n            # TODO these shold be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            options (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n        self.import_and_containerize(path, asset_dir, container_name)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            context[\"product\"][\"productType\"],\n            context[\"project\"][\"name\"]\n        )\n\n        asset_contents = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n        for unreal_asset in asset_contents:\n            unreal.EditorAssetLibrary.save_asset(unreal_asset)\n\n        return asset_contents\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n\n        # Create directory for asset and Ayon container\n        suffix = \"_CON\"\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n        self.import_and_containerize(path, asset_dir, container_name)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_contents = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n        for unreal_asset in asset_contents:\n            unreal.EditorAssetLibrary.save_asset(unreal_asset)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_image_png.html#client.ayon_unreal.plugins.load.load_image_png.TexturePNGLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>options</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_image_png.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        options (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_path = context[\"folder\"][\"path\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n    self.import_and_containerize(path, asset_dir, container_name)\n\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        context[\"product\"][\"productType\"],\n        context[\"project\"][\"name\"]\n    )\n\n    asset_contents = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n    for unreal_asset in asset_contents:\n        unreal.EditorAssetLibrary.save_asset(unreal_asset)\n\n    return asset_contents\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_layout.html","title":"load_layout","text":"<p>Loader for layouts.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_layout.html#client.ayon_unreal.plugins.load.load_layout.LayoutLoader","title":"<code>LayoutLoader</code>","text":"<p>               Bases: <code>LayoutLoader</code></p> <p>Load Layout from a JSON file</p> Source code in <code>client/ayon_unreal/plugins/load/load_layout.py</code> <pre><code>class LayoutLoader(plugin.LayoutLoader):\n    \"\"\"Load Layout from a JSON file\"\"\"\n\n    label = \"Load Layout\"\n    force_loaded = False\n    folder_representation_type = \"json\"\n    level_sequences_for_layouts = True\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(LayoutLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        import_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.force_loaded = import_settings[\"force_loaded\"]\n        cls.folder_representation_type = (\n            import_settings[\"folder_representation_type\"]\n        )\n        cls.level_sequences_for_layouts = (\n            import_settings[\"level_sequences_for_layouts\"]\n        )\n        cls.loaded_layout_dir = import_settings[\"loaded_layout_dir\"]\n        cls.remove_loaded_assets = import_settings[\"remove_loaded_assets\"]\n\n    @classmethod\n    def get_options(cls, contexts):\n        defs = []\n        if cls.force_loaded:\n            defs.append(\n                EnumDef(\n                    \"folder_representation_type\",\n                    label=\"Override layout representation by\",\n                    items={\n                        \"json\": \"json\",\n                        \"fbx\": \"fbx\",\n                        \"abc\": \"abc\"\n                    },\n                    default=cls.folder_representation_type\n                )\n            )\n        return defs\n\n    def _process_family(\n        self, assets, class_name, transform, basis, sequence, inst_name=None,\n        rotation=None, unreal_import=False\n    ):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        actors = []\n        bindings = []\n\n        for asset in assets:\n            obj = ar.get_asset_by_object_path(asset).get_asset()\n            if obj.get_class().get_name() == class_name:\n                t = self._transform_from_basis(\n                    transform, basis, unreal_import=unreal_import)\n                actor = EditorLevelLibrary.spawn_actor_from_object(\n                    obj, t.translation\n                )\n                actor_rotation = t.rotation.rotator()\n                if rotation:\n                    actor_rotation = unreal.Rotator(\n                        roll=rotation[\"x\"], pitch=rotation[\"z\"],\n                        yaw=-rotation[\"y\"])\n                actor.set_actor_rotation(actor_rotation, False)\n                actor.set_actor_scale3d(t.scale3d)\n\n                if class_name == 'SkeletalMesh':\n                    skm_comp = actor.get_editor_property(\n                        'skeletal_mesh_component')\n                    skm_comp.set_bounds_scale(10.0)\n\n                actors.append(actor)\n\n                if sequence:\n                    binding = None\n                    for p in sequence.get_possessables():\n                        if p.get_name() == actor.get_name():\n                            binding = p\n                            break\n\n                    if not binding:\n                        binding = sequence.add_possessable(actor)\n\n                    bindings.append(binding)\n\n        return actors, bindings\n\n    def _process(self, lib_path, project_name, asset_dir, sequence,\n                 repr_loaded=None, loaded_extension=None,\n                 force_loaded=False):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        with open(lib_path, \"r\") as fp:\n            data = json.load(fp)\n\n\n        if not repr_loaded:\n            repr_loaded = []\n\n        path = Path(lib_path)\n\n        skeleton_dict = {}\n        actors_dict = {}\n        bindings_dict = {}\n\n        loaded_assets = []\n\n        repre_entities_by_version_id = self._get_repre_entities_by_version_id(\n            project_name, data, loaded_extension, force_loaded=force_loaded\n        )\n        for element in data:\n            repre_id = None\n            repr_format = None\n            if element.get('representation'):\n                version_id = element.get(\"version\")\n                repre_entities = repre_entities_by_version_id[version_id]\n                if not repre_entities:\n                    self.log.error(\n                        f\"No valid representation found for version\"\n                        f\" {version_id}\")\n                    continue\n                extension = element.get(\"extension\", \"ma\")\n                repre_entity = None\n                if not force_loaded or loaded_extension == \"json\":\n                    repre_entity = next((repre_entity for repre_entity in repre_entities\n                                         if repre_entity[\"name\"] == extension), None)\n                    if not repre_entity or extension == \"ma\":\n                        repre_entity = repre_entities[0]\n                else:\n                    # use the prioritized representation\n                    # to load the assets\n                    repre_entity = repre_entities[0]\n                repre_id = repre_entity[\"id\"]\n                repr_format = repre_entity[\"name\"]\n\n            # If reference is None, this element is skipped, as it cannot be\n            # imported in Unreal\n            if not repr_format:\n                self.log.warning(f\"Representation name not defined for element: {element}\")\n                continue\n\n            instance_name = element.get('instance_name')\n\n            skeleton = None\n\n            if repre_id not in repr_loaded:\n                repr_loaded.append(repre_id)\n\n                product_type = element.get(\"product_type\")\n                if product_type is None:\n                    product_type = element.get(\"family\")\n\n                assets = self._load_assets(\n                    instance_name, repre_id,\n                    product_type, repr_format)\n\n                container = None\n\n                for asset in assets:\n                    obj = ar.get_asset_by_object_path(asset).get_asset()\n                    if obj.get_class().get_name() == 'AyonAssetContainer':\n                        container = obj\n                    if obj.get_class().get_name() == 'Skeleton':\n                        skeleton = obj\n                    if container is not None:\n                        loaded_assets.append(container.get_path_name())\n\n                instances = [\n                    item for item in data\n                    if ((item.get('version') and\n                        item.get('version') == element.get('version'))\n                        )]\n\n                for instance in instances:\n                    transform = instance.get('transform_matrix')\n                    rotation = instance.get('rotation', {})\n                    basis = instance.get('basis')\n                    inst = instance.get('instance_name')\n                    unreal_import = (\n                        True if \"unreal\" in instance.get(\"host\", []) else False\n                    )\n\n                    actors = []\n\n                    if product_type in ['model', 'staticMesh']:\n                        actors, _ = self._process_family(\n                            assets, 'StaticMesh', transform, basis,\n                            sequence, inst, rotation, unreal_import=unreal_import\n                        )\n                    elif product_type in ['rig', 'skeletalMesh']:\n                        actors, bindings = self._process_family(\n                            assets, 'SkeletalMesh', transform, basis,\n                            sequence, inst, rotation, unreal_import=unreal_import\n                        )\n                        actors_dict[inst] = actors\n                        bindings_dict[inst] = bindings\n\n                if skeleton:\n                    skeleton_dict[repre_id] = skeleton\n            else:\n                skeleton = skeleton_dict.get(repre_id)\n\n            animation_file = element.get('animation')\n\n            if animation_file and skeleton:\n                import_animation(\n                    asset_dir, path, instance_name, skeleton, actors_dict,\n                    animation_file, bindings_dict, sequence\n                )\n\n        return loaded_assets\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        This is two step process. First, import FBX to temporary path and\n        then call `containerise()` on it - this moves all content to new\n        directory and then it will create AssetContainer there and imprint it\n        with metadata. This will mark this path as container.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            options (dict): Those would be data to be imprinted. This is not\n                used now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        data = get_current_project_settings()\n        create_sequences = (\n            data[\"unreal\"][\"import_settings\"][\"level_sequences_for_layouts\"]\n        )\n        # Create directory for asset and Ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        folder_name = folder_entity[\"name\"]\n        asset_root, _ = format_asset_directory(context, self.loaded_layout_dir)\n        master_dir_name = get_top_hierarchy_folder(asset_root)\n        asset_dir, hierarchy_dir, container_name, asset_name = (\n            generate_hierarchy_path(\n                name, folder_name, asset_root, master_dir_name\n            )\n        )\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n\n        asset_level = f\"{asset_dir}/{folder_name}_map.{folder_name}_map\"\n        if not EditorAssetLibrary.does_asset_exist(asset_level):\n            EditorLevelLibrary.new_level(f\"{asset_dir}/{folder_name}_map\")\n\n        shot = None\n        sequences = []\n        if create_sequences:\n            shot, _, asset_level, sequences, frame_ranges = (\n                generate_master_level_sequence(\n                    tools, asset_dir, folder_name,\n                    hierarchy_dir, master_dir_name\n                )\n            )\n\n            project_name = get_current_project_name()\n            folder_attributes = (\n                ayon_api.get_folder_by_path(project_name, folder_path)[\"attrib\"]\n            )\n            shot.set_display_rate(\n                unreal.FrameRate(folder_attributes.get(\"fps\"), 1.0))\n            shot.set_playback_start(0)\n            shot.set_playback_end(\n                folder_attributes.get('clipOut')\n                - folder_attributes.get('clipIn')\n                + 1\n            )\n            if sequences:\n                min_frame = 0 if frame_ranges[-1][1] == 0 else folder_attributes.get('clipIn')\n                max_frame = folder_attributes.get('clipOut')\n                max_frame = min_frame + 1 if max_frame &lt; min_frame else max_frame\n                set_sequence_hierarchy(\n                    sequences[-1],\n                    shot,\n                    frame_ranges[-1][1],\n                    min_frame,\n                    max_frame,\n                    [asset_level])\n\n            EditorLevelLibrary.load_level(asset_level)\n        project_name = get_current_project_name()\n        extension = options.get(\n            \"folder_representation_type\", self.folder_representation_type)\n        path = self.filepath_from_context(context)\n        loaded_assets = self._process(\n            path, project_name, asset_dir, shot,\n            loaded_extension=extension,\n            force_loaded=self.force_loaded)\n        for s in sequences:\n            EditorAssetLibrary.save_asset(s.get_path_name())\n\n        EditorLevelLibrary.save_current_level()\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"\n        ):\n            # Create Asset Container\n            create_container(container=container_name, path=asset_dir)\n        self.imprint(\n            context,\n            folder_path,\n            folder_name,\n            loaded_assets,\n            asset_dir,\n            asset_name,\n            container_name,\n            context[\"project\"][\"name\"],\n            hierarchy_dir=hierarchy_dir\n        )\n        save_dir = hierarchy_dir if create_sequences else asset_dir\n\n        asset_content = EditorAssetLibrary.list_assets(\n            save_dir, recursive=True, include_folder=False)\n\n        for a in asset_content:\n            EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        project_name = context[\"project\"][\"name\"]\n        data = get_current_project_settings()\n        create_sequences = (\n            data[\"unreal\"][\"import_settings\"][\"level_sequences_for_layouts\"]\n        )\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        curr_level_sequence = LevelSequenceLib.get_current_level_sequence()\n        curr_time = LevelSequenceLib.get_current_time()\n        is_cam_lock = LevelSequenceLib.is_camera_cut_locked_to_viewport()\n\n        editor_subsystem = unreal.UnrealEditorSubsystem()\n        vp_loc, vp_rot = editor_subsystem.get_level_viewport_camera_info()\n\n        asset_dir = container.get('namespace')\n        repre_entity = context[\"representation\"]\n        sequence = None\n        master_level = None\n        hierarchy_dir = container.get(\"master_directory\", \"\")\n        master_dir_name = get_top_hierarchy_folder(asset_dir)\n        if not hierarchy_dir:\n            hierarchy_dir = f\"{AYON_ROOT_DIR}/{master_dir_name}\"\n        if create_sequences:\n            master_level = f\"{hierarchy_dir}/{master_dir_name}_map.{master_dir_name}_map\"\n            filter = unreal.ARFilter(\n                class_names=[\"LevelSequence\"],\n                package_paths=[asset_dir],\n                recursive_paths=False)\n            sequences = ar.get_assets(filter)\n            sequence = sequences[0].get_asset()\n\n        prev_level = None\n\n        if not master_level:\n            curr_level = unreal.LevelEditorSubsystem().get_current_level()\n            curr_level_path = curr_level.get_outer().get_path_name()\n            # If the level path does not start with \"/Game/\", the current\n            # level is a temporary, unsaved level.\n            if curr_level_path.startswith(\"/Game/\"):\n                prev_level = curr_level_path\n\n        # Get layout level\n        filter = unreal.ARFilter(\n            class_names=[\"World\"],\n            package_paths=[asset_dir],\n            recursive_paths=False)\n        levels = ar.get_assets(filter)\n\n        layout_level = levels[0].get_asset().get_path_name()\n\n        EditorLevelLibrary.save_all_dirty_levels()\n        EditorLevelLibrary.load_level(layout_level)\n\n        # Delete all the actors in the level\n        actors = unreal.EditorLevelLibrary.get_all_level_actors()\n        for actor in actors:\n            unreal.EditorLevelLibrary.destroy_actor(actor)\n\n        if create_sequences:\n            EditorLevelLibrary.save_current_level()\n        source_path = get_representation_path(repre_entity)\n\n        loaded_assets = self._process(\n            source_path, project_name, asset_dir, sequence,\n            loaded_extension=self.folder_representation_type,\n            force_loaded=self.force_loaded)\n\n        update_container(container, project_name, repre_entity, loaded_assets=loaded_assets)\n\n        EditorLevelLibrary.save_current_level()\n\n        save_dir = hierarchy_dir if create_sequences else asset_dir\n\n        asset_content = EditorAssetLibrary.list_assets(\n            save_dir, recursive=True, include_folder=False)\n\n        for a in asset_content:\n            EditorAssetLibrary.save_asset(a)\n\n        if master_level:\n            EditorLevelLibrary.load_level(master_level)\n        elif prev_level:\n            EditorLevelLibrary.load_level(prev_level)\n\n        if curr_level_sequence:\n            LevelSequenceLib.open_level_sequence(curr_level_sequence)\n            LevelSequenceLib.set_current_time(curr_time)\n            LevelSequenceLib.set_lock_camera_cut_to_viewport(is_cam_lock)\n\n        editor_subsystem.set_level_viewport_camera_info(vp_loc, vp_rot)\n\n    def remove(self, container):\n        self._remove_Loaded_asset(container)\n        master_sequence = None\n        sequences = []\n        if self.level_sequences_for_layouts:\n            # Remove the Level Sequence from the parent.\n            # We need to traverse the hierarchy from the master sequence to\n            # find the level sequence.\n            master_directory = container.get(\"master_directory\", \"\")\n            if not master_directory:\n                namespace = container.get('namespace').replace(f\"{AYON_ROOT_DIR}/\", \"\")\n                ms_asset = namespace.split('/')[0]\n                master_directory = f\"{AYON_ROOT_DIR}/{ms_asset}\"\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n            _filter = unreal.ARFilter(\n                class_names=[\"LevelSequence\"],\n                package_paths=[master_directory],\n                recursive_paths=False)\n            sequences = ar.get_assets(_filter)\n            master_sequence = sequences[0].get_asset()\n            sequences = [master_sequence]\n\n            parent = None\n            for s in sequences:\n                tracks = get_tracks(s)\n                subscene_track = None\n                visibility_track = None\n                for t in tracks:\n                    if t.get_class() == unreal.MovieSceneSubTrack.static_class():\n                        subscene_track = t\n                    if (t.get_class() ==\n                            unreal.MovieSceneLevelVisibilityTrack.static_class()):\n                        visibility_track = t\n                if subscene_track:\n                    sections = subscene_track.get_sections()\n                    for ss in sections:\n                        try:\n                            if (ss.get_sequence().get_name() ==\n                                    container.get('asset')):\n                                parent = s\n                                subscene_track.remove_section(ss)\n                                break\n                            sequences.append(ss.get_sequence())\n                        except AttributeError:\n                            unreal.log(\"Cannot get the level sequences\")\n                    # Update subscenes indexes.\n                    i = 0\n                    for ss in sections:\n                        ss.set_row_index(i)\n                        i += 1\n\n                if visibility_track:\n                    sections = visibility_track.get_sections()\n                    for ss in sections:\n                        if (unreal.Name(f\"{container.get('asset')}_map\")\n                                in ss.get_level_names()):\n                            visibility_track.remove_section(ss)\n                    # Update visibility sections indexes.\n                    i = -1\n                    prev_name = []\n                    for ss in sections:\n                        if prev_name != ss.get_level_names():\n                            i += 1\n                        ss.set_row_index(i)\n                        prev_name = ss.get_level_names()\n                if parent:\n                    break\n\n            assert parent, \"Could not find the parent sequence\"\n\n        remove_map_and_sequence(container)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_layout.html#client.ayon_unreal.plugins.load.load_layout.LayoutLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>This is two step process. First, import FBX to temporary path and then call <code>containerise()</code> on it - this moves all content to new directory and then it will create AssetContainer there and imprint it with metadata. This will mark this path as container.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>options</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_layout.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    This is two step process. First, import FBX to temporary path and\n    then call `containerise()` on it - this moves all content to new\n    directory and then it will create AssetContainer there and imprint it\n    with metadata. This will mark this path as container.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        options (dict): Those would be data to be imprinted. This is not\n            used now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    data = get_current_project_settings()\n    create_sequences = (\n        data[\"unreal\"][\"import_settings\"][\"level_sequences_for_layouts\"]\n    )\n    # Create directory for asset and Ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = folder_entity[\"path\"]\n    folder_name = folder_entity[\"name\"]\n    asset_root, _ = format_asset_directory(context, self.loaded_layout_dir)\n    master_dir_name = get_top_hierarchy_folder(asset_root)\n    asset_dir, hierarchy_dir, container_name, asset_name = (\n        generate_hierarchy_path(\n            name, folder_name, asset_root, master_dir_name\n        )\n    )\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n\n    asset_level = f\"{asset_dir}/{folder_name}_map.{folder_name}_map\"\n    if not EditorAssetLibrary.does_asset_exist(asset_level):\n        EditorLevelLibrary.new_level(f\"{asset_dir}/{folder_name}_map\")\n\n    shot = None\n    sequences = []\n    if create_sequences:\n        shot, _, asset_level, sequences, frame_ranges = (\n            generate_master_level_sequence(\n                tools, asset_dir, folder_name,\n                hierarchy_dir, master_dir_name\n            )\n        )\n\n        project_name = get_current_project_name()\n        folder_attributes = (\n            ayon_api.get_folder_by_path(project_name, folder_path)[\"attrib\"]\n        )\n        shot.set_display_rate(\n            unreal.FrameRate(folder_attributes.get(\"fps\"), 1.0))\n        shot.set_playback_start(0)\n        shot.set_playback_end(\n            folder_attributes.get('clipOut')\n            - folder_attributes.get('clipIn')\n            + 1\n        )\n        if sequences:\n            min_frame = 0 if frame_ranges[-1][1] == 0 else folder_attributes.get('clipIn')\n            max_frame = folder_attributes.get('clipOut')\n            max_frame = min_frame + 1 if max_frame &lt; min_frame else max_frame\n            set_sequence_hierarchy(\n                sequences[-1],\n                shot,\n                frame_ranges[-1][1],\n                min_frame,\n                max_frame,\n                [asset_level])\n\n        EditorLevelLibrary.load_level(asset_level)\n    project_name = get_current_project_name()\n    extension = options.get(\n        \"folder_representation_type\", self.folder_representation_type)\n    path = self.filepath_from_context(context)\n    loaded_assets = self._process(\n        path, project_name, asset_dir, shot,\n        loaded_extension=extension,\n        force_loaded=self.force_loaded)\n    for s in sequences:\n        EditorAssetLibrary.save_asset(s.get_path_name())\n\n    EditorLevelLibrary.save_current_level()\n    if not unreal.EditorAssetLibrary.does_asset_exist(\n        f\"{asset_dir}/{container_name}\"\n    ):\n        # Create Asset Container\n        create_container(container=container_name, path=asset_dir)\n    self.imprint(\n        context,\n        folder_path,\n        folder_name,\n        loaded_assets,\n        asset_dir,\n        asset_name,\n        container_name,\n        context[\"project\"][\"name\"],\n        hierarchy_dir=hierarchy_dir\n    )\n    save_dir = hierarchy_dir if create_sequences else asset_dir\n\n    asset_content = EditorAssetLibrary.list_assets(\n        save_dir, recursive=True, include_folder=False)\n\n    for a in asset_content:\n        EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_layout_existing.html","title":"load_layout_existing","text":""},{"location":"autoapi/client/ayon_unreal/plugins/load/load_layout_existing.html#client.ayon_unreal.plugins.load.load_layout_existing.ExistingLayoutLoader","title":"<code>ExistingLayoutLoader</code>","text":"<p>               Bases: <code>LayoutLoader</code></p> <p>Load Layout for an existing scene, and match the existing assets.</p> Source code in <code>client/ayon_unreal/plugins/load/load_layout_existing.py</code> <pre><code>class ExistingLayoutLoader(plugin.LayoutLoader):\n    \"\"\"\n    Load Layout for an existing scene, and match the existing assets.\n    \"\"\"\n\n    label = \"Load Layout on Existing Scene\"\n    delete_unmatched_assets = True\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(ExistingLayoutLoader, cls).apply_settings(\n            project_settings\n        )\n        import_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.delete_unmatched_assets = (\n            import_settings[\"delete_unmatched_assets\"]\n        )\n        cls.loaded_layout_dir = import_settings[\"loaded_layout_dir\"]\n        cls.remove_loaded_assets = import_settings[\"remove_loaded_assets\"]\n\n    def _spawn_actor(self, obj, lasset, sequence):\n        actor = EditorLevelLibrary.spawn_actor_from_object(\n            obj, unreal.Vector(0.0, 0.0, 0.0)\n        )\n\n        transform = lasset.get('transform_matrix')\n        basis = lasset.get('basis')\n        rotation = lasset.get(\"rotation\", {})\n        unreal_import = (\n            True if \"unreal\" in lasset.get(\"host\", []) else False\n        )\n\n        computed_transform = self._transform_from_basis(\n            transform, basis, unreal_import=unreal_import)\n\n        actor.set_actor_transform(computed_transform, False, True)\n        if rotation:\n            actor_rotation = unreal.Rotator(\n                roll=rotation[\"x\"], pitch=rotation[\"z\"],\n                yaw=-rotation[\"y\"])\n            actor.set_actor_rotation(actor_rotation, False)\n        if sequence is not None:\n            sequence.add_possessable(actor)\n        else:\n            self.log.warning(\n                \"No Level Sequence found for current level. \"\n                \"Skipping to add spawned actor into the sequence.\"\n            )\n\n    def _load_asset(self, repr_data, instance_name, family, extension):\n        repre_entity = next((repre_entity for repre_entity in repr_data\n                             if repre_entity[\"name\"] == extension), None)\n        if not repre_entity or extension == \"ma\":\n            repre_entity = repr_data[0]\n\n        repr_format = repre_entity.get('name')\n        representation = repre_entity.get('id')\n        assets = self._load_assets(\n            instance_name, representation, family, repr_format)\n        return assets\n\n    def _process(self, lib_path, project_name, sequence):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        actors = EditorLevelLibrary.get_all_level_actors()\n\n        with open(lib_path, \"r\") as fp:\n            data = json.load(fp)\n\n        elements = []\n        repre_ids = set()\n        extensions = []\n        # Get all the representations in the JSON from the database.\n        for element in data:\n            repre_id = element.get('representation')\n            extension = element.get(\"extension\", \"ma\")\n            if repre_id:\n                repre_ids.add(repre_id)\n                elements.append(element)\n            if extension == \"ma\":\n                extensions.extend([\"fbx\", \"abc\"])\n            else:\n                extensions.append(extension)\n\n        repre_entities = ayon_api.get_representations(\n            project_name, representation_ids=repre_ids\n        )\n        repre_entities_by_id = {\n            repre_entity[\"id\"]: repre_entity\n            for repre_entity in repre_entities\n        }\n        layout_data = []\n        version_ids = set()\n        for element in elements:\n            repre_id = element.get(\"representation\")\n            repre_entity = repre_entities_by_id.get(repre_id)\n            if not repre_entity:\n                raise AssertionError(\"Representation not found\")\n            if not (\n                repre_entity.get(\"attrib\")\n                or repre_entity[\"attrib\"].get(\"path\")\n            ):\n                raise AssertionError(\"Representation does not have path\")\n            if not repre_entity.get('context'):\n                raise AssertionError(\"Representation does not have context\")\n\n            layout_data.append((repre_entity, element))\n            version_ids.add(repre_entity[\"versionId\"])\n\n        repre_entities_by_version_id = self._get_repre_entities_by_version_id(\n            project_name, data, \"json\"\n        )\n        containers = []\n        actors_matched = []\n\n        for (repre_entity, lasset) in layout_data:\n            # For every actor in the scene, check if it has a representation in\n            # those we got from the JSON. If so, create a container for it.\n            # Otherwise, remove it from the scene.\n            found = False\n            repre_id = repre_entity[\"id\"]\n\n            for actor in actors:\n                if not actor.get_class().get_name() == 'StaticMeshActor':\n                    continue\n                if actor in actors_matched:\n                    continue\n\n                # Get the original path of the file from which the asset has\n                # been imported.\n                smc = actor.get_editor_property('static_mesh_component')\n                mesh = smc.get_editor_property('static_mesh')\n                if not mesh:\n                    continue\n                import_data = mesh.get_editor_property('asset_import_data')\n                filename = import_data.get_first_filename()\n                path = Path(filename)\n\n                if (not path.name or\n                        path.name not in repre_entity[\"attrib\"][\"path\"]):\n                    unreal.log(\"Path is not found in representation entity\")\n                    continue\n                existing_asset_dir = unreal.Paths.get_path(mesh.get_path_name())\n                assets = ar.get_assets_by_path(existing_asset_dir, recursive=False)\n                for asset in assets:\n                    obj = asset.get_asset()\n                    if asset.get_class().get_name() == 'AyonAssetContainer':\n                        container = obj\n                        containers.append(container.get_path_name())\n                # Set the transform for the actor.\n                transform = lasset.get('transform_matrix')\n                basis = lasset.get('basis')\n                rotation = lasset.get(\"rotation\", {})\n                unreal_import = (\n                    True if \"unreal\" in lasset.get(\"host\", []) else False\n                )\n\n                computed_transform = self._transform_from_basis(\n                    transform, basis, unreal_import=unreal_import)\n                actor.set_actor_transform(computed_transform, False, True)\n                if rotation:\n                    actor_rotation = unreal.Rotator(\n                        roll=rotation[\"x\"], pitch=rotation[\"z\"],\n                        yaw=-rotation[\"y\"])\n                    actor.set_actor_rotation(actor_rotation, False)\n                actors_matched.append(actor)\n                found = True\n                break\n\n            # If an actor has not been found for this representation,\n            # we check if it has been loaded already by checking all the\n            # loaded containers. If so, we add it to the scene. Otherwise,\n            # we load it.\n            if found:\n                continue\n\n            all_containers = upipeline.ls()\n\n            loaded = False\n\n            for container in all_containers:\n                repre_id = container.get('representation')\n\n                if not repre_id == repre_entity[\"id\"]:\n                    continue\n\n                asset_dir = container.get('namespace')\n\n                arfilter = unreal.ARFilter(\n                    class_names=[\"StaticMesh\"],\n                    package_paths=[asset_dir],\n                    recursive_paths=False)\n                assets = ar.get_assets(arfilter)\n\n                for asset in assets:\n                    obj = asset.get_asset()\n                    self._spawn_actor(obj, lasset, sequence)\n                loaded = True\n                break\n\n            # If the asset has not been loaded yet, we load it.\n            if loaded:\n                continue\n\n            version_id = lasset.get('version')\n            repre_entities = repre_entities_by_version_id.get(version_id)\n            if not repre_entities:\n                self.log.error(\n                    f\"No valid representation found for version\"\n                    f\" {version_id}\")\n                continue\n\n            product_type = lasset.get(\"product_type\")\n            if product_type is None:\n                product_type = lasset.get(\"family\")\n            extension = lasset.get(\"extension\")\n            assets = self._load_asset(\n                repre_entities,\n                lasset.get('instance_name'),\n                product_type,\n                extension\n            )\n            con = None\n            for asset in assets:\n                obj = ar.get_asset_by_object_path(asset).get_asset()\n                if not obj.get_class().get_name() == 'StaticMesh':\n                    continue\n\n                self._spawn_actor(obj, lasset, sequence)\n                if obj.get_class().get_name() == 'AyonAssetContainer':\n                    con = obj\n                    containers.append(con.get_path_name())\n                break\n        # Check if an actor was not matched to a representation.\n        # If so, remove it from the scene.\n        for actor in actors:\n            if not actor.get_class().get_name() == 'StaticMeshActor':\n                continue\n            if actor not in actors_matched:\n                self.log.warning(f\"Actor {actor.get_name()} not matched.\")\n                if self.delete_unmatched_assets:\n                    EditorLevelLibrary.destroy_actor(actor)\n\n        return containers\n\n    def load(self, context, name, namespace, options):\n        print(\"Loading Layout and Match Assets\")\n\n        # Create directory for asset and Ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n\n        folder_name = folder_entity[\"name\"]\n        asset_root, _ = upipeline.format_asset_directory(\n            context, self.loaded_layout_dir)\n        suffix = \"_CON\"\n        asset_name = f\"{folder_name}_{name}\" if folder_name else name\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root,\n            suffix=\"_existing\"\n        )\n\n        sub_sys = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)\n        curr_level = sub_sys.get_current_level()\n        curr_asset_dir = Path(\n            curr_level.get_outer().get_path_name()).parent.as_posix()\n        if curr_asset_dir == \"/Temp\":\n            curr_asset_dir = asset_dir\n        #TODO: make sure asset_dir is not a temp path,\n        # create new level for layout level\n        level_seq_filter = unreal.ARFilter(\n            class_names=[\"LevelSequence\"],\n            package_paths=[curr_asset_dir],\n            recursive_paths=False)\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        sequence = next((asset.get_asset() for asset in ar.get_assets(level_seq_filter)), None)\n        if not curr_level:\n            raise LoadError(\"Current level not saved\")\n\n        project_name = context[\"project\"][\"name\"]\n        path = self.filepath_from_context(context)\n        loaded_assets = self._process(path, project_name, sequence)\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{curr_asset_dir}/{container_name}\"\n        ):\n            upipeline.create_container(\n                container=container_name, path=curr_asset_dir)\n        self.imprint(\n            context,\n            folder_path,\n            folder_name,\n            loaded_assets,\n            curr_asset_dir,\n            asset_name,\n            container_name,\n            context[\"project\"][\"name\"]\n        )\n\n    def update(self, container, context):\n        asset_dir = container.get('namespace')\n\n        project_name = context[\"project\"][\"name\"]\n        repre_entity = context[\"representation\"]\n        level_seq_filter = unreal.ARFilter(\n            class_names=[\"LevelSequence\"],\n            package_paths=[asset_dir],\n            recursive_paths=False)\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        sequence = next((asset for asset in ar.get_assets(level_seq_filter)), None)\n        source_path = get_representation_path(repre_entity)\n        loaded_assets = self._process(source_path, project_name, sequence)\n\n        upipeline.update_container(\n            container, repre_entity, loaded_assets=loaded_assets)\n\n        unreal.EditorLevelLibrary.save_current_level()\n\n    def remove(self, container):\n        parent_path = Path(container[\"namespace\"])\n        self._remove_Loaded_asset(container)\n        container_name = container[\"container_name\"]\n        if unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{parent_path}/{container_name}\"):\n                unreal.EditorAssetLibrary.delete_asset(\n                    f\"{parent_path}/{container_name}\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_abc.html","title":"load_skeletalmesh_abc","text":"<p>Load Skeletal Mesh alembics.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_abc.html#client.ayon_unreal.plugins.load.load_skeletalmesh_abc.SkeletalMeshAlembicLoader","title":"<code>SkeletalMeshAlembicLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal SkeletalMesh from Alembic</p> Source code in <code>client/ayon_unreal/plugins/load/load_skeletalmesh_abc.py</code> <pre><code>class SkeletalMeshAlembicLoader(plugin.Loader):\n    \"\"\"Load Unreal SkeletalMesh from Alembic\"\"\"\n\n    product_types = {\"pointcache\", \"skeletalMesh\"}\n    label = \"Import Alembic Skeletal Mesh\"\n    representations = {\"abc\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    abc_conversion_preset = \"maya\"\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(SkeletalMeshAlembicLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.abc_conversion_preset = unreal_settings[\"abc_conversion_preset\"]\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"abc_conversion_preset\",\n                label=\"Alembic Conversion Preset\",\n                items={\n                    \"3dsmax\": \"3dsmax\",\n                    \"maya\": \"maya\",\n                    \"custom\": \"custom\"\n                },\n                default=cls.abc_conversion_preset\n            ),\n            EnumDef(\n                \"abc_material_settings\",\n                label=\"Alembic Material Settings\",\n                items={\n                    \"no_material\": \"Do not apply materials\",\n                    \"create_materials\": \"Create matarials by face sets\",\n                    \"find_materials\": \"Search matching materials by face sets\",\n                },\n                default=\"Do not apply materials\"\n            )\n        ]\n\n\n    @staticmethod\n    def get_task(filename, asset_dir, asset_name, replace, loaded_options):\n        task = unreal.AssetImportTask()\n        options = unreal.AbcImportSettings()\n        mat_settings = unreal.AbcMaterialSettings()\n        conversion_settings = unreal.AbcConversionSettings()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property(\n            'automated', not loaded_options.get(\"show_dialog\"))\n        task.set_editor_property('save', True)\n\n        options.set_editor_property(\n            'import_type', unreal.AlembicImportType.SKELETAL)\n        options.sampling_settings.frame_start = loaded_options.get(\"frameStart\")\n        options.sampling_settings.frame_end = loaded_options.get(\"frameEnd\")\n\n        if loaded_options.get(\"abc_material_settings\") == \"create_materials\":\n            mat_settings.set_editor_property(\"create_materials\", True)\n            mat_settings.set_editor_property(\"find_materials\", False)\n        elif loaded_options.get(\"abc_material_settings\") == \"find_materials\":\n            mat_settings.set_editor_property(\"create_materials\", False)\n            mat_settings.set_editor_property(\"find_materials\", True)\n        else:\n            mat_settings.set_editor_property(\"create_materials\", False)\n            mat_settings.set_editor_property(\"find_materials\", False)\n\n        if not loaded_options.get(\"default_conversion\"):\n            conversion_settings = None\n            abc_conversion_preset = loaded_options.get(\"abc_conversion_preset\")\n            if abc_conversion_preset == \"maya\":\n                if UNREAL_VERSION.major &gt;= 5 and UNREAL_VERSION.minor &gt;= 4:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.MAYA)\n                else:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.CUSTOM,\n                        flip_u=False, flip_v=True,\n                        rotation=[90.0, 0.0, 0.0],\n                        scale=[1.0, -1.0, 1.0])\n            elif abc_conversion_preset == \"3dsmax\":\n                if UNREAL_VERSION.major &gt;= 5:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.MAX)\n                else:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.CUSTOM,\n                        flip_u=False, flip_v=True,\n                        rotation=[0.0, 0.0, 0.0],\n                        scale=[1.0, -1.0, 1.0])\n            else:\n                data = get_current_project_settings()\n                preset = (\n                    data[\"unreal\"][\"import_settings\"][\"custom\"]\n                )\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=preset[\"flip_u\"],\n                    flip_v=preset[\"flip_v\"],\n                    rotation=[\n                        preset[\"rot_x\"],\n                        preset[\"rot_y\"],\n                        preset[\"rot_z\"]\n                    ],\n                    scale=[\n                        preset[\"scl_x\"],\n                        preset[\"scl_y\"],\n                        preset[\"scl_z\"]\n                    ]\n                )\n\n            options.conversion_settings = conversion_settings\n\n            options.material_settings = mat_settings\n\n        task.options = options\n\n        return task\n\n    def import_and_containerize(\n        self, filepath, asset_dir, asset_name, container_name,\n        loaded_options, asset_path=None\n    ):\n        task = None\n        if asset_path:\n            loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n            task = self.get_task(\n                filepath, loaded_asset_dir, asset_name, True, loaded_options)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(\n                        filepath, asset_dir, asset_name, False, loaded_options)\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        product_type,\n        frameStart,\n        frameEnd,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"product_type\": product_type,\n            \"frameStart\":frameStart,\n            \"frameEnd\": frameEnd,\n            # TODO these should be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and ayon container\n        folder_entity = context[\"folder\"]\n        folder_path = folder_entity[\"path\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        loaded_options = {\n            \"default_conversion\": options.get(\"default_conversion\", False),\n            \"abc_conversion_preset\": options.get(\n                \"abc_conversion_preset\", self.abc_conversion_preset),\n            \"abc_material_settings\": options.get(\"abc_material_settings\", \"no_material\"),\n            \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n            \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n        }\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n        container_name += suffix\n\n        asset_path = has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name, extension=ext)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        self.import_and_containerize(path, asset_dir, asset_name,\n                                     container_name, loaded_options,\n                                     asset_path=asset_path)\n\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n\n        product_type = context[\"product\"][\"productType\"]\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            product_type,\n            folder_entity[\"attrib\"][\"frameStart\"],\n            folder_entity[\"attrib\"][\"frameEnd\"],\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n\n        # Create directory for folder and Ayon container\n        suffix = \"_CON\"\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"default_conversion\": False,\n            \"abc_conversion_preset\": self.abc_conversion_preset,\n            \"frameStart\": container.get(\"frameStart\", 1),\n            \"frameEnd\": container.get(\"frameEnd\", 1)\n        }\n        self.import_and_containerize(path, asset_dir, asset_name,\n                                     container_name, loaded_options)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            container.get(\"frameStart\", 1),\n            container.get(\"frameEnd\", 1),\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_abc.html#client.ayon_unreal.plugins.load.load_skeletalmesh_abc.SkeletalMeshAlembicLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_skeletalmesh_abc.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and ayon container\n    folder_entity = context[\"folder\"]\n    folder_path = folder_entity[\"path\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n    loaded_options = {\n        \"default_conversion\": options.get(\"default_conversion\", False),\n        \"abc_conversion_preset\": options.get(\n            \"abc_conversion_preset\", self.abc_conversion_preset),\n        \"abc_material_settings\": options.get(\"abc_material_settings\", \"no_material\"),\n        \"frameStart\": folder_entity[\"attrib\"][\"frameStart\"],\n        \"frameEnd\": folder_entity[\"attrib\"][\"frameEnd\"]\n    }\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n    container_name += suffix\n\n    asset_path = has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name, extension=ext)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n    self.import_and_containerize(path, asset_dir, asset_name,\n                                 container_name, loaded_options,\n                                 asset_path=asset_path)\n\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n\n    product_type = context[\"product\"][\"productType\"]\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        product_type,\n        folder_entity[\"attrib\"][\"frameStart\"],\n        folder_entity[\"attrib\"][\"frameEnd\"],\n        context[\"project\"][\"name\"]\n    )\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_fbx.html","title":"load_skeletalmesh_fbx","text":"<p>Load Skeletal Meshes form FBX.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_fbx.html#client.ayon_unreal.plugins.load.load_skeletalmesh_fbx.SkeletalMeshFBXLoader","title":"<code>SkeletalMeshFBXLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal SkeletalMesh from FBX.</p> Source code in <code>client/ayon_unreal/plugins/load/load_skeletalmesh_fbx.py</code> <pre><code>class SkeletalMeshFBXLoader(plugin.Loader):\n    \"\"\"Load Unreal SkeletalMesh from FBX.\"\"\"\n\n    product_types = {\"rig\", \"skeletalMesh\"}\n    label = \"Import FBX Skeletal Mesh\"\n    representations = {\"fbx\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        super(SkeletalMeshFBXLoader, cls).apply_settings(project_settings)\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    @classmethod\n    def get_task(cls, filename, asset_dir, asset_name, replace):\n        task = unreal.AssetImportTask()\n        options = unreal.FbxImportUI()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', not cls.show_dialog)\n        task.set_editor_property('save', True)\n\n        options.set_editor_property(\n            'automated_import_should_detect_type', False)\n        options.set_editor_property('import_as_skeletal', True)\n        options.set_editor_property('import_animations', False)\n        options.set_editor_property('import_mesh', True)\n        options.set_editor_property('import_materials', False)\n        options.set_editor_property('import_textures', False)\n        options.set_editor_property('skeleton', None)\n        options.set_editor_property('create_physics_asset', False)\n\n        options.set_editor_property(\n            'mesh_type_to_import',\n            unreal.FBXImportType.FBXIT_SKELETAL_MESH)\n\n        options.skeletal_mesh_import_data.set_editor_property(\n            'import_content_type',\n            unreal.FBXImportContentType.FBXICT_ALL)\n\n        options.skeletal_mesh_import_data.set_editor_property(\n            'normal_import_method',\n            unreal.FBXNormalImportMethod.FBXNIM_IMPORT_NORMALS)\n\n        task.options = options\n\n        return task\n\n\n    def import_and_containerize(\n        self, filepath, asset_dir, asset_name, container_name,\n        asset_path=None\n    ):\n        task = None\n        if asset_path:\n            loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n            task = self.get_task(filepath, loaded_asset_dir, asset_name, False)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(filepath, asset_dir, asset_name, False)\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"product_type\": product_type,\n            # TODO these should be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_name = context[\"folder\"][\"name\"]\n        product_type = context[\"product\"][\"productType\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        asset_path = has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name, extension=ext)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n        self.import_and_containerize(\n            path, asset_dir, asset_name,\n            container_name, asset_path=asset_path\n        )\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n\n        self.imprint(\n            folder_name,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n\n        # Create directory for asset and Ayon container\n        suffix = \"_CON\"\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        self.import_and_containerize(path, asset_dir, asset_name, container_name)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_skeletalmesh_fbx.html#client.ayon_unreal.plugins.load.load_skeletalmesh_fbx.SkeletalMeshFBXLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_skeletalmesh_fbx.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_name = context[\"folder\"][\"name\"]\n    product_type = context[\"product\"][\"productType\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n    asset_path = has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name, extension=ext)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n    self.import_and_containerize(\n        path, asset_dir, asset_name,\n        container_name, asset_path=asset_path\n    )\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n\n    self.imprint(\n        folder_name,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        product_type,\n        context[\"project\"][\"name\"]\n    )\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_abc.html","title":"load_staticmesh_abc","text":"<p>Loader for Static Mesh alembics.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_abc.html#client.ayon_unreal.plugins.load.load_staticmesh_abc.StaticMeshAlembicLoader","title":"<code>StaticMeshAlembicLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal StaticMesh from Alembic</p> Source code in <code>client/ayon_unreal/plugins/load/load_staticmesh_abc.py</code> <pre><code>class StaticMeshAlembicLoader(plugin.Loader):\n    \"\"\"Load Unreal StaticMesh from Alembic\"\"\"\n\n    product_types = {\"model\", \"staticMesh\"}\n    label = \"Import Alembic Static Mesh\"\n    representations = {\"abc\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    abc_conversion_preset = \"maya\"\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    show_dialog = False\n\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(StaticMeshAlembicLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings[\"unreal\"][\"import_settings\"]\n        cls.abc_conversion_preset = unreal_settings[\"abc_conversion_preset\"]\n        cls.loaded_asset_dir = unreal_settings[\"loaded_asset_dir\"]\n        cls.show_dialog = unreal_settings[\"show_dialog\"]\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"abc_conversion_preset\",\n                label=\"Alembic Conversion Preset\",\n                items={\n                    \"3dsmax\": \"3dsmax\",\n                    \"maya\": \"maya\",\n                    \"custom\": \"custom\"\n                },\n                default=cls.abc_conversion_preset\n            ),\n            EnumDef(\n                \"abc_material_settings\",\n                label=\"Alembic Material Settings\",\n                items={\n                    \"no_material\": \"Do not apply materials\",\n                    \"create_materials\": \"Create matarials by face sets\",\n                    \"find_materials\": \"Search matching materials by face sets\",\n                },\n                default=\"no_materials\"\n            ),\n            BoolDef(\n                \"merge_meshes\",\n                label=\"Merge Meshes\",\n                default=True\n            )\n        ]\n\n    @staticmethod\n    def get_task(filename, asset_dir, asset_name, replace, loaded_options):\n        task = unreal.AssetImportTask()\n        options = unreal.AbcImportSettings()\n        sm_settings = unreal.AbcStaticMeshSettings()\n        mat_settings = unreal.AbcMaterialSettings()\n        conversion_settings = unreal.AbcConversionSettings()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property(\n            'automated', not loaded_options.get(\"show_dialog\"))\n        task.set_editor_property('save', True)\n\n        # set import options here\n        # Unreal 4.24 ignores the settings. It works with Unreal 4.26\n        options.set_editor_property(\n            'import_type', unreal.AlembicImportType.STATIC_MESH)\n\n        sm_settings.set_editor_property(\n            'merge_meshes', loaded_options.get(\"merge_meshes\", True))\n\n        if loaded_options.get(\"abc_material_settings\") == \"create_materials\":\n            mat_settings.set_editor_property(\"create_materials\", True)\n            mat_settings.set_editor_property(\"find_materials\", False)\n        elif loaded_options.get(\"abc_material_settings\") == \"find_materials\":\n            mat_settings.set_editor_property(\"create_materials\", False)\n            mat_settings.set_editor_property(\"find_materials\", True)\n        else:\n            mat_settings.set_editor_property(\"create_materials\", False)\n            mat_settings.set_editor_property(\"find_materials\", False)\n\n\n        if not loaded_options.get(\"default_conversion\"):\n            conversion_settings = None\n            abc_conversion_preset = loaded_options.get(\"abc_conversion_preset\")\n            if abc_conversion_preset == \"maya\":\n                if UNREAL_VERSION.major &gt;= 5 and UNREAL_VERSION.minor &gt;= 4:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.MAYA)\n                else:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.CUSTOM,\n                        flip_u=False, flip_v=True,\n                        rotation=[90.0, 0.0, 0.0],\n                        scale=[1.0, -1.0, 1.0])\n            elif abc_conversion_preset == \"3dsmax\":\n                if UNREAL_VERSION.major &gt;= 5:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.MAX)\n                else:\n                    conversion_settings = unreal.AbcConversionSettings(\n                        preset=unreal.AbcConversionPreset.CUSTOM,\n                        flip_u=False, flip_v=True,\n                        rotation=[0.0, 0.0, 0.0],\n                        scale=[1.0, -1.0, 1.0])\n            else:\n                data = get_current_project_settings()\n                preset = (\n                    data[\"unreal\"][\"import_settings\"][\"custom\"]\n                )\n                conversion_settings = unreal.AbcConversionSettings(\n                    preset=unreal.AbcConversionPreset.CUSTOM,\n                    flip_u=preset[\"flip_u\"],\n                    flip_v=preset[\"flip_v\"],\n                    rotation=[\n                        preset[\"rot_x\"],\n                        preset[\"rot_y\"],\n                        preset[\"rot_z\"]\n                    ],\n                    scale=[\n                        preset[\"scl_x\"],\n                        preset[\"scl_y\"],\n                        preset[\"scl_z\"]\n                    ]\n                )\n            options.conversion_settings = conversion_settings\n\n        options.static_mesh_settings = sm_settings\n        options.material_settings = mat_settings\n        task.options = options\n\n        return task\n\n    def import_and_containerize(\n        self, filepath, asset_dir, asset_name, container_name,\n        loaded_options, asset_path=None\n    ):\n        task = None\n        if asset_path:\n            loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n            task = self.get_task(\n                filepath, loaded_asset_dir, asset_name, True, loaded_options)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(\n                        filepath, asset_dir, asset_name, False, loaded_options)\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        representation,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"folder_path\": folder_path,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": representation[\"id\"],\n            \"parent\": representation[\"versionId\"],\n            \"product_type\": product_type,\n            # TODO these should be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        loaded_options = {\n            \"default_conversion\": options.get(\"default_conversion\", False),\n            \"abc_conversion_preset\": options.get(\n                \"abc_conversion_preset\", self.abc_conversion_preset),\n            \"abc_material_settings\": options.get(\"abc_material_settings\", \"no_material\"),\n            \"merge_meshes\": options.get(\"merge_meshes\", True),\n            \"show_dialog\": options.get(\"show_dialog\", self.show_dialog),\n        }\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        asset_path = has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name, extension=ext)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n            self.import_and_containerize(path, asset_dir, asset_name,\n                                         container_name, loaded_options,\n                                         asset_path=asset_path)\n\n        product_type = context[\"product\"][\"productType\"]\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n\n        # Create directory for asset and Ayon container\n        suffix = \"_CON\"\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        loaded_options = {\n            \"default_conversion\": False,\n            \"abc_conversion_preset\": self.abc_conversion_preset\n        }\n        self.import_and_containerize(path, asset_dir, asset_name,\n                                     container_name, loaded_options)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_abc.html#client.ayon_unreal.plugins.load.load_staticmesh_abc.StaticMeshAlembicLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_staticmesh_abc.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_path = context[\"folder\"][\"path\"]\n\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n    loaded_options = {\n        \"default_conversion\": options.get(\"default_conversion\", False),\n        \"abc_conversion_preset\": options.get(\n            \"abc_conversion_preset\", self.abc_conversion_preset),\n        \"abc_material_settings\": options.get(\"abc_material_settings\", \"no_material\"),\n        \"merge_meshes\": options.get(\"merge_meshes\", True),\n        \"show_dialog\": options.get(\"show_dialog\", self.show_dialog),\n    }\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n    asset_path = has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name, extension=ext)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n        self.import_and_containerize(path, asset_dir, asset_name,\n                                     container_name, loaded_options,\n                                     asset_path=asset_path)\n\n    product_type = context[\"product\"][\"productType\"]\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        product_type,\n        context[\"project\"][\"name\"]\n    )\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=False\n    )\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_fbx.html","title":"load_staticmesh_fbx","text":"<p>Load Static meshes form FBX.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_fbx.html#client.ayon_unreal.plugins.load.load_staticmesh_fbx.StaticMeshFBXLoader","title":"<code>StaticMeshFBXLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Unreal StaticMesh from FBX.</p> Source code in <code>client/ayon_unreal/plugins/load/load_staticmesh_fbx.py</code> <pre><code>class StaticMeshFBXLoader(plugin.Loader):\n    \"\"\"Load Unreal StaticMesh from FBX.\"\"\"\n\n    product_types = {\"model\", \"staticMesh\"}\n    label = \"Import FBX Static Mesh\"\n    representations = {\"fbx\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    use_nanite = True\n    show_dialog = False\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(StaticMeshFBXLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        unreal_settings = project_settings.get(\"unreal\", {})\n        import_settings = unreal_settings.get(\"import_settings\", {})\n        cls.use_interchange = import_settings.get(\"interchange\", {}).get(\n            \"enabled\", cls.use_interchange\n        )\n        cls.show_dialog = import_settings.get(\"show_dialog\", cls.show_dialog)\n        cls.use_nanite = import_settings.get(\"use_nanite\", cls.use_nanite)\n        cls.loaded_asset_dir = import_settings.get(\n            \"loaded_asset_dir\", cls.loaded_asset_dir)\n\n    @classmethod\n    def get_task(cls, filename, asset_dir, asset_name, replace):\n        task = unreal.AssetImportTask()\n        options = unreal.FbxImportUI()\n        import_data = unreal.FbxStaticMeshImportData()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', not cls.show_dialog)\n        task.set_editor_property('save', True)\n\n        # set import options here\n        options.set_editor_property(\n            'automated_import_should_detect_type', False)\n        options.set_editor_property('import_animations', False)\n\n        import_data.set_editor_property('combine_meshes', True)\n        import_data.set_editor_property('remove_degenerates', False)\n        import_data.set_editor_property('build_nanite', cls.use_nanite) #nanite\n\n        options.static_mesh_import_data = import_data\n        task.options = options\n\n        return task\n\n    @classmethod\n    def import_and_containerize(\n        cls, filepath, asset_dir, container_name\n    ):\n        unreal.log(\"Import using interchange method\")\n        unreal.SystemLibrary.execute_console_command(None, \"Interchange.FeatureFlags.Import.FBX 1\")\n\n        import_asset_parameters = unreal.ImportAssetParameters()\n        import_asset_parameters.is_automated = not cls.show_dialog\n\n        source_data = unreal.InterchangeManager.create_source_data(filepath)\n        interchange_manager = unreal.InterchangeManager.get_interchange_manager_scripted()\n        interchange_manager.import_asset(asset_dir, source_data, import_asset_parameters)\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                create_container(container=container_name, path=asset_dir)\n\n    def imprint(\n        self,\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        repre_entity,\n        product_type,\n        project_name\n    ):\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"folder_path\": folder_path,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"product_type\": product_type,\n            # TODO these shold be probably removed\n            \"asset\": folder_path,\n            \"family\": product_type,\n            \"project_name\": project_name\n        }\n        imprint(f\"{asset_dir}/{container_name}\", data)\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            options (dict): Those would be data to be imprinted.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n        # Create directory for asset and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name += suffix\n\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        self.import_and_containerize(path, asset_dir, container_name)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            context[\"representation\"],\n            context[\"product\"][\"productType\"],\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        folder_path = context[\"folder\"][\"path\"]\n        product_type = context[\"product\"][\"productType\"]\n        repre_entity = context[\"representation\"]\n\n        # Create directory for asset and Ayon container\n        suffix = \"_CON\"\n        path = get_representation_path(repre_entity)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n\n        container_name += suffix\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        self.import_and_containerize(path, asset_dir, container_name)\n\n        self.imprint(\n            folder_path,\n            asset_dir,\n            container_name,\n            asset_name,\n            repre_entity,\n            product_type,\n            context[\"project\"][\"name\"]\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=False\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_staticmesh_fbx.html#client.ayon_unreal.plugins.load.load_staticmesh_fbx.StaticMeshFBXLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>options</code> <code>dict</code> <p>Those would be data to be imprinted.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_staticmesh_fbx.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        options (dict): Those would be data to be imprinted.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n    # Create directory for asset and Ayon container\n    folder_path = context[\"folder\"][\"path\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name += suffix\n\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n    self.import_and_containerize(path, asset_dir, container_name)\n\n    self.imprint(\n        folder_path,\n        asset_dir,\n        container_name,\n        asset_name,\n        context[\"representation\"],\n        context[\"product\"][\"productType\"],\n        context[\"project\"][\"name\"]\n    )\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_uasset.html","title":"load_uasset","text":"<p>Load UAsset.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_uasset.html#client.ayon_unreal.plugins.load.load_uasset.UAssetLoader","title":"<code>UAssetLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load UAsset.</p> Source code in <code>client/ayon_unreal/plugins/load/load_uasset.py</code> <pre><code>class UAssetLoader(plugin.Loader):\n    \"\"\"Load UAsset.\"\"\"\n\n    product_types = {\"uasset\"}\n    label = \"Load UAsset\"\n    representations = {\"uasset\"}\n    icon = \"cube\"\n    color = \"orange\"\n\n    extension = \"uasset\"\n\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(UAssetLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        cls.loaded_asset_dir = (\n            project_settings[\"unreal\"]\n                            [\"import_settings\"]\n                            [\"loaded_asset_dir\"]\n        )\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            options (dict): Those would be data to be imprinted. This is not\n                used now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n        \"\"\"\n\n        # Create directory for asset and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        suffix = \"_CON\"\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=\"\"\n        )\n        container_name = f\"{container_name}_{suffix}\"\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n        destination_path = asset_dir.replace(\n            \"/Game\", Path(unreal.Paths.project_content_dir()).as_posix(), 1)\n\n        path = self.filepath_from_context(context)\n        asset_name = os.path.basename(path)\n        asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name)\n        if asset_path:\n            destination_path = unreal.Paths.split(asset_path)[0]\n        shutil.copy(path, f\"{destination_path}/{asset_name}\")\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                unreal_pipeline.create_container(\n                    container=container_name, path=asset_dir)\n\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"folder_path\": folder_path,\n            \"container_name\": container_name,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"product_type\": context[\"product\"][\"productType\"],\n            # TODO these should be probably removed\n            \"asset\": folder_path,\n            \"family\": context[\"product\"][\"productType\"],\n            \"asset_path\": asset_path,\n            \"project_name\": context[\"project\"][\"name\"]\n        }\n\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n\n        unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        asset_dir = container[\"namespace\"]\n        repre_entity = context[\"representation\"]\n\n        destination_path = asset_dir.replace(\n            \"/Game\", Path(unreal.Paths.project_content_dir()).as_posix(), 1)\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=False, include_folder=True\n        )\n\n        for asset in asset_content:\n            obj = ar.get_asset_by_object_path(asset).get_asset()\n            if obj.get_class().get_name() != \"AyonAssetContainer\":\n                unreal.EditorAssetLibrary.delete_asset(asset)\n\n        update_filepath = get_representation_path(repre_entity)\n        new_asset_name = os.path.basename(update_filepath)\n        shutil.copy(update_filepath, f\"{destination_path}/{new_asset_name}\")\n\n        container_path = f'{container[\"namespace\"]}/{container[\"objectName\"]}'\n        # update metadata\n        unreal_pipeline.imprint(\n            container_path,\n            {\n                \"representation\": repre_entity[\"id\"],\n                \"parent\": repre_entity[\"versionId\"],\n                \"project_name\": context[\"project\"][\"name\"]\n            }\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_uasset.html#client.ayon_unreal.plugins.load.load_uasset.UAssetLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>options</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_uasset.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        options (dict): Those would be data to be imprinted. This is not\n            used now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n    \"\"\"\n\n    # Create directory for asset and Ayon container\n    folder_path = context[\"folder\"][\"path\"]\n    suffix = \"_CON\"\n    asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=\"\"\n    )\n    container_name = f\"{container_name}_{suffix}\"\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n\n    destination_path = asset_dir.replace(\n        \"/Game\", Path(unreal.Paths.project_content_dir()).as_posix(), 1)\n\n    path = self.filepath_from_context(context)\n    asset_name = os.path.basename(path)\n    asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name)\n    if asset_path:\n        destination_path = unreal.Paths.split(asset_path)[0]\n    shutil.copy(path, f\"{destination_path}/{asset_name}\")\n\n    if not unreal.EditorAssetLibrary.does_asset_exist(\n        f\"{asset_dir}/{container_name}\"):\n            # Create Asset Container\n            unreal_pipeline.create_container(\n                container=container_name, path=asset_dir)\n\n    data = {\n        \"schema\": \"ayon:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"namespace\": asset_dir,\n        \"folder_path\": folder_path,\n        \"container_name\": container_name,\n        \"asset_name\": asset_name,\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"product_type\": context[\"product\"][\"productType\"],\n        # TODO these should be probably removed\n        \"asset\": folder_path,\n        \"family\": context[\"product\"][\"productType\"],\n        \"asset_path\": asset_path,\n        \"project_name\": context[\"project\"][\"name\"]\n    }\n\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n\n    unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_uasset.html#client.ayon_unreal.plugins.load.load_uasset.UMapLoader","title":"<code>UMapLoader</code>","text":"<p>               Bases: <code>UAssetLoader</code></p> <p>Load Level.</p> Source code in <code>client/ayon_unreal/plugins/load/load_uasset.py</code> <pre><code>class UMapLoader(UAssetLoader):\n    \"\"\"Load Level.\"\"\"\n\n    product_types = {\"uasset\"}\n    label = \"Load Level\"\n    representations = {\"umap\"}\n\n    extension = \"umap\"\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_yeticache.html","title":"load_yeticache","text":"<p>Loader for Yeti Cache.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_yeticache.html#client.ayon_unreal.plugins.load.load_yeticache.YetiLoader","title":"<code>YetiLoader</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load Yeti Cache</p> Source code in <code>client/ayon_unreal/plugins/load/load_yeticache.py</code> <pre><code>class YetiLoader(plugin.Loader):\n    \"\"\"Load Yeti Cache\"\"\"\n\n    product_types = {\"yeticacheUE\"}\n    label = \"Import Yeti\"\n    representations = {\"abc\"}\n    icon = \"pagelines\"\n    color = \"orange\"\n\n    loaded_asset_dir = \"{folder[path]}/{product[name]}_{version[version]}\"\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(YetiLoader, cls).apply_settings(project_settings)\n        # Apply import settings\n        cls.loaded_asset_dir = (\n            project_settings[\"unreal\"]\n                            [\"import_settings\"]\n                            [\"loaded_asset_dir\"]\n        )\n\n    @staticmethod\n    def get_task(filename, asset_dir, asset_name, replace):\n        task = unreal.AssetImportTask()\n        options = unreal.AbcImportSettings()\n\n        task.set_editor_property('filename', filename)\n        task.set_editor_property('destination_path', asset_dir)\n        task.set_editor_property('destination_name', asset_name)\n        task.set_editor_property('replace_existing', replace)\n        task.set_editor_property('automated', True)\n        task.set_editor_property('save', True)\n\n        task.options = options\n\n        return task\n\n    @staticmethod\n    def is_groom_module_active():\n        \"\"\"\n        Check if Groom plugin is active.\n\n        This is a workaround, because the Unreal python API don't have\n        any method to check if plugin is active.\n        \"\"\"\n        prj_file = unreal.Paths.get_project_file_path()\n\n        with open(prj_file, \"r\") as fp:\n            data = json.load(fp)\n\n        plugins = data.get(\"Plugins\")\n\n        if not plugins:\n            return False\n\n        plugin_names = [p.get(\"Name\") for p in plugins]\n\n        return \"HairStrands\" in plugin_names\n\n    def load(self, context, name, namespace, options):\n        \"\"\"Load and containerise representation into Content Browser.\n\n        This is two step process. First, import FBX to temporary path and\n        then call `containerise()` on it - this moves all content to new\n        directory and then it will create AssetContainer there and imprint it\n        with metadata. This will mark this path as container.\n\n        Args:\n            context (dict): application context\n            name (str): Product name\n            namespace (str): in Unreal this is basically path to container.\n                             This is not passed here, so namespace is set\n                             by `containerise()` because only then we know\n                             real path.\n            data (dict): Those would be data to be imprinted. This is not used\n                         now, data are imprinted by `containerise()`.\n\n        Returns:\n            list(str): list of container content\n\n        \"\"\"\n        # Check if Groom plugin is active\n        if not self.is_groom_module_active():\n            raise RuntimeError(\"Groom plugin is not activated.\")\n\n        # Create directory for asset and Ayon container\n        folder_path = context[\"folder\"][\"path\"]\n        suffix = \"_CON\"\n        path = self.filepath_from_context(context)\n        ext = os.path.splitext(path)[-1].lstrip(\".\")\n        asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n\n        tools = unreal.AssetToolsHelpers().get_asset_tools()\n        asset_dir, container_name = tools.create_unique_asset_name(\n            asset_root, suffix=f\"_{ext}\")\n\n        container_name = f\"{container_name}_{suffix}\"\n        asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n            asset_name, asset_dir, name)\n        if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n            unreal.EditorAssetLibrary.make_directory(asset_dir)\n        task = None\n        if asset_path:\n            loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n            task = self.get_task(path, loaded_asset_dir, asset_name, True)\n        else:\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                f\"{asset_dir}/{asset_name}\"):\n                    task = self.get_task(path, asset_dir, asset_name, False)\n\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])  # noqa: E501\n\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{container_name}\"):\n                # Create Asset Container\n                unreal_pipeline.create_container(\n                    container=container_name, path=asset_dir)\n\n        data = {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"namespace\": asset_dir,\n            \"container_name\": container_name,\n            \"folder_path\": folder_path,\n            \"asset_name\": asset_name,\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"product_type\": context[\"product\"][\"productType\"],\n            # TODO these shold be probably removed\n            \"asset\": folder_path,\n            \"family\": context[\"product\"][\"productType\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        }\n\n        if asset_path:\n            unreal.EditorAssetLibrary.rename_asset(\n                f\"{asset_path}\",\n                f\"{asset_dir}/{asset_name}.{asset_name}\"\n            )\n        unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            asset_dir, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n        return asset_content\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        name = container[\"asset_name\"]\n        source_path = get_representation_path(repre_entity)\n        destination_path = container[\"namespace\"]\n\n        task = self.get_task(source_path, destination_path, name, False)\n\n        # do import fbx and replace existing data\n        unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])\n\n        container_path = f'{container[\"namespace\"]}/{container[\"objectName\"]}'\n        # update metadata\n        unreal_pipeline.imprint(\n            container_path,\n            {\n                \"representation\": repre_entity[\"id\"],\n                \"parent\": repre_entity[\"versionId\"],\n                \"project_name\": context[\"project\"][\"name\"]\n            }\n        )\n\n        asset_content = unreal.EditorAssetLibrary.list_assets(\n            destination_path, recursive=True, include_folder=True\n        )\n\n        for a in asset_content:\n            unreal.EditorAssetLibrary.save_asset(a)\n\n    def remove(self, container):\n        path = container[\"namespace\"]\n        if unreal.EditorAssetLibrary.does_directory_exist(path):\n            unreal.EditorAssetLibrary.delete_directory(path)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_yeticache.html#client.ayon_unreal.plugins.load.load_yeticache.YetiLoader.is_groom_module_active","title":"<code>is_groom_module_active()</code>  <code>staticmethod</code>","text":"<p>Check if Groom plugin is active.</p> <p>This is a workaround, because the Unreal python API don't have any method to check if plugin is active.</p> Source code in <code>client/ayon_unreal/plugins/load/load_yeticache.py</code> <pre><code>@staticmethod\ndef is_groom_module_active():\n    \"\"\"\n    Check if Groom plugin is active.\n\n    This is a workaround, because the Unreal python API don't have\n    any method to check if plugin is active.\n    \"\"\"\n    prj_file = unreal.Paths.get_project_file_path()\n\n    with open(prj_file, \"r\") as fp:\n        data = json.load(fp)\n\n    plugins = data.get(\"Plugins\")\n\n    if not plugins:\n        return False\n\n    plugin_names = [p.get(\"Name\") for p in plugins]\n\n    return \"HairStrands\" in plugin_names\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/load/load_yeticache.html#client.ayon_unreal.plugins.load.load_yeticache.YetiLoader.load","title":"<code>load(context, name, namespace, options)</code>","text":"<p>Load and containerise representation into Content Browser.</p> <p>This is two step process. First, import FBX to temporary path and then call <code>containerise()</code> on it - this moves all content to new directory and then it will create AssetContainer there and imprint it with metadata. This will mark this path as container.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>application context</p> required <code>name</code> <code>str</code> <p>Product name</p> required <code>namespace</code> <code>str</code> <p>in Unreal this is basically path to container.              This is not passed here, so namespace is set              by <code>containerise()</code> because only then we know              real path.</p> required <code>data</code> <code>dict</code> <p>Those would be data to be imprinted. This is not used          now, data are imprinted by <code>containerise()</code>.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>str</code> <p>list of container content</p> Source code in <code>client/ayon_unreal/plugins/load/load_yeticache.py</code> <pre><code>def load(self, context, name, namespace, options):\n    \"\"\"Load and containerise representation into Content Browser.\n\n    This is two step process. First, import FBX to temporary path and\n    then call `containerise()` on it - this moves all content to new\n    directory and then it will create AssetContainer there and imprint it\n    with metadata. This will mark this path as container.\n\n    Args:\n        context (dict): application context\n        name (str): Product name\n        namespace (str): in Unreal this is basically path to container.\n                         This is not passed here, so namespace is set\n                         by `containerise()` because only then we know\n                         real path.\n        data (dict): Those would be data to be imprinted. This is not used\n                     now, data are imprinted by `containerise()`.\n\n    Returns:\n        list(str): list of container content\n\n    \"\"\"\n    # Check if Groom plugin is active\n    if not self.is_groom_module_active():\n        raise RuntimeError(\"Groom plugin is not activated.\")\n\n    # Create directory for asset and Ayon container\n    folder_path = context[\"folder\"][\"path\"]\n    suffix = \"_CON\"\n    path = self.filepath_from_context(context)\n    ext = os.path.splitext(path)[-1].lstrip(\".\")\n    asset_root, asset_name = unreal_pipeline.format_asset_directory(context, self.loaded_asset_dir)\n\n    tools = unreal.AssetToolsHelpers().get_asset_tools()\n    asset_dir, container_name = tools.create_unique_asset_name(\n        asset_root, suffix=f\"_{ext}\")\n\n    container_name = f\"{container_name}_{suffix}\"\n    asset_path = unreal_pipeline.has_asset_directory_pattern_matched(\n        asset_name, asset_dir, name)\n    if not unreal.EditorAssetLibrary.does_directory_exist(asset_dir):\n        unreal.EditorAssetLibrary.make_directory(asset_dir)\n    task = None\n    if asset_path:\n        loaded_asset_dir = unreal.Paths.split(asset_path)[0]\n        task = self.get_task(path, loaded_asset_dir, asset_name, True)\n    else:\n        if not unreal.EditorAssetLibrary.does_asset_exist(\n            f\"{asset_dir}/{asset_name}\"):\n                task = self.get_task(path, asset_dir, asset_name, False)\n\n    unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks([task])  # noqa: E501\n\n    if not unreal.EditorAssetLibrary.does_asset_exist(\n        f\"{asset_dir}/{container_name}\"):\n            # Create Asset Container\n            unreal_pipeline.create_container(\n                container=container_name, path=asset_dir)\n\n    data = {\n        \"schema\": \"ayon:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"namespace\": asset_dir,\n        \"container_name\": container_name,\n        \"folder_path\": folder_path,\n        \"asset_name\": asset_name,\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"product_type\": context[\"product\"][\"productType\"],\n        # TODO these shold be probably removed\n        \"asset\": folder_path,\n        \"family\": context[\"product\"][\"productType\"],\n        \"project_name\": context[\"project\"][\"name\"]\n    }\n\n    if asset_path:\n        unreal.EditorAssetLibrary.rename_asset(\n            f\"{asset_path}\",\n            f\"{asset_dir}/{asset_name}.{asset_name}\"\n        )\n    unreal_pipeline.imprint(f\"{asset_dir}/{container_name}\", data)\n\n    asset_content = unreal.EditorAssetLibrary.list_assets(\n        asset_dir, recursive=True, include_folder=True\n    )\n\n    for a in asset_content:\n        unreal.EditorAssetLibrary.save_asset(a)\n\n    return asset_content\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_current_file.html","title":"collect_current_file","text":"<p>Collect current project path.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_current_file.html#client.ayon_unreal.plugins.publish.collect_current_file.CollectUnrealCurrentFile","title":"<code>CollectUnrealCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context.</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_current_file.py</code> <pre><code>class CollectUnrealCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Unreal Current File\"\n    hosts = ['unreal']\n\n    def process(self, context):\n        \"\"\"Inject the current working file.\"\"\"\n        current_file = unreal.Paths.get_project_file_path()\n        context.data[\"currentFile\"] = os.path.abspath(current_file)\n\n        assert current_file != '', \"Current file is empty. \" \\\n            \"Save the file before continuing.\"\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_current_file.html#client.ayon_unreal.plugins.publish.collect_current_file.CollectUnrealCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file.\"\"\"\n    current_file = unreal.Paths.get_project_file_path()\n    context.data[\"currentFile\"] = os.path.abspath(current_file)\n\n    assert current_file != '', \"Current file is empty. \" \\\n        \"Save the file before continuing.\"\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_frame_range.html","title":"collect_frame_range","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_frame_range.html#client.ayon_unreal.plugins.publish.collect_frame_range.CollectFrameRange","title":"<code>CollectFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Frame Range</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_frame_range.py</code> <pre><code>class CollectFrameRange(pyblish.api.InstancePlugin):\n    \"\"\"Collect Frame Range\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Frame Range\"\n    hosts = ['unreal']\n    families = [\"camera\"]\n\n    def process(self, instance):\n        for member in instance.data.get('members'):\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n            data = ar.get_asset_by_object_path(member)\n            is_level_sequence = (\n                data.asset_class_path.asset_name == \"LevelSequence\")\n            if is_level_sequence:\n                sequence = data.get_asset()\n                frameStart, frameEnd = get_frame_range(sequence)\n                instance.data[\"clipIn\"] = frameStart\n                instance.data[\"clipOut\"] = frameEnd\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_instance_members.html","title":"collect_instance_members","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_instance_members.html#client.ayon_unreal.plugins.publish.collect_instance_members.CollectInstanceMembers","title":"<code>CollectInstanceMembers</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect members of instance.</p> <p>This collector will collect the assets for the families that support to have them included as External Data, and will add them to the instance as members.</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_instance_members.py</code> <pre><code>class CollectInstanceMembers(pyblish.api.InstancePlugin):\n    \"\"\"\n    Collect members of instance.\n\n    This collector will collect the assets for the families that support to\n    have them included as External Data, and will add them to the instance\n    as members.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.1\n    hosts = [\"unreal\"]\n    families = [\"camera\", \"look\", \"staticMesh\", \"uasset\"]\n    label = \"Collect Instance Members\"\n\n    def process(self, instance):\n        \"\"\"Collect members of instance.\"\"\"\n        self.log.info(\"Collecting instance members\")\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        inst_path = instance.data.get('instance_path')\n        inst_name = inst_path.split('/')[-1]\n\n        pub_instance = ar.get_asset_by_object_path(\n            f\"{inst_path}.{inst_name}\").get_asset()\n\n        if not pub_instance:\n            self.log.error(f\"{inst_path}.{inst_name}\")\n            raise RuntimeError(f\"Instance {instance} not found.\")\n\n        if not pub_instance.get_editor_property(\"add_external_assets\"):\n            # No external assets in the instance\n            return\n\n        assets = pub_instance.get_editor_property('asset_data_external')\n\n        members = [asset.get_path_name() for asset in assets]\n\n        self.log.debug(f\"Members: {members}\")\n\n        instance.data[\"members\"] = members\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_instance_members.html#client.ayon_unreal.plugins.publish.collect_instance_members.CollectInstanceMembers.process","title":"<code>process(instance)</code>","text":"<p>Collect members of instance.</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_instance_members.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collect members of instance.\"\"\"\n    self.log.info(\"Collecting instance members\")\n\n    ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n    inst_path = instance.data.get('instance_path')\n    inst_name = inst_path.split('/')[-1]\n\n    pub_instance = ar.get_asset_by_object_path(\n        f\"{inst_path}.{inst_name}\").get_asset()\n\n    if not pub_instance:\n        self.log.error(f\"{inst_path}.{inst_name}\")\n        raise RuntimeError(f\"Instance {instance} not found.\")\n\n    if not pub_instance.get_editor_property(\"add_external_assets\"):\n        # No external assets in the instance\n        return\n\n    assets = pub_instance.get_editor_property('asset_data_external')\n\n    members = [asset.get_path_name() for asset in assets]\n\n    self.log.debug(f\"Members: {members}\")\n\n    instance.data[\"members\"] = members\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_remove_marked.html","title":"collect_remove_marked","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_remove_marked.html#client.ayon_unreal.plugins.publish.collect_remove_marked.CollectRemoveMarked","title":"<code>CollectRemoveMarked</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Remove marked data</p> <p>Remove instances that have 'remove' in their instance.data</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_remove_marked.py</code> <pre><code>class CollectRemoveMarked(pyblish.api.ContextPlugin):\n    \"\"\"Remove marked data\n\n    Remove instances that have 'remove' in their instance.data\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499\n    label = 'Remove Marked Instances'\n\n    def process(self, context):\n\n        self.log.debug(context)\n        # make ftrack publishable\n        instances_to_remove = []\n        for instance in context:\n            if instance.data.get('remove'):\n                instances_to_remove.append(instance)\n\n        for instance in instances_to_remove:\n            context.remove(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_render_files.html","title":"collect_render_files","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/collect_render_files.html#client.ayon_unreal.plugins.publish.collect_render_files.CollectRenderFiles","title":"<code>CollectRenderFiles</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>This collector will try to find all the rendered frames.</p> <p>Secondary step after local rendering. Should collect all rendered files and add them as representation.</p> Source code in <code>client/ayon_unreal/plugins/publish/collect_render_files.py</code> <pre><code>class CollectRenderFiles(pyblish.api.InstancePlugin):\n    \"\"\" This collector will try to find all the rendered frames.\n\n    Secondary step after local rendering. Should collect all rendered files and\n    add them as representation.\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.001\n    families = [\"render.local\"]\n    label = \"Collect Render Files\"\n\n    def process(self, instance):\n        self.log.debug(\"Collecting rendered files\")\n        context = instance.context\n\n        data = instance.data\n        data['remove'] = True\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        sequence = ar.get_asset_by_object_path(\n            data.get('sequence')).get_asset()\n\n        sequences = [{\n            \"sequence\": sequence,\n            \"output\": data.get('output'),\n            \"frame_range\": (\n                data.get('frameStart'), data.get('frameEnd'))\n        }]\n\n        for s in sequences:\n            self.log.debug(f\"Processing: {s.get('sequence').get_name()}\")\n            subscenes = pipeline.get_subsequences(s.get('sequence'))\n\n            if subscenes:\n                for ss in subscenes:\n                    sequences.append({\n                        \"sequence\": ss.get_sequence(),\n                        \"output\": (f\"{s.get('output')}/\"\n                                   f\"{ss.get_sequence().get_name()}\"),\n                        \"frame_range\": (\n                            ss.get_start_frame(), ss.get_end_frame() - 1)\n                    })\n            else:\n                # Avoid creating instances for camera sequences\n                if \"_camera\" in s.get('sequence').get_name():\n                    continue\n                seq = s.get('sequence')\n                seq_name = seq.get_name()\n\n                product_type = \"render\"\n                new_product_name = f\"{data.get('productName')}_{seq_name}\"\n                new_instance = context.create_instance(\n                    new_product_name\n                )\n                new_instance[:] = seq_name\n\n                new_data = new_instance.data\n\n                new_data[\"folderPath\"] = instance.data[\"folderPath\"]\n                new_data[\"setMembers\"] = seq_name\n                new_data[\"productName\"] = new_product_name\n                new_data[\"productType\"] = product_type\n                new_data[\"family\"] = product_type\n                new_data[\"families\"] = [product_type, \"review\"]\n                new_data[\"parent\"] = data.get(\"parent\")\n                new_data[\"level\"] = data.get(\"level\")\n                new_data[\"output\"] = s['output']\n                new_data[\"fps\"] = seq.get_display_rate().numerator\n                new_data[\"frameStart\"] = int(s.get('frame_range')[0])\n                new_data[\"frameEnd\"] = int(s.get('frame_range')[1])\n                new_data[\"sequence\"] = seq.get_path_name()\n                new_data[\"master_sequence\"] = data[\"master_sequence\"]\n                new_data[\"master_level\"] = data[\"master_level\"]\n\n                self.log.debug(f\"new instance data: {new_data}\")\n\n                try:\n                    project = get_current_project_name()\n                    anatomy = Anatomy(project)\n                    root = anatomy.roots['renders']\n                except Exception as e:\n                    raise Exception((\n                        \"Could not find render root \"\n                        \"in anatomy settings.\")) from e\n\n                render_dir = f\"{root}/{project}/{s.get('output')}\"\n                render_path = Path(render_dir)\n                if not os.path.exists(render_path):\n                    msg = (\n                        f\"Render directory {render_path} not found.\"\n                        \" Please render with the render instance\"\n                    )\n                    self.log.error(msg)\n                    raise PublishError(msg, title=\"Render directory not found.\")\n\n                self.log.debug(f\"Collecting render path: {render_path}\")\n                frames = [str(x) for x in render_path.iterdir() if x.is_file()]\n                frames = pipeline.get_sequence(frames)\n                image_format = next((os.path.splitext(x)[-1].lstrip(\".\")\n                                     for x in frames), \"exr\")\n\n                if \"representations\" not in new_instance.data:\n                    new_instance.data[\"representations\"] = []\n\n                repr = {\n                    'frameStart': instance.data[\"frameStart\"],\n                    'frameEnd': instance.data[\"frameEnd\"],\n                    'name': image_format,\n                    'ext': image_format,\n                    'files': frames,\n                    'stagingDir': render_dir,\n                    'tags': ['review']\n                }\n                new_instance.data[\"representations\"].append(repr)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/create_farm_render_instances.html","title":"create_farm_render_instances","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/create_farm_render_instances.html#client.ayon_unreal.plugins.publish.create_farm_render_instances.CreateFarmRenderInstances","title":"<code>CreateFarmRenderInstances</code>","text":"<p>               Bases: <code>AbstractCollectRender</code></p> Source code in <code>client/ayon_unreal/plugins/publish/create_farm_render_instances.py</code> <pre><code>class CreateFarmRenderInstances(publish.AbstractCollectRender):\n\n    order = pyblish.api.CollectorOrder + 0.21\n    label = \"Create Farm Render Instances\"\n    families = [\"render\"]\n\n    def preparing_rendering_instance(self, instance):\n        context = instance.context\n\n        data = instance.data\n        data[\"remove\"] = True\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        sequence = ar.get_asset_by_object_path(\n            data.get(\"sequence\")).get_asset()\n\n        sequences = [{\n            \"sequence\": sequence,\n            \"output\": data.get(\"output\"),\n            \"frame_range\": (\n                data.get(\"frameStart\"), data.get(\"frameEnd\"))\n        }]\n\n        for s in sequences:\n            self.log.debug(f\"Processing: {s.get('sequence').get_name()}\")\n            subscenes = pipeline.get_subsequences(s.get('sequence'))\n\n            if subscenes:\n                for ss in subscenes:\n                    sequences.append({\n                        \"sequence\": ss.get_sequence(),\n                        \"output\": (f\"{s.get('output')}/\"\n                                   f\"{ss.get_sequence().get_name()}\"),\n                        \"frame_range\": (\n                            ss.get_start_frame(), ss.get_end_frame() - 1)\n                    })\n            else:\n                # Avoid creating instances for camera sequences\n                if \"_camera\" not in s.get('sequence').get_name():\n                    seq = s.get('sequence')\n                    seq_name = seq.get_name()\n\n                    product_type = \"render\"\n                    new_product_name = f\"{data.get('productName')}_{seq_name}\"\n                    new_instance = context.create_instance(\n                        new_product_name\n                    )\n                    new_instance[:] = seq_name\n\n                    new_data = new_instance.data\n\n                    new_data[\"folderPath\"] = instance.data[\"folderPath\"]\n                    new_data[\"setMembers\"] = seq_name\n                    new_data[\"productName\"] = new_product_name\n                    new_data[\"productType\"] = product_type\n                    new_data[\"family\"] = product_type\n                    new_data[\"families\"] = [product_type, \"review\"]\n                    new_data[\"parent\"] = data.get(\"parent\")\n                    new_data[\"level\"] = data.get(\"level\")\n                    new_data[\"output\"] = s['output']\n                    new_data[\"fps\"] = seq.get_display_rate().numerator\n                    new_data[\"frameStart\"] = int(s.get('frame_range')[0])\n                    new_data[\"frameEnd\"] = int(s.get('frame_range')[1])\n                    new_data[\"sequence\"] = seq.get_path_name()\n                    new_data[\"master_sequence\"] = data[\"master_sequence\"]\n                    new_data[\"master_level\"] = data[\"master_level\"]\n                    new_data[\"review\"] = instance.data.get(\"review\", False)\n                    new_data[\"farm\"] = instance.data.get(\"farm\", False)\n\n                    self.log.debug(f\"new instance data: {new_data}\")\n\n    def get_instances(self, context):\n        instances = []\n        instances_to_remove = []\n\n        current_file = context.data[\"currentFile\"]\n        version = 1  # TODO where to get this without change list\n\n        project_name = context.data[\"projectName\"]\n        project_settings = context.data['project_settings']\n        render_settings = project_settings[\"unreal\"][\"render_setup\"]\n        config_path, config = get_render_config(project_name, render_settings)\n        if not config:\n            raise RuntimeError(\"Please provide stored render config at path \"\n                \"set in `ayon+settings://unreal/render_setup/render_config_path`\")\n\n        output_ext_from_settings = render_settings[\"render_format\"]\n        config = set_output_extension_from_settings(output_ext_from_settings,\n                                                    config)\n\n        ext = self._get_ext_from_config(config)\n        if not ext:\n            raise RuntimeError(\"Please provide output extension in config!\")\n\n        output_settings = config.find_or_add_setting_by_class(\n            unreal.MoviePipelineOutputSetting)\n\n        resolution = output_settings.output_resolution\n        resolution_width = resolution.x\n        resolution_height = resolution.y\n\n        output_fps = output_settings.output_frame_rate\n        fps = f\"{output_fps.denominator}.{output_fps.numerator}\"\n\n        for inst in context:\n            instance_families = inst.data.get(\"families\", [])\n            product_name = inst.data[\"productName\"]\n\n            if not inst.data.get(\"active\", True):\n                continue\n\n            family = inst.data[\"family\"]\n            if family not in [\"render\"]:\n                continue\n\n            # skip if local render instances\n            if \"render.local\" in instance_families:\n                continue\n\n            if not inst.data.get(\"farm\", False):\n                self.log.info(\"Skipping local render instance\")\n                continue\n\n            render_queue_path = render_settings[\"render_queue_path\"]\n            if not unreal.EditorAssetLibrary.does_asset_exist(\n                    render_queue_path):\n                # TODO: temporary until C++ blueprint is created as it is not\n                #   possible to create renderQueue. Also, we could\n                #   use Render Graph from UE 5.4\n\n                master_level = inst.data[\"master_level\"]\n                sequence = inst.data[\"sequence\"]\n                msg = (f\"Please create `Movie Pipeline Queue` \"\n                       f\"at `{render_queue_path}`. \"\n                       f\"Set it Sequence to `{sequence}`, \"\n                       f\"Map to `{master_level}` and \"\n                       f\"Settings to `{config_path}` \")\n                raise PublishError(msg)\n\n            # Get current jobs\n            jobs = unreal.EditorAssetLibrary.load_asset(\n                render_settings[\"render_queue_path\"]\n            ).get_jobs()\n\n            # backward compatibility\n            task_name = inst.data.get(\"task\") or inst.data.get(\"task_name\")\n            self.log.debug(f\"Task name:{task_name}\")\n\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n            sequence = (ar.get_asset_by_object_path(inst.data[\"sequence\"]).\n                        get_asset())\n            if not sequence:\n                raise PublishError(f\"Cannot find {inst.data['sequence']}\")\n\n            # Get current job\n            job = next(\n                (\n                    job\n                    for job in jobs\n                    if job.sequence.export_text() == inst.data[\"sequence\"]\n                ),\n                None,\n            )\n            if not job:\n                raise PublishError(\n                    f\"Cannot find job with sequence {inst.data['sequence']}\"\n                )\n\n            # current frame range - might be different from created\n            frame_start = sequence.get_playback_start()\n            # in Unreal 1 of 60 &gt;&gt; 0-59\n            frame_end = sequence.get_playback_end() - 1\n\n            inst.data[\"frameStart\"] = frame_start\n            inst.data[\"frameEnd\"] = frame_end\n\n            frame_placeholder = \"#\" * output_settings.zero_pad_frame_numbers\n            version = (\n                version\n                if output_settings.auto_version\n                else output_settings.version_number\n            )\n\n            exp_file_name = self._get_expected_file_name(\n                output_settings.file_name_format,\n                ext,\n                frame_placeholder,\n                job,\n                version,\n            )\n\n            publish_attributes = {}\n\n            try:\n                review = bool(inst.data[\"creator_attributes\"].get(\"review\"))\n            except KeyError:\n                review = inst.data.get(\"review\", False)\n\n            new_instance = UnrealRenderInstance(\n                family=\"render\",\n                families=[\"render.farm\"],\n                version=version,\n                time=\"\",\n                source=current_file,\n                label=f\"{product_name} - {family}\",\n                productName=product_name,\n                productType=\"render\",\n                folderPath=inst.data[\"folderPath\"],\n                task=task_name,\n                attachTo=False,\n                setMembers='',\n                publish=True,\n                name=product_name,\n                resolutionWidth=resolution_width,\n                resolutionHeight=resolution_height,\n                pixelAspect=1,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                review=review,\n                frameStart=frame_start,\n                frameEnd=frame_end,\n                frameStep=1,\n                fps=fps,\n                publish_attributes=publish_attributes,\n                file_names=[exp_file_name],\n                app_version=f\"{UNREAL_VERSION.major}.{UNREAL_VERSION.minor}\",\n                output_settings=output_settings,\n                config_path=config_path,\n                master_level=inst.data[\"master_level\"],\n                render_queue_path=render_queue_path,\n                deadline=inst.data.get(\"deadline\"),\n            )\n            new_instance.farm = True\n\n            instances.append(new_instance)\n            instances_to_remove.append(inst)\n\n        for instance in instances_to_remove:\n            self.log.debug(f\"Removing instance: {instance}\")\n            context.remove(instance)\n        return instances\n\n    def _get_expected_file_name(\n        self,\n        file_name_format,\n        ext,\n        frame_placeholder,\n        job: unreal.MoviePipelineExecutorJob,\n        version: int,\n    ):\n        \"\"\"Calculate file name that should be rendered.\"\"\"\n        sequence_path = job.sequence.export_text()\n        map_path = job.map.export_text()\n\n        sequence_name = os.path.splitext(os.path.basename(sequence_path))[0]\n        map_name = os.path.splitext(os.path.basename(map_path))[0]\n\n        file_name_format = file_name_format.replace(\"{sequence_name}\", sequence_name)\n        file_name_format = file_name_format.replace(\"{level_name}\", map_name)\n        file_name_format = file_name_format.replace(\"{job_name}\", job.job_name)\n        file_name_format = file_name_format.replace(\"{version}\", f\"v{version:03d}\")\n        file_name_format = file_name_format.replace(\"{frame_number}\", frame_placeholder)\n        return f\"{file_name_format}.{ext}\"\n\n    def get_expected_files(self, render_instance: UnrealRenderInstance):\n        \"\"\"\n            Returns list of rendered files that should be created by\n            Deadline. These are not published directly, they are source\n            for later 'submit_publish_job'.\n\n        Args:\n            render_instance (UnrealRenderInstance): to pull anatomy and parts used\n                in url\n\n        Returns:\n            (list) of absolute urls to rendered file\n        \"\"\"\n        start = render_instance.frameStart\n        end = render_instance.frameEnd\n\n        base_dir = self._get_output_dir(render_instance)\n        expected_files = []\n        for file_name in render_instance.file_names:\n            if \"#\" in file_name:\n                _spl = file_name.split(\"#\")\n                _len = (len(_spl) - 1)\n                placeholder = \"#\"*_len\n                for frame in range(start, end+1):\n                    new_file_name = file_name.replace(placeholder,\n                                                      str(frame).zfill(_len))\n                    path = os.path.join(base_dir, new_file_name)\n                    expected_files.append(path)\n\n        return expected_files\n\n    def _get_output_dir(self, render_instance):\n        \"\"\"\n            Returns dir path of rendered files, used in submit_publish_job\n            for metadata.json location.\n            Should be in separate folder inside work area.\n\n        Args:\n            render_instance (RenderInstance):\n\n        Returns:\n            (str): absolute path to rendered files\n        \"\"\"\n        # render to folder of project\n        output_dir = render_instance.output_settings.output_directory.path\n        base_dir = os.path.dirname(render_instance.source)\n        output_dir = output_dir.replace(\"{project_dir}\", base_dir)\n\n        return output_dir\n\n    def _get_ext_from_config(self, config):\n        \"\"\"Get set extension in render config.\n\n        Bit weird approach to loop through supported extensions and bail on\n        found.\n        Assumes that there would be only single extension!\n\n        Arg:\n            config (unreal.MoviePipelineMasterConfig): render config\n        \"\"\"\n        for ext, cls in SUPPORTED_EXTENSION_MAP.items():\n            current_sett = config.find_setting_by_class(cls)\n            if current_sett:\n                return ext\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/create_farm_render_instances.html#client.ayon_unreal.plugins.publish.create_farm_render_instances.CreateFarmRenderInstances.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<pre><code>Returns list of rendered files that should be created by\nDeadline. These are not published directly, they are source\nfor later 'submit_publish_job'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>render_instance</code> <code>UnrealRenderInstance</code> <p>to pull anatomy and parts used in url</p> required <p>Returns:</p> Type Description <p>(list) of absolute urls to rendered file</p> Source code in <code>client/ayon_unreal/plugins/publish/create_farm_render_instances.py</code> <pre><code>def get_expected_files(self, render_instance: UnrealRenderInstance):\n    \"\"\"\n        Returns list of rendered files that should be created by\n        Deadline. These are not published directly, they are source\n        for later 'submit_publish_job'.\n\n    Args:\n        render_instance (UnrealRenderInstance): to pull anatomy and parts used\n            in url\n\n    Returns:\n        (list) of absolute urls to rendered file\n    \"\"\"\n    start = render_instance.frameStart\n    end = render_instance.frameEnd\n\n    base_dir = self._get_output_dir(render_instance)\n    expected_files = []\n    for file_name in render_instance.file_names:\n        if \"#\" in file_name:\n            _spl = file_name.split(\"#\")\n            _len = (len(_spl) - 1)\n            placeholder = \"#\"*_len\n            for frame in range(start, end+1):\n                new_file_name = file_name.replace(placeholder,\n                                                  str(frame).zfill(_len))\n                path = os.path.join(base_dir, new_file_name)\n                expected_files.append(path)\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_camera.html","title":"extract_camera","text":"<p>Extract camera from Unreal.</p>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_camera.html#client.ayon_unreal.plugins.publish.extract_camera.ExtractCamera","title":"<code>ExtractCamera</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract a camera.</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_camera.py</code> <pre><code>class ExtractCamera(publish.Extractor):\n    \"\"\"Extract a camera.\"\"\"\n\n    label = \"Extract Camera\"\n    hosts = [\"unreal\"]\n    families = [\"camera\"]\n    optional = True\n\n    def process(self, instance):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        # Define extract output file path\n        staging_dir = self.staging_dir(instance)\n        fbx_filename = \"{}.fbx\".format(instance.name)\n\n        # Perform extraction\n        self.log.info(\"Performing extraction..\")\n        # Check if the loaded level is the same of the instance\n        if UNREAL_VERSION.major == 5:\n            world = unreal.UnrealEditorSubsystem().get_editor_world()\n        else:\n            world = unreal.EditorLevelLibrary.get_editor_world()\n        current_level = world.get_path_name()\n        assert current_level == instance.data.get(\"level\"), \\\n            \"Wrong level loaded\"\n\n        for member in instance.data.get('members'):\n            data = ar.get_asset_by_object_path(member)\n            if UNREAL_VERSION.major == 5:\n                is_level_sequence = (\n                    data.asset_class_path.asset_name == \"LevelSequence\")\n            else:\n                is_level_sequence = (data.asset_class == \"LevelSequence\")\n\n            if is_level_sequence:\n                sequence = data.get_asset()\n                with select_camera(sequence):\n                    if UNREAL_VERSION.major == 5:\n                        params = None\n                        if UNREAL_VERSION.minor &gt;= 4:\n                            params = unreal.SequencerExportFBXParams(\n                                world=world,\n                                root_sequence=sequence,\n                                sequence=sequence,\n                                bindings=sequence.get_bindings(),\n                                fbx_file_name=os.path.join(staging_dir, fbx_filename)\n                            )\n                        else:\n                            params = unreal.SequencerExportFBXParams(\n                                world=world,\n                                root_sequence=sequence,\n                                sequence=sequence,\n                                bindings=sequence.get_bindings(),\n                                master_tracks=get_tracks(sequence),\n                                fbx_file_name=os.path.join(staging_dir, fbx_filename)\n                            )\n                        unreal.SequencerTools.export_level_sequence_fbx(params)\n                    elif UNREAL_VERSION.major == 4 and UNREAL_VERSION.minor == 26:\n                        unreal.SequencerTools.export_fbx(\n                            world,\n                            sequence,\n                            sequence.get_bindings(),\n                            unreal.FbxExportOption(),\n                            os.path.join(staging_dir, fbx_filename)\n                        )\n                    else:\n                        # Unreal 5.0 or 4.27\n                        unreal.SequencerTools.export_level_sequence_fbx(\n                            world,\n                            sequence,\n                            sequence.get_bindings(),\n                            unreal.FbxExportOption(),\n                            os.path.join(staging_dir, fbx_filename)\n                        )\n\n                    if not os.path.isfile(os.path.join(staging_dir, fbx_filename)):\n                        raise RuntimeError(\"Failed to extract camera\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        fbx_representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': fbx_filename,\n            'clipIn': instance.data[\"clipIn\"],\n            'clipOut': instance.data[\"clipOut\"],\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(fbx_representation)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_fbx.html","title":"extract_fbx","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_fbx.html#client.ayon_unreal.plugins.publish.extract_fbx.ExtractFbx","title":"<code>ExtractFbx</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract Fbx.</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractFbx(publish.Extractor):\n    \"\"\"Extract Fbx.\"\"\"\n\n    label = \"Extract Fbx (Static Mesh)\"\n    hosts = [\"unreal\"]\n    families = [\"staticMesh\"]\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        # TODO: select the asset during context\n        fbx_exporter = unreal.StaticMeshExporterFBX()\n        fbx_exporter.set_editor_property('text', False)\n\n        options = unreal.FbxExportOption()\n        options.set_editor_property('ascii', False)\n        options.set_editor_property('collision', False)\n        fbx_filename = f\"{instance.name}.fbx\"\n\n        task = unreal.AssetExportTask()\n        task.exporter = fbx_exporter\n        task.options = options\n        members = set(instance.data.get(\"members\", []))\n        asset_registry = unreal.AssetRegistryHelpers.get_asset_registry()\n        for member in members:\n            task.object = asset_registry.get_asset_by_object_path(member).get_asset()\n            task.automated = True\n            task.filename = os.path.join(staging_dir, fbx_filename).replace(\"\\\\\", \"/\")\n            task.selected = False\n            task.use_file_archive = False\n            task.write_empty_files = False\n\n            unreal.Exporter.run_asset_export_task(task)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': fbx_filename,\n            \"stagingDir\": staging_dir,\n        }\n\n        instance.data[\"representations\"].append(representation)\n        self.log.debug(f\"{staging_dir}/{fbx_filename}\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_layout.html","title":"extract_layout","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_layout.html#client.ayon_unreal.plugins.publish.extract_layout.ExtractLayout","title":"<code>ExtractLayout</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract a layout.</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_layout.py</code> <pre><code>class ExtractLayout(publish.Extractor):\n    \"\"\"Extract a layout.\"\"\"\n\n    label = \"Extract Layout\"\n    hosts = [\"unreal\"]\n    families = [\"layout\"]\n    optional = True\n\n    def process(self, instance):\n        # Define extract output file path\n        staging_dir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.info(\"Performing extraction..\")\n\n        # Check if the loaded level is the same of the instance\n        current_level = ell.get_editor_world().get_path_name()\n        assert current_level == instance.data.get(\"level\"), \\\n            \"Wrong level loaded\"\n\n        json_data = []\n        project_name = instance.context.data[\"projectName\"]\n        eas = unreal.EditorActorSubsystem()\n        sel_actors = eas.get_all_level_actors()\n        members = set(instance.data.get(\"members\", []))\n        actors = [a for a in sel_actors if a.get_path_name() in members]\n        for actor in actors:\n            mesh = None\n            # Check type the type of mesh\n            if actor.get_class().get_name() == 'SkeletalMeshActor':\n                mesh = actor.skeletal_mesh_component.skeletal_mesh\n            elif actor.get_class().get_name() == 'StaticMeshActor':\n                mesh = actor.static_mesh_component.static_mesh\n\n            if mesh:\n                # Search the reference to the Asset Container for the object\n                path = unreal.Paths.get_path(mesh.get_path_name())\n                filter = unreal.ARFilter(\n                    class_names=[\"AyonAssetContainer\"], package_paths=[path])\n                ar = unreal.AssetRegistryHelpers.get_asset_registry()\n                try:\n                    asset_container = ar.get_assets(filter)[0].get_asset()\n                except IndexError:\n                    self.log.error(\"AssetContainer not found.\")\n                    return\n\n                parent_id = eal.get_metadata_tag(asset_container, \"parent\")\n                repre_id = eal.get_metadata_tag(asset_container, \"representation\")\n                family = eal.get_metadata_tag(asset_container, \"family\")\n                json_element = {}\n                json_element[\"reference\"] = str(repre_id)\n                json_element[\"representation\"] = str(repre_id)\n                # TODO: remove the option after tweaking\n                # the layout loader in blender\n                if instance.data.get(\"export_blender\", False):\n                    blend = ayon_api.get_representation_by_name(\n                        project_name, \"blend\", parent_id, fields={\"id\"}\n                    )\n                    blend_id = blend[\"id\"]\n                    json_element[\"reference\"] = str(blend_id)\n                instance_name = mesh.get_name()\n                extension = instance_name.split(\"_\")[-1]\n                asset_name = re.match(f'(.+)_{extension}$', instance_name)\n                json_element[\"version\"] = str(parent_id)\n                json_element[\"product_type\"] = family\n                json_element[\"instance_name\"] = asset_name.group(1)\n                json_element[\"asset_name\"] = instance_name\n                json_element[\"extension\"] = extension\n                transform = actor.get_actor_transform()\n                json_element[\"host\"] = self.hosts\n                json_element[\"transform\"] = {\n                    \"translation\": {\n                        \"x\": transform.translation.x,\n                        \"y\": transform.translation.y,\n                        \"z\": transform.translation.z\n                    },\n                    \"rotation\": {\n                        \"x\": math.radians(transform.rotation.euler().x),\n                        \"y\": math.radians(transform.rotation.euler().y),\n                        \"z\": math.radians(transform.rotation.euler().z)\n                    },\n                    \"scale\": {\n                        \"x\": transform.scale3d.x,\n                        \"y\": transform.scale3d.y,\n                        \"z\": transform.scale3d.z\n                    }\n                }\n                json_element[\"transform_matrix\"] = self.get_transform_matrix(transform)\n                json_element[\"basis\"] = self.get_basis_matrix()\n                json_element[\"rotation\"] = {\n                    \"x\": transform.rotation.euler().x,\n                    \"y\": transform.rotation.euler().y,\n                    \"z\": transform.rotation.euler().z\n                }\n                json_data.append(json_element)\n\n        json_filename = \"{}.json\".format(instance.name)\n        json_path = os.path.join(staging_dir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_data, fp=file, indent=2)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(json_representation)\n\n    def get_basis_matrix(self):\n        \"\"\"Get Identity matrix\n\n        Returns:\n            list: list of identity matrix\n        \"\"\"\n        # Create an identity matrix\n        identity_matrix = unreal.Matrix.IDENTITY\n\n        basis_list = [\n            [identity_matrix.x_plane.x, identity_matrix.x_plane.y,\n            identity_matrix.x_plane.z, identity_matrix.x_plane.w],\n            [identity_matrix.y_plane.x, identity_matrix.y_plane.y,\n            identity_matrix.y_plane.z, identity_matrix.y_plane.w],\n            [identity_matrix.z_plane.x, identity_matrix.z_plane.y,\n            identity_matrix.z_plane.z, identity_matrix.z_plane.w],\n            [identity_matrix.w_plane.x, identity_matrix.w_plane.y,\n            identity_matrix.w_plane.z, identity_matrix.w_plane.w]\n        ]\n        return basis_list\n\n    def get_transform_matrix(self, transform):\n        \"\"\"Get transform matrix for each actor\n\n        Args:\n            transform (Matrix): Actor's transformation\n\n        Returns:\n            list: Actor's transformation data\n        \"\"\"\n        translation = [\n            transform.translation.x,\n            transform.translation.z,\n            transform.translation.y\n        ]\n        rotation = [\n            transform.rotation.euler().x,\n            transform.rotation.euler().z,\n            transform.rotation.euler().y\n        ]\n        scale = [\n            transform.scale3d.x,\n            transform.scale3d.z,\n            transform.scale3d.y,\n        ]\n        transform = unreal.Transform(\n            location=translation,\n            rotation=rotation,\n            scale=scale\n        )\n        transform_m_matrix = transform.to_matrix()\n        transform_matrix = [\n            [transform_m_matrix.x_plane.x, transform_m_matrix.x_plane.y,\n             transform_m_matrix.x_plane.z, transform_m_matrix.x_plane.w],\n            [transform_m_matrix.y_plane.x, transform_m_matrix.y_plane.y,\n             transform_m_matrix.y_plane.z, transform_m_matrix.y_plane.w],\n            [transform_m_matrix.z_plane.x, transform_m_matrix.z_plane.y,\n             transform_m_matrix.z_plane.z, transform_m_matrix.z_plane.w],\n            [transform_m_matrix.w_plane.x, transform_m_matrix.w_plane.y,\n             transform_m_matrix.w_plane.z, transform_m_matrix.w_plane.w]\n        ]\n        return transform_matrix\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_layout.html#client.ayon_unreal.plugins.publish.extract_layout.ExtractLayout.get_basis_matrix","title":"<code>get_basis_matrix()</code>","text":"<p>Get Identity matrix</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of identity matrix</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_layout.py</code> <pre><code>def get_basis_matrix(self):\n    \"\"\"Get Identity matrix\n\n    Returns:\n        list: list of identity matrix\n    \"\"\"\n    # Create an identity matrix\n    identity_matrix = unreal.Matrix.IDENTITY\n\n    basis_list = [\n        [identity_matrix.x_plane.x, identity_matrix.x_plane.y,\n        identity_matrix.x_plane.z, identity_matrix.x_plane.w],\n        [identity_matrix.y_plane.x, identity_matrix.y_plane.y,\n        identity_matrix.y_plane.z, identity_matrix.y_plane.w],\n        [identity_matrix.z_plane.x, identity_matrix.z_plane.y,\n        identity_matrix.z_plane.z, identity_matrix.z_plane.w],\n        [identity_matrix.w_plane.x, identity_matrix.w_plane.y,\n        identity_matrix.w_plane.z, identity_matrix.w_plane.w]\n    ]\n    return basis_list\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_layout.html#client.ayon_unreal.plugins.publish.extract_layout.ExtractLayout.get_transform_matrix","title":"<code>get_transform_matrix(transform)</code>","text":"<p>Get transform matrix for each actor</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>Matrix</code> <p>Actor's transformation</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Actor's transformation data</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_layout.py</code> <pre><code>def get_transform_matrix(self, transform):\n    \"\"\"Get transform matrix for each actor\n\n    Args:\n        transform (Matrix): Actor's transformation\n\n    Returns:\n        list: Actor's transformation data\n    \"\"\"\n    translation = [\n        transform.translation.x,\n        transform.translation.z,\n        transform.translation.y\n    ]\n    rotation = [\n        transform.rotation.euler().x,\n        transform.rotation.euler().z,\n        transform.rotation.euler().y\n    ]\n    scale = [\n        transform.scale3d.x,\n        transform.scale3d.z,\n        transform.scale3d.y,\n    ]\n    transform = unreal.Transform(\n        location=translation,\n        rotation=rotation,\n        scale=scale\n    )\n    transform_m_matrix = transform.to_matrix()\n    transform_matrix = [\n        [transform_m_matrix.x_plane.x, transform_m_matrix.x_plane.y,\n         transform_m_matrix.x_plane.z, transform_m_matrix.x_plane.w],\n        [transform_m_matrix.y_plane.x, transform_m_matrix.y_plane.y,\n         transform_m_matrix.y_plane.z, transform_m_matrix.y_plane.w],\n        [transform_m_matrix.z_plane.x, transform_m_matrix.z_plane.y,\n         transform_m_matrix.z_plane.z, transform_m_matrix.z_plane.w],\n        [transform_m_matrix.w_plane.x, transform_m_matrix.w_plane.y,\n         transform_m_matrix.w_plane.z, transform_m_matrix.w_plane.w]\n    ]\n    return transform_matrix\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_look.html","title":"extract_look","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_look.html#client.ayon_unreal.plugins.publish.extract_look.ExtractLook","title":"<code>ExtractLook</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract look.</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_look.py</code> <pre><code>class ExtractLook(publish.Extractor):\n    \"\"\"Extract look.\"\"\"\n\n    label = \"Extract Look\"\n    hosts = [\"unreal\"]\n    families = [\"look\"]\n    optional = True\n\n    def process(self, instance):\n        # Define extract output file path\n        staging_dir = self.staging_dir(instance)\n        resources_dir = instance.data[\"resourcesDir\"]\n\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        transfers = []\n\n        json_data = []\n\n        for member in instance:\n            asset = ar.get_asset_by_object_path(member)\n            obj = asset.get_asset()\n\n            name = asset.get_editor_property('asset_name')\n\n            json_element = {'material': str(name)}\n\n            material_obj = obj.get_editor_property('static_materials')[0]\n            material = material_obj.material_interface\n\n            base_color = mat_lib.get_material_property_input_node(\n                material, unreal.MaterialProperty.MP_BASE_COLOR)\n\n            base_color_name = base_color.get_editor_property('parameter_name')\n\n            texture = mat_lib.get_material_default_texture_parameter_value(\n                material, base_color_name)\n\n            if texture:\n                # Export Texture\n                tga_filename = f\"{instance.name}_{name}_texture.tga\"\n\n                tga_exporter = unreal.TextureExporterTGA()\n\n                tga_export_task = unreal.AssetExportTask()\n\n                tga_export_task.set_editor_property('exporter', tga_exporter)\n                tga_export_task.set_editor_property('automated', True)\n                tga_export_task.set_editor_property('object', texture)\n                tga_export_task.set_editor_property(\n                    'filename', f\"{staging_dir}/{tga_filename}\")\n                tga_export_task.set_editor_property('prompt', False)\n                tga_export_task.set_editor_property('selected', False)\n\n                unreal.Exporter.run_asset_export_task(tga_export_task)\n\n                json_element['tga_filename'] = tga_filename\n\n                transfers.append((\n                    f\"{staging_dir}/{tga_filename}\",\n                    f\"{resources_dir}/{tga_filename}\"))\n\n            fbx_filename = f\"{instance.name}_{name}.fbx\"\n\n            fbx_exporter = unreal.StaticMeshExporterFBX()\n            fbx_exporter.set_editor_property('text', False)\n\n            options = unreal.FbxExportOption()\n            options.set_editor_property('ascii', False)\n            options.set_editor_property('collision', False)\n\n            task = unreal.AssetExportTask()\n            task.set_editor_property('exporter', fbx_exporter)\n            task.set_editor_property('options', options)\n            task.set_editor_property('automated', True)\n            task.set_editor_property('object', object)\n            task.set_editor_property(\n                'filename', f\"{staging_dir}/{fbx_filename}\")\n            task.set_editor_property('prompt', False)\n            task.set_editor_property('selected', False)\n\n            unreal.Exporter.run_asset_export_task(task)\n\n            json_element['fbx_filename'] = fbx_filename\n\n            transfers.append((\n                f\"{staging_dir}/{fbx_filename}\",\n                f\"{resources_dir}/{fbx_filename}\"))\n\n            json_data.append(json_element)\n\n        json_filename = f\"{instance.name}.json\"\n        json_path = os.path.join(staging_dir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_data, fp=file, indent=2)\n\n        if \"transfers\" not in instance.data:\n            instance.data[\"transfers\"] = []\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": staging_dir,\n        }\n\n        instance.data[\"representations\"].append(json_representation)\n        instance.data[\"transfers\"].extend(transfers)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_uasset.html","title":"extract_uasset","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/extract_uasset.html#client.ayon_unreal.plugins.publish.extract_uasset.ExtractUAsset","title":"<code>ExtractUAsset</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract a UAsset.</p> Source code in <code>client/ayon_unreal/plugins/publish/extract_uasset.py</code> <pre><code>class ExtractUAsset(publish.Extractor):\n    \"\"\"Extract a UAsset.\"\"\"\n\n    label = \"Extract UAsset\"\n    hosts = [\"unreal\"]\n    families = [\"uasset\", \"umap\"]\n    optional = True\n\n    def process(self, instance):\n        extension = (\n            \"umap\" if \"umap\" in instance.data.get(\"families\") else \"uasset\")\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n\n        self.log.debug(\"Performing extraction..\")\n        staging_dir = self.staging_dir(instance)\n\n        members = instance.data.get(\"members\", [])\n\n        if not members:\n            raise RuntimeError(\"No members found in instance.\")\n\n        # UAsset publishing supports only one member\n        obj = members[0]\n\n        asset = ar.get_asset_by_object_path(obj).get_asset()\n        sys_path = unreal.SystemLibrary.get_system_path(asset)\n        filename = Path(sys_path).name\n\n        shutil.copy(sys_path, staging_dir)\n\n        self.log.info(f\"instance.data: {instance.data}\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": extension,\n            \"ext\": extension,\n            \"files\": filename,\n            \"stagingDir\": staging_dir,\n        }\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/switch_render_target.html","title":"switch_render_target","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/switch_render_target.html#client.ayon_unreal.plugins.publish.switch_render_target.SwitchRenderTargets","title":"<code>SwitchRenderTargets</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Switch between farm and local render targets.</p> Source code in <code>client/ayon_unreal/plugins/publish/switch_render_target.py</code> <pre><code>class SwitchRenderTargets(pyblish.api.InstancePlugin):\n    \"\"\"Switch between farm and local render targets.\"\"\"\n    order = pyblish.api.CollectorOrder - 0.499\n    families = [\"render\"]\n    label = \"Switch Render Targets\"\n\n    def process(self, instance):\n        self.log.debug(instance.data[\"creator_attributes\"])\n        render_target = (instance.data[\"creator_attributes\"].\n                         get(\"render_target\"))\n        if render_target == \"farm\":\n            self.log.debug(\"Rendering on farm\")\n            instance.data[\"families\"].append(\"render.farm\")\n            instance.data[\"farm\"] = True\n            return\n\n        self.log.debug(\"Using locally renderer files\")\n        instance.data[\"families\"].append(\"render.local\")\n        instance.data[\"farm\"] = False\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_actors_existing_in_scene.html","title":"validate_actors_existing_in_scene","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_actors_existing_in_scene.html#client.ayon_unreal.plugins.publish.validate_actors_existing_in_scene.SelectActorsAsInstanceMemberAction","title":"<code>SelectActorsAsInstanceMemberAction</code>","text":"<p>               Bases: <code>RepairAction</code></p> <p>Set selected actors as instance members as repairing action</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_actors_existing_in_scene.py</code> <pre><code>class SelectActorsAsInstanceMemberAction(RepairAction):\n    \"\"\"Set selected actors as instance members as repairing action\n    \"\"\"\n\n    label = \"Set selected actors as instance members\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"object-group\"\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_actors_existing_in_scene.html#client.ayon_unreal.plugins.publish.validate_actors_existing_in_scene.ValidateActorExistingInLayout","title":"<code>ValidateActorExistingInLayout</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure that the selected actor for layout exist in the scene.</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_actors_existing_in_scene.py</code> <pre><code>class ValidateActorExistingInLayout(pyblish.api.InstancePlugin):\n    \"\"\"Ensure that the selected actor for layout exist in the scene.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Layout Actors Existing in Scene\"\n    families = [\"layout\"]\n    hosts = [\"unreal\"]\n    actions = [SelectActorsAsInstanceMemberAction]\n\n    def process(self, instance):\n        eas = unreal.EditorActorSubsystem()\n        sel_actors = eas.get_all_level_actors()\n        members_lookup = set(instance.data.get(\"members\", []))\n        actors = [a for a in sel_actors if a.get_path_name() in members_lookup]\n        if not actors:\n            raise PublishValidationError(\n                \"Invalid actors for layout publish\\n\\n\"\n                \"Selected actors for publishing layout do not exist in \"\n                f\"the Unreal Scene: {actors}\\n\\n\"\n                \"You can select the actors and use repair action to update \"\n                \"the actors which you want to publish for the layout.\",\n                title=\"Non-existent Actors for Layout Publish\")\n\n    @classmethod\n    def repair(cls, instance):\n        actor_subsystem = unreal.EditorActorSubsystem()\n        sel_actors = actor_subsystem.get_selected_level_actors()\n        instance.data[\"members\"] = [a.get_path_name() for a in sel_actors]\n        instance_path = instance.data[\"instance_path\"]\n        imprint(instance_path, {\"members\": instance.data[\"members\"]})\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_camera_tracks.html","title":"validate_camera_tracks","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_camera_tracks.html#client.ayon_unreal.plugins.publish.validate_camera_tracks.ValidateCameraTracks","title":"<code>ValidateCameraTracks</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure that the camera tracks existing in the selected level sequence for publishing</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_camera_tracks.py</code> <pre><code>class ValidateCameraTracks(pyblish.api.InstancePlugin):\n    \"\"\"Ensure that the camera tracks existing\n    in the selected level sequence for publishing\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Camera Tracks\"\n    hosts = ['unreal']\n    families = [\"camera\"]\n    actions = [RepairAction]\n\n    def get_invalid(self, instance):\n        invalid = []\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        members = instance.data.get(\"members\", {})\n        if not members:\n            invalid.append(\"No assets selected for publishing.\")\n            return invalid\n        for member in members:\n            data = ar.get_asset_by_object_path(member)\n            is_level_sequence = (\n                data.asset_class_path.asset_name == \"LevelSequence\")\n            if not is_level_sequence:\n                invalid.append(\n                    \"The published assets must be Level Sequence\")\n            sequence = data.get_asset()\n            seq_name = sequence.get_name()\n            all_tracks = get_tracks(sequence)\n            if not all_tracks:\n                message = (\n                    f\"No tracks found in Level Sequence {seq_name}. You can perform\\n \"\n                    \"repair action to add camera track into the sequence\\n \"\n                    \"and assign the camera to the track you want to publish\\n\"\n                )\n                invalid.append(message)\n            has_movie_tracks = False\n            for track in all_tracks:\n                if str(track).count(\"MovieSceneCameraCutTrack\"):\n                    has_movie_tracks = True\n                    break\n            if not has_movie_tracks:\n                message = (\n                    f\"The level sequence {seq_name} does not include any Movie\\n \"\n                    \" Scene Camera Cut Track. Please make sure the published level\\n \"\n                    \"sequence must include Movie Scene Camera Cut Track.\"\n                )\n                invalid.append(message)\n        return invalid\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            report = \"{}\".format(err for err in invalid)\n            raise PublishValidationError(report, title=\"Invalid Camera Tracks\")\n\n    @classmethod\n    def repair(cls, instance):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        members = instance.data.get(\"members\", {})\n        for member in members:\n            data = ar.get_asset_by_object_path(member)\n            is_level_sequence = (\n                data.asset_class_path.asset_name == \"LevelSequence\")\n            if is_level_sequence:\n                sequence = data.get_asset()\n                add_track(sequence, unreal.MovieSceneCameraCutTrack)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_frame_range.html#client.ayon_unreal.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that the tracks aligns with the clipIn/clipOut value in database.</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(pyblish.api.InstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Ensure that the tracks aligns with the clipIn/clipOut\n    value in database.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Range\"\n    hosts = ['unreal']\n    families = [\"camera\"]\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Frame Range...\")\n            return\n\n        inst_clip_in = instance.data.get(\"clipIn\")\n        inst_clip_out = instance.data.get(\"clipOut\")\n        if inst_clip_in is None or inst_clip_out is None:\n            raise KnownPublishError(\n                \"Missing clip In and clip Out values on \"\n                \"instance to to validate.\"\n            )\n        clip_in_handle, clip_out_handle = get_frame_range_from_folder_attributes(\n            instance.data[\"folderEntity\"])\n        errors = []\n        if inst_clip_in != clip_in_handle:\n            errors.append(\n                f\"Clip-In value ({inst_clip_in}) on instance does not match \" # noqa\n                f\"with the Clip-In value ({clip_in_handle}) set on the folder attributes. \")    # noqa\n        if inst_clip_out != clip_out_handle:\n            errors.append(\n                f\"Clip-Out value ({inst_clip_out}) on instance does not match \"\n                f\"with the Clip-Out value ({clip_out_handle}) \"\n                \"from the folder attributes. \")\n\n        if errors:\n            bullet_point_errors = \"\\n\".join(\n                \"- {}\".format(err) for err in errors\n            )\n            report = (\n                \"Clip In/Out settings are incorrect.\\n\\n\"\n                f\"{bullet_point_errors}\\n\\n\"\n                \"You can use repair action to fix it.\"\n            )\n            raise PublishValidationError(report, title=\"Frame Range incorrect\")\n\n    @classmethod\n    def repair(cls, instance):\n        clip_in_handle, clip_out_handle = get_frame_range_from_folder_attributes(\n            instance.data[\"folderEntity\"])\n        for member in instance.data.get('members'):\n            ar = unreal.AssetRegistryHelpers.get_asset_registry()\n            data = ar.get_asset_by_object_path(member)\n            is_level_sequence = (\n                data.asset_class_path.asset_name == \"LevelSequence\")\n            if is_level_sequence:\n                sequence = data.get_asset()\n                camera_tracks = get_camera_tracks(sequence)\n                if not camera_tracks:\n                    return sequence.get_playback_start(), sequence.get_playback_end()\n                for camera_track in camera_tracks:\n                    sections = camera_track.get_sections()\n                    for section in sections:\n                        section.set_range(clip_in_handle, clip_out_handle)\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_model_content.html","title":"validate_model_content","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_model_content.html#client.ayon_unreal.plugins.publish.validate_model_content.ValidateNoDependencies","title":"<code>ValidateNoDependencies</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure the model contents are staticMesh</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_model_content.py</code> <pre><code>class ValidateNoDependencies(pyblish.api.InstancePlugin):\n    \"\"\"Ensure the model contents are staticMesh\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Model Content\"\n    families = [\"staticMesh\"]\n    hosts = [\"unreal\"]\n\n    def process(self, instance):\n        invalid_asset = []\n        members = set(instance.data.get(\"members\", []))\n        asset_registry = unreal.AssetRegistryHelpers.get_asset_registry()\n        for member in members:\n            asset = asset_registry.get_asset_by_object_path(member).get_asset()\n            if asset.get_class().get_name() != \"StaticMesh\":\n                invalid_asset.append(member)\n\n        if invalid_asset:\n            raise PublishValidationError(\n                f\"{invalid_asset} are not static Mesh.\", title=\"Incorrect Model Type\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_no_dependencies.html","title":"validate_no_dependencies","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_no_dependencies.html#client.ayon_unreal.plugins.publish.validate_no_dependencies.ValidateNoDependencies","title":"<code>ValidateNoDependencies</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure that the uasset has no dependencies</p> <p>The uasset is checked for dependencies. If there are any, the instance cannot be published.</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_no_dependencies.py</code> <pre><code>class ValidateNoDependencies(pyblish.api.InstancePlugin):\n    \"\"\"Ensure that the uasset has no dependencies\n\n    The uasset is checked for dependencies. If there are any, the instance\n    cannot be published.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Check no dependencies\"\n    families = [\"uasset\"]\n    hosts = [\"unreal\"]\n    optional = True\n\n    def process(self, instance):\n        ar = unreal.AssetRegistryHelpers.get_asset_registry()\n        all_dependencies = []\n\n        for obj in instance[:]:\n            asset = ar.get_asset_by_object_path(obj)\n            dependencies = ar.get_dependencies(\n                asset.package_name,\n                unreal.AssetRegistryDependencyOptions(\n                    include_soft_package_references=False,\n                    include_hard_package_references=True,\n                    include_searchable_names=False,\n                    include_soft_management_references=False,\n                    include_hard_management_references=False\n                ))\n            if dependencies:\n                for dep in dependencies:\n                    if str(dep).startswith(\"/Game/\"):\n                        all_dependencies.append(str(dep))\n\n        if all_dependencies:\n            raise RuntimeError(\n                f\"Dependencies found: {all_dependencies}\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_sequence_frames.html","title":"validate_sequence_frames","text":""},{"location":"autoapi/client/ayon_unreal/plugins/publish/validate_sequence_frames.html#client.ayon_unreal.plugins.publish.validate_sequence_frames.ValidateSequenceFrames","title":"<code>ValidateSequenceFrames</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure the sequence of frames is complete</p> <p>The files found in the folder are checked against the frameStart and frameEnd of the instance. If the first or last file is not corresponding with the first or last frame it is flagged as invalid.</p> Source code in <code>client/ayon_unreal/plugins/publish/validate_sequence_frames.py</code> <pre><code>class ValidateSequenceFrames(pyblish.api.InstancePlugin,\n                             OptionalPyblishPluginMixin):\n    \"\"\"Ensure the sequence of frames is complete\n\n    The files found in the folder are checked against the frameStart and\n    frameEnd of the instance. If the first or last file is not\n    corresponding with the first or last frame it is flagged as invalid.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Sequence Frames\"\n    families = [\"render.local\"]\n    hosts = [\"unreal\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Frame Range...\")\n            return\n\n        representations = instance.data.get(\"representations\")\n\n        folder_attributes = (\n            instance.data\n            .get(\"folderEntity\", {})\n            .get(\"attrib\", {})\n        )\n        for repr in representations:\n            repr_files = repr[\"files\"]\n            if isinstance(repr_files, str):\n                continue\n\n            ext = repr.get(\"ext\")\n            if not ext:\n                _, ext = os.path.splitext(repr_files[0])\n            elif not ext.startswith(\".\"):\n                ext = \".{}\".format(ext)\n\n            collections, remainder = clique.assemble(\n                repr[\"files\"], minimum_items=1,\n                patterns=[clique.PATTERNS['frames']])\n\n            if remainder:\n                raise PublishValidationError(\n                    \"Some files have been found outside a sequence. \"\n                    f\"Invalid files: {remainder}\")\n            if not collections:\n                raise PublishValidationError(\n                    \"We have been unable to find a sequence in the \"\n                    \"files. Please ensure the files are named \"\n                    \"appropriately. \"\n                    f\"Files: {repr_files}\")\n            if len(collections) &gt; 1:\n                raise PublishValidationError(\n                    \"Multiple collections detected. There should be a single \"\n                    \"collection per representation. \"\n                    f\"Collections identified: {collections}\")\n\n            collection = collections[0]\n            frames = list(collection.indexes)\n\n            if instance.data.get(\"slate\"):\n                # Slate is not part of the frame range\n                frames = frames[1:]\n\n            current_range = (frames[0], frames[-1])\n            required_range = (folder_attributes.get(\"clipIn\"),\n                              folder_attributes.get(\"clipOut\"))\n\n            if current_range != required_range:\n                raise PublishValidationError(\n                    f\"Invalid frame range: {current_range} - \"\n                    f\"expected: {required_range}\")\n\n            missing = collection.holes().indexes\n            if missing:\n                raise PublishValidationError(\n                    \"Missing frames have been detected. \"\n                    f\"Missing frames: {missing}\")\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html","title":"ui","text":""},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen","title":"<code>SplashScreen</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Splash screen for executing a process on another thread. It is able to inform about the progress of the process and log given information.</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>class SplashScreen(QtWidgets.QDialog):\n    \"\"\"Splash screen for executing a process on another thread. It is able\n    to inform about the progress of the process and log given information.\n    \"\"\"\n\n    splash_icon = None\n    top_label = None\n    show_log_btn: QtWidgets.QLabel = None\n    progress_bar = None\n    log_text: QtWidgets.QLabel = None\n    scroll_area: QtWidgets.QScrollArea = None\n    close_btn: QtWidgets.QPushButton = None\n    scroll_bar: QtWidgets.QScrollBar = None\n\n    is_log_visible = False\n    is_scroll_auto = True\n\n    thread_return_code = None\n    q_thread: QtCore.QThread = None\n\n    def __init__(self,\n                 window_title: str,\n                 splash_icon=None,\n                 window_icon=None):\n        \"\"\"\n        Args:\n            window_title (str): String which sets the window title\n            splash_icon (str | bytes | None): A resource (pic) which is used\n                for the splash icon\n            window_icon (str | bytes | None: A resource (pic) which is used for\n                the window's icon\n        \"\"\"\n        super().__init__()\n\n        if splash_icon is None:\n            splash_icon = resources.get_ayon_icon_filepath()\n\n        if window_icon is None:\n            window_icon = resources.get_ayon_icon_filepath()\n\n        self.splash_icon = splash_icon\n        self.setWindowIcon(QtGui.QIcon(window_icon))\n        self.setWindowTitle(window_title)\n        self.init_ui()\n\n        show_timer = QtCore.QTimer()\n        show_timer.timeout.connect(self._on_show_timer)\n\n        self._first_show = True\n        self._show_timer = show_timer\n\n    def was_proc_successful(self) -&gt; bool:\n        return self.thread_return_code == 0\n\n    def start_thread(self, q_thread: QtCore.QThread):\n        \"\"\"Saves the reference to this thread and starts it.\n\n        Args:\n            q_thread (QtCore.QThread): A QThread containing a given worker\n                (QtCore.QObject)\n\n        Returns:\n            None\n        \"\"\"\n        if not q_thread:\n            raise RuntimeError(\"Failed to run a worker thread! \"\n                               \"The thread is null!\")\n\n        self.q_thread = q_thread\n        self.q_thread.start()\n\n    @QtCore.Slot()\n    def quit_and_close(self):\n        \"\"\"Quits the thread and closes the splash screen. Note that this means\n        the thread has exited with the return code 0!\n\n        Returns:\n            None\n        \"\"\"\n        self.thread_return_code = 0\n        self.q_thread.quit()\n\n        if not self.q_thread.wait(5000):\n            raise RuntimeError(\"Failed to quit the QThread! \"\n                               \"The deadline has been reached! The thread \"\n                               \"has not finished it's execution!.\")\n        self.close()\n\n    @QtCore.Slot()\n    def toggle_log(self):\n        if self.is_log_visible:\n            self.scroll_area.hide()\n            width = self.width()\n            self.adjustSize()\n            self.resize(width, self.height())\n        else:\n            self.scroll_area.show()\n            self.scroll_bar.setValue(self.scroll_bar.maximum())\n            self.resize(self.width(), 300)\n\n        self.is_log_visible = not self.is_log_visible\n\n    def showEvent(self, event: QtGui.QShowEvent):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._show_timer.start()\n\n    def _on_show_timer(self):\n        screen = self.screen()\n        screen_geo = screen.geometry()\n        center = screen_geo.center()\n        self.move(\n            center.x() - int(self.width() * 0.5),\n            center.y() - int(self.height() * 0.5)\n        )\n\n    def show_ui(self):\n        \"\"\"Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING\n        (The execution of code can not proceed further beyond this function\n        until the splash screen is closed!)\n\n        Returns:\n            None\n        \"\"\"\n        self.show()\n        self.exec_()\n\n    def init_ui(self):\n        self.resize(450, 100)\n        self.setMinimumWidth(250)\n        self.setStyleSheet(style.load_stylesheet())\n\n        # Top Section\n        self.top_label = QtWidgets.QLabel(self)\n        self.top_label.setText(\"Starting process ...\")\n        self.top_label.setWordWrap(True)\n\n        icon = QtWidgets.QLabel(self)\n        icon.setPixmap(QtGui.QPixmap(self.splash_icon))\n        icon.setFixedHeight(45)\n        icon.setFixedWidth(45)\n        icon.setScaledContents(True)\n\n        self.close_btn = QtWidgets.QPushButton(self)\n        self.close_btn.setText(\"Quit\")\n        self.close_btn.clicked.connect(self.close)\n        self.close_btn.setFixedWidth(80)\n        self.close_btn.hide()\n\n        self.show_log_btn = QtWidgets.QPushButton(self)\n        self.show_log_btn.setText(\"Show log\")\n        self.show_log_btn.setFixedWidth(80)\n        self.show_log_btn.clicked.connect(self.toggle_log)\n\n        button_layout = QtWidgets.QVBoxLayout()\n        button_layout.addWidget(self.show_log_btn)\n        button_layout.addWidget(self.close_btn)\n\n        # Progress Bar\n        self.progress_bar = QtWidgets.QProgressBar()\n        self.progress_bar.setValue(0)\n        self.progress_bar.setAlignment(QtCore.Qt.AlignTop)\n\n        # Log Content\n        self.scroll_area = QtWidgets.QScrollArea(self)\n        self.scroll_area.hide()\n        log_widget = QtWidgets.QWidget(self.scroll_area)\n        self.scroll_area.setWidgetResizable(True)\n        self.scroll_area.setHorizontalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn\n        )\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn\n        )\n        self.scroll_area.setWidget(log_widget)\n\n        self.scroll_bar = self.scroll_area.verticalScrollBar()\n        self.scroll_bar.sliderMoved.connect(self.on_scroll)\n\n        self.log_text = QtWidgets.QLabel(self)\n        self.log_text.setText('')\n        self.log_text.setAlignment(QtCore.Qt.AlignTop)\n\n        log_layout = QtWidgets.QVBoxLayout(log_widget)\n        log_layout.addWidget(self.log_text)\n\n        top_layout = QtWidgets.QHBoxLayout()\n        top_layout.setAlignment(QtCore.Qt.AlignTop)\n        top_layout.addWidget(icon)\n        top_layout.addSpacing(10)\n        top_layout.addWidget(self.top_label)\n        top_layout.addSpacing(10)\n        top_layout.addLayout(button_layout)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.addLayout(top_layout)\n        main_layout.addSpacing(10)\n        main_layout.addWidget(self.progress_bar)\n        main_layout.addSpacing(10)\n        main_layout.addWidget(self.scroll_area)\n\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.CustomizeWindowHint\n            | QtCore.Qt.WindowTitleHint\n            | QtCore.Qt.WindowMinimizeButtonHint\n        )\n\n    @QtCore.Slot(int)\n    def update_progress(self, value: int):\n        self.progress_bar.setValue(value)\n\n    @QtCore.Slot(str)\n    def update_top_label_text(self, text: str):\n        self.top_label.setText(text)\n\n    @QtCore.Slot(str, str)\n    def append_log(self, text: str, end: str = ''):\n        \"\"\"A slot used for receiving log info and appending it to scroll area's\n            content.\n        Args:\n            text (str): A log text that will append to the current one in the\n                scroll area.\n            end (str): end string which can be appended to the end of the given\n                line (for ex. a line break).\n\n        Returns:\n            None\n        \"\"\"\n        self.log_text.setText(self.log_text.text() + text + end)\n        if self.is_scroll_auto:\n            self.scroll_bar.setValue(self.scroll_bar.maximum())\n\n    @QtCore.Slot(int)\n    def on_scroll(self, position: int):\n        \"\"\"\n        A slot for the vertical scroll bar's movement. This ensures the\n        auto-scrolling feature of the scroll area when the scroll bar is at its\n        maximum value.\n\n        Args:\n            position (int): Position value of the scroll bar.\n\n        Returns:\n             None\n        \"\"\"\n        if self.scroll_bar.maximum() == position:\n            self.is_scroll_auto = True\n            return\n\n        self.is_scroll_auto = False\n\n    @QtCore.Slot(str, int)\n    def fail(self, text: str, return_code: int = 1):\n        \"\"\"\n        A slot used for signals which can emit when a worker (process) has\n        failed. at this moment the splash screen doesn't close by itself.\n        it has to be closed by the user.\n\n        Args:\n            text (str): A text which can be set to the top label.\n\n        Returns:\n            return_code (int): Return code of the thread's code\n        \"\"\"\n        self.top_label.setText(text)\n        self.close_btn.show()\n        self.thread_return_code = return_code\n        self.q_thread.exit(return_code)\n        self.q_thread.wait()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.__init__","title":"<code>__init__(window_title, splash_icon=None, window_icon=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>window_title</code> <code>str</code> <p>String which sets the window title</p> required <code>splash_icon</code> <code>str | bytes | None</code> <p>A resource (pic) which is used for the splash icon</p> <code>None</code> <code>window_icon</code> <code>str | bytes | None</code> <p>A resource (pic) which is used for the window's icon</p> <code>None</code> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def __init__(self,\n             window_title: str,\n             splash_icon=None,\n             window_icon=None):\n    \"\"\"\n    Args:\n        window_title (str): String which sets the window title\n        splash_icon (str | bytes | None): A resource (pic) which is used\n            for the splash icon\n        window_icon (str | bytes | None: A resource (pic) which is used for\n            the window's icon\n    \"\"\"\n    super().__init__()\n\n    if splash_icon is None:\n        splash_icon = resources.get_ayon_icon_filepath()\n\n    if window_icon is None:\n        window_icon = resources.get_ayon_icon_filepath()\n\n    self.splash_icon = splash_icon\n    self.setWindowIcon(QtGui.QIcon(window_icon))\n    self.setWindowTitle(window_title)\n    self.init_ui()\n\n    show_timer = QtCore.QTimer()\n    show_timer.timeout.connect(self._on_show_timer)\n\n    self._first_show = True\n    self._show_timer = show_timer\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.append_log","title":"<code>append_log(text, end='')</code>","text":"<p>A slot used for receiving log info and appending it to scroll area's     content. Args:     text (str): A log text that will append to the current one in the         scroll area.     end (str): end string which can be appended to the end of the given         line (for ex. a line break).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(str, str)\ndef append_log(self, text: str, end: str = ''):\n    \"\"\"A slot used for receiving log info and appending it to scroll area's\n        content.\n    Args:\n        text (str): A log text that will append to the current one in the\n            scroll area.\n        end (str): end string which can be appended to the end of the given\n            line (for ex. a line break).\n\n    Returns:\n        None\n    \"\"\"\n    self.log_text.setText(self.log_text.text() + text + end)\n    if self.is_scroll_auto:\n        self.scroll_bar.setValue(self.scroll_bar.maximum())\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.fail","title":"<code>fail(text, return_code=1)</code>","text":"<p>A slot used for signals which can emit when a worker (process) has failed. at this moment the splash screen doesn't close by itself. it has to be closed by the user.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>A text which can be set to the top label.</p> required <p>Returns:</p> Name Type Description <code>return_code</code> <code>int</code> <p>Return code of the thread's code</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(str, int)\ndef fail(self, text: str, return_code: int = 1):\n    \"\"\"\n    A slot used for signals which can emit when a worker (process) has\n    failed. at this moment the splash screen doesn't close by itself.\n    it has to be closed by the user.\n\n    Args:\n        text (str): A text which can be set to the top label.\n\n    Returns:\n        return_code (int): Return code of the thread's code\n    \"\"\"\n    self.top_label.setText(text)\n    self.close_btn.show()\n    self.thread_return_code = return_code\n    self.q_thread.exit(return_code)\n    self.q_thread.wait()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.on_scroll","title":"<code>on_scroll(position)</code>","text":"<p>A slot for the vertical scroll bar's movement. This ensures the auto-scrolling feature of the scroll area when the scroll bar is at its maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Position value of the scroll bar.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(int)\ndef on_scroll(self, position: int):\n    \"\"\"\n    A slot for the vertical scroll bar's movement. This ensures the\n    auto-scrolling feature of the scroll area when the scroll bar is at its\n    maximum value.\n\n    Args:\n        position (int): Position value of the scroll bar.\n\n    Returns:\n         None\n    \"\"\"\n    if self.scroll_bar.maximum() == position:\n        self.is_scroll_auto = True\n        return\n\n    self.is_scroll_auto = False\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.quit_and_close","title":"<code>quit_and_close()</code>","text":"<p>Quits the thread and closes the splash screen. Note that this means the thread has exited with the return code 0!</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot()\ndef quit_and_close(self):\n    \"\"\"Quits the thread and closes the splash screen. Note that this means\n    the thread has exited with the return code 0!\n\n    Returns:\n        None\n    \"\"\"\n    self.thread_return_code = 0\n    self.q_thread.quit()\n\n    if not self.q_thread.wait(5000):\n        raise RuntimeError(\"Failed to quit the QThread! \"\n                           \"The deadline has been reached! The thread \"\n                           \"has not finished it's execution!.\")\n    self.close()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.show_ui","title":"<code>show_ui()</code>","text":"<p>Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING (The execution of code can not proceed further beyond this function until the splash screen is closed!)</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def show_ui(self):\n    \"\"\"Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING\n    (The execution of code can not proceed further beyond this function\n    until the splash screen is closed!)\n\n    Returns:\n        None\n    \"\"\"\n    self.show()\n    self.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/index.html#client.ayon_unreal.ui.SplashScreen.start_thread","title":"<code>start_thread(q_thread)</code>","text":"<p>Saves the reference to this thread and starts it.</p> <p>Parameters:</p> Name Type Description Default <code>q_thread</code> <code>QThread</code> <p>A QThread containing a given worker (QtCore.QObject)</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def start_thread(self, q_thread: QtCore.QThread):\n    \"\"\"Saves the reference to this thread and starts it.\n\n    Args:\n        q_thread (QtCore.QThread): A QThread containing a given worker\n            (QtCore.QObject)\n\n    Returns:\n        None\n    \"\"\"\n    if not q_thread:\n        raise RuntimeError(\"Failed to run a worker thread! \"\n                           \"The thread is null!\")\n\n    self.q_thread = q_thread\n    self.q_thread.start()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html","title":"splash_screen","text":""},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen","title":"<code>SplashScreen</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Splash screen for executing a process on another thread. It is able to inform about the progress of the process and log given information.</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>class SplashScreen(QtWidgets.QDialog):\n    \"\"\"Splash screen for executing a process on another thread. It is able\n    to inform about the progress of the process and log given information.\n    \"\"\"\n\n    splash_icon = None\n    top_label = None\n    show_log_btn: QtWidgets.QLabel = None\n    progress_bar = None\n    log_text: QtWidgets.QLabel = None\n    scroll_area: QtWidgets.QScrollArea = None\n    close_btn: QtWidgets.QPushButton = None\n    scroll_bar: QtWidgets.QScrollBar = None\n\n    is_log_visible = False\n    is_scroll_auto = True\n\n    thread_return_code = None\n    q_thread: QtCore.QThread = None\n\n    def __init__(self,\n                 window_title: str,\n                 splash_icon=None,\n                 window_icon=None):\n        \"\"\"\n        Args:\n            window_title (str): String which sets the window title\n            splash_icon (str | bytes | None): A resource (pic) which is used\n                for the splash icon\n            window_icon (str | bytes | None: A resource (pic) which is used for\n                the window's icon\n        \"\"\"\n        super().__init__()\n\n        if splash_icon is None:\n            splash_icon = resources.get_ayon_icon_filepath()\n\n        if window_icon is None:\n            window_icon = resources.get_ayon_icon_filepath()\n\n        self.splash_icon = splash_icon\n        self.setWindowIcon(QtGui.QIcon(window_icon))\n        self.setWindowTitle(window_title)\n        self.init_ui()\n\n        show_timer = QtCore.QTimer()\n        show_timer.timeout.connect(self._on_show_timer)\n\n        self._first_show = True\n        self._show_timer = show_timer\n\n    def was_proc_successful(self) -&gt; bool:\n        return self.thread_return_code == 0\n\n    def start_thread(self, q_thread: QtCore.QThread):\n        \"\"\"Saves the reference to this thread and starts it.\n\n        Args:\n            q_thread (QtCore.QThread): A QThread containing a given worker\n                (QtCore.QObject)\n\n        Returns:\n            None\n        \"\"\"\n        if not q_thread:\n            raise RuntimeError(\"Failed to run a worker thread! \"\n                               \"The thread is null!\")\n\n        self.q_thread = q_thread\n        self.q_thread.start()\n\n    @QtCore.Slot()\n    def quit_and_close(self):\n        \"\"\"Quits the thread and closes the splash screen. Note that this means\n        the thread has exited with the return code 0!\n\n        Returns:\n            None\n        \"\"\"\n        self.thread_return_code = 0\n        self.q_thread.quit()\n\n        if not self.q_thread.wait(5000):\n            raise RuntimeError(\"Failed to quit the QThread! \"\n                               \"The deadline has been reached! The thread \"\n                               \"has not finished it's execution!.\")\n        self.close()\n\n    @QtCore.Slot()\n    def toggle_log(self):\n        if self.is_log_visible:\n            self.scroll_area.hide()\n            width = self.width()\n            self.adjustSize()\n            self.resize(width, self.height())\n        else:\n            self.scroll_area.show()\n            self.scroll_bar.setValue(self.scroll_bar.maximum())\n            self.resize(self.width(), 300)\n\n        self.is_log_visible = not self.is_log_visible\n\n    def showEvent(self, event: QtGui.QShowEvent):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._show_timer.start()\n\n    def _on_show_timer(self):\n        screen = self.screen()\n        screen_geo = screen.geometry()\n        center = screen_geo.center()\n        self.move(\n            center.x() - int(self.width() * 0.5),\n            center.y() - int(self.height() * 0.5)\n        )\n\n    def show_ui(self):\n        \"\"\"Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING\n        (The execution of code can not proceed further beyond this function\n        until the splash screen is closed!)\n\n        Returns:\n            None\n        \"\"\"\n        self.show()\n        self.exec_()\n\n    def init_ui(self):\n        self.resize(450, 100)\n        self.setMinimumWidth(250)\n        self.setStyleSheet(style.load_stylesheet())\n\n        # Top Section\n        self.top_label = QtWidgets.QLabel(self)\n        self.top_label.setText(\"Starting process ...\")\n        self.top_label.setWordWrap(True)\n\n        icon = QtWidgets.QLabel(self)\n        icon.setPixmap(QtGui.QPixmap(self.splash_icon))\n        icon.setFixedHeight(45)\n        icon.setFixedWidth(45)\n        icon.setScaledContents(True)\n\n        self.close_btn = QtWidgets.QPushButton(self)\n        self.close_btn.setText(\"Quit\")\n        self.close_btn.clicked.connect(self.close)\n        self.close_btn.setFixedWidth(80)\n        self.close_btn.hide()\n\n        self.show_log_btn = QtWidgets.QPushButton(self)\n        self.show_log_btn.setText(\"Show log\")\n        self.show_log_btn.setFixedWidth(80)\n        self.show_log_btn.clicked.connect(self.toggle_log)\n\n        button_layout = QtWidgets.QVBoxLayout()\n        button_layout.addWidget(self.show_log_btn)\n        button_layout.addWidget(self.close_btn)\n\n        # Progress Bar\n        self.progress_bar = QtWidgets.QProgressBar()\n        self.progress_bar.setValue(0)\n        self.progress_bar.setAlignment(QtCore.Qt.AlignTop)\n\n        # Log Content\n        self.scroll_area = QtWidgets.QScrollArea(self)\n        self.scroll_area.hide()\n        log_widget = QtWidgets.QWidget(self.scroll_area)\n        self.scroll_area.setWidgetResizable(True)\n        self.scroll_area.setHorizontalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn\n        )\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn\n        )\n        self.scroll_area.setWidget(log_widget)\n\n        self.scroll_bar = self.scroll_area.verticalScrollBar()\n        self.scroll_bar.sliderMoved.connect(self.on_scroll)\n\n        self.log_text = QtWidgets.QLabel(self)\n        self.log_text.setText('')\n        self.log_text.setAlignment(QtCore.Qt.AlignTop)\n\n        log_layout = QtWidgets.QVBoxLayout(log_widget)\n        log_layout.addWidget(self.log_text)\n\n        top_layout = QtWidgets.QHBoxLayout()\n        top_layout.setAlignment(QtCore.Qt.AlignTop)\n        top_layout.addWidget(icon)\n        top_layout.addSpacing(10)\n        top_layout.addWidget(self.top_label)\n        top_layout.addSpacing(10)\n        top_layout.addLayout(button_layout)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.addLayout(top_layout)\n        main_layout.addSpacing(10)\n        main_layout.addWidget(self.progress_bar)\n        main_layout.addSpacing(10)\n        main_layout.addWidget(self.scroll_area)\n\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.CustomizeWindowHint\n            | QtCore.Qt.WindowTitleHint\n            | QtCore.Qt.WindowMinimizeButtonHint\n        )\n\n    @QtCore.Slot(int)\n    def update_progress(self, value: int):\n        self.progress_bar.setValue(value)\n\n    @QtCore.Slot(str)\n    def update_top_label_text(self, text: str):\n        self.top_label.setText(text)\n\n    @QtCore.Slot(str, str)\n    def append_log(self, text: str, end: str = ''):\n        \"\"\"A slot used for receiving log info and appending it to scroll area's\n            content.\n        Args:\n            text (str): A log text that will append to the current one in the\n                scroll area.\n            end (str): end string which can be appended to the end of the given\n                line (for ex. a line break).\n\n        Returns:\n            None\n        \"\"\"\n        self.log_text.setText(self.log_text.text() + text + end)\n        if self.is_scroll_auto:\n            self.scroll_bar.setValue(self.scroll_bar.maximum())\n\n    @QtCore.Slot(int)\n    def on_scroll(self, position: int):\n        \"\"\"\n        A slot for the vertical scroll bar's movement. This ensures the\n        auto-scrolling feature of the scroll area when the scroll bar is at its\n        maximum value.\n\n        Args:\n            position (int): Position value of the scroll bar.\n\n        Returns:\n             None\n        \"\"\"\n        if self.scroll_bar.maximum() == position:\n            self.is_scroll_auto = True\n            return\n\n        self.is_scroll_auto = False\n\n    @QtCore.Slot(str, int)\n    def fail(self, text: str, return_code: int = 1):\n        \"\"\"\n        A slot used for signals which can emit when a worker (process) has\n        failed. at this moment the splash screen doesn't close by itself.\n        it has to be closed by the user.\n\n        Args:\n            text (str): A text which can be set to the top label.\n\n        Returns:\n            return_code (int): Return code of the thread's code\n        \"\"\"\n        self.top_label.setText(text)\n        self.close_btn.show()\n        self.thread_return_code = return_code\n        self.q_thread.exit(return_code)\n        self.q_thread.wait()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.__init__","title":"<code>__init__(window_title, splash_icon=None, window_icon=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>window_title</code> <code>str</code> <p>String which sets the window title</p> required <code>splash_icon</code> <code>str | bytes | None</code> <p>A resource (pic) which is used for the splash icon</p> <code>None</code> <code>window_icon</code> <code>str | bytes | None</code> <p>A resource (pic) which is used for the window's icon</p> <code>None</code> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def __init__(self,\n             window_title: str,\n             splash_icon=None,\n             window_icon=None):\n    \"\"\"\n    Args:\n        window_title (str): String which sets the window title\n        splash_icon (str | bytes | None): A resource (pic) which is used\n            for the splash icon\n        window_icon (str | bytes | None: A resource (pic) which is used for\n            the window's icon\n    \"\"\"\n    super().__init__()\n\n    if splash_icon is None:\n        splash_icon = resources.get_ayon_icon_filepath()\n\n    if window_icon is None:\n        window_icon = resources.get_ayon_icon_filepath()\n\n    self.splash_icon = splash_icon\n    self.setWindowIcon(QtGui.QIcon(window_icon))\n    self.setWindowTitle(window_title)\n    self.init_ui()\n\n    show_timer = QtCore.QTimer()\n    show_timer.timeout.connect(self._on_show_timer)\n\n    self._first_show = True\n    self._show_timer = show_timer\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.append_log","title":"<code>append_log(text, end='')</code>","text":"<p>A slot used for receiving log info and appending it to scroll area's     content. Args:     text (str): A log text that will append to the current one in the         scroll area.     end (str): end string which can be appended to the end of the given         line (for ex. a line break).</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(str, str)\ndef append_log(self, text: str, end: str = ''):\n    \"\"\"A slot used for receiving log info and appending it to scroll area's\n        content.\n    Args:\n        text (str): A log text that will append to the current one in the\n            scroll area.\n        end (str): end string which can be appended to the end of the given\n            line (for ex. a line break).\n\n    Returns:\n        None\n    \"\"\"\n    self.log_text.setText(self.log_text.text() + text + end)\n    if self.is_scroll_auto:\n        self.scroll_bar.setValue(self.scroll_bar.maximum())\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.fail","title":"<code>fail(text, return_code=1)</code>","text":"<p>A slot used for signals which can emit when a worker (process) has failed. at this moment the splash screen doesn't close by itself. it has to be closed by the user.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>A text which can be set to the top label.</p> required <p>Returns:</p> Name Type Description <code>return_code</code> <code>int</code> <p>Return code of the thread's code</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(str, int)\ndef fail(self, text: str, return_code: int = 1):\n    \"\"\"\n    A slot used for signals which can emit when a worker (process) has\n    failed. at this moment the splash screen doesn't close by itself.\n    it has to be closed by the user.\n\n    Args:\n        text (str): A text which can be set to the top label.\n\n    Returns:\n        return_code (int): Return code of the thread's code\n    \"\"\"\n    self.top_label.setText(text)\n    self.close_btn.show()\n    self.thread_return_code = return_code\n    self.q_thread.exit(return_code)\n    self.q_thread.wait()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.on_scroll","title":"<code>on_scroll(position)</code>","text":"<p>A slot for the vertical scroll bar's movement. This ensures the auto-scrolling feature of the scroll area when the scroll bar is at its maximum value.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int</code> <p>Position value of the scroll bar.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot(int)\ndef on_scroll(self, position: int):\n    \"\"\"\n    A slot for the vertical scroll bar's movement. This ensures the\n    auto-scrolling feature of the scroll area when the scroll bar is at its\n    maximum value.\n\n    Args:\n        position (int): Position value of the scroll bar.\n\n    Returns:\n         None\n    \"\"\"\n    if self.scroll_bar.maximum() == position:\n        self.is_scroll_auto = True\n        return\n\n    self.is_scroll_auto = False\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.quit_and_close","title":"<code>quit_and_close()</code>","text":"<p>Quits the thread and closes the splash screen. Note that this means the thread has exited with the return code 0!</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>@QtCore.Slot()\ndef quit_and_close(self):\n    \"\"\"Quits the thread and closes the splash screen. Note that this means\n    the thread has exited with the return code 0!\n\n    Returns:\n        None\n    \"\"\"\n    self.thread_return_code = 0\n    self.q_thread.quit()\n\n    if not self.q_thread.wait(5000):\n        raise RuntimeError(\"Failed to quit the QThread! \"\n                           \"The deadline has been reached! The thread \"\n                           \"has not finished it's execution!.\")\n    self.close()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.show_ui","title":"<code>show_ui()</code>","text":"<p>Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING (The execution of code can not proceed further beyond this function until the splash screen is closed!)</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def show_ui(self):\n    \"\"\"Shows the splash screen. BEWARE THAT THIS FUNCTION IS BLOCKING\n    (The execution of code can not proceed further beyond this function\n    until the splash screen is closed!)\n\n    Returns:\n        None\n    \"\"\"\n    self.show()\n    self.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_unreal/ui/splash_screen.html#client.ayon_unreal.ui.splash_screen.SplashScreen.start_thread","title":"<code>start_thread(q_thread)</code>","text":"<p>Saves the reference to this thread and starts it.</p> <p>Parameters:</p> Name Type Description Default <code>q_thread</code> <code>QThread</code> <p>A QThread containing a given worker (QtCore.QObject)</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_unreal/ui/splash_screen.py</code> <pre><code>def start_thread(self, q_thread: QtCore.QThread):\n    \"\"\"Saves the reference to this thread and starts it.\n\n    Args:\n        q_thread (QtCore.QThread): A QThread containing a given worker\n            (QtCore.QObject)\n\n    Returns:\n        None\n    \"\"\"\n    if not q_thread:\n        raise RuntimeError(\"Failed to run a worker thread! \"\n                           \"The thread is null!\")\n\n    self.q_thread = q_thread\n    self.q_thread.start()\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/import_settings.html","title":"import_settings","text":""},{"location":"autoapi/server/pre_launch_settings.html","title":"pre_launch_settings","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}